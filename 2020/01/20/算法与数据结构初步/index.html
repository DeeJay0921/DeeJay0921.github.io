<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>算法与数据结构初步 | DeeJay's Blog</title><meta name="description" content="算法与数据结构初步"><meta name="keywords" content="Java,数据结构,算法"><meta name="author" content="DeeJay"><meta name="copyright" content="DeeJay"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="算法与数据结构初步"><meta name="twitter:description" content="算法与数据结构初步"><meta name="twitter:image" content="https://cn.bing.com/th?id=OIP.Pq_hBkZvOtJHoUqhmlgA1AHaDv&amp;pid=Api&amp;rs=1"><meta property="og:type" content="article"><meta property="og:title" content="算法与数据结构初步"><meta property="og:url" content="https://deejay0921.github.io/2020/01/20/算法与数据结构初步/"><meta property="og:site_name" content="DeeJay's Blog"><meta property="og:description" content="算法与数据结构初步"><meta property="og:image" content="https://cn.bing.com/th?id=OIP.Pq_hBkZvOtJHoUqhmlgA1AHaDv&amp;pid=Api&amp;rs=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://deejay0921.github.io/2020/01/20/算法与数据结构初步/"><link rel="prev" title="Java中的字符串" href="https://deejay0921.github.io/2020/02/09/Java中的字符串/"><link rel="next" title="Java之Stream" href="https://deejay0921.github.io/2020/01/17/Java之Stream/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'false',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'false',
  Snackbar: undefined
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">DeeJay's Blog</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="https://avatars1.githubusercontent.com/u/20784273?s=400&amp;u=ba38b4835b7e3c4960763bc6dce9abb320c43f05&amp;v=4" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">159</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">102</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">10</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#算法和数据结构的重要性"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">算法和数据结构的重要性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#算法的复杂度"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">算法的复杂度</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#一些常用算法举例"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">一些常用算法举例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#基本数据结构"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">基本数据结构</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#数组"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">数组</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#链表"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">链表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#栈"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">栈</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#队列"><span class="toc_mobile_items-number">4.4.</span> <span class="toc_mobile_items-text">队列</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#哈希表"><span class="toc_mobile_items-number">4.5.</span> <span class="toc_mobile_items-text">哈希表</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#查找-插入-删除操作都是O-1"><span class="toc_mobile_items-number">4.5.1.</span> <span class="toc_mobile_items-text">查找/插入/删除操作都是O(1)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#哈希算法与碰撞"><span class="toc_mobile_items-number">4.5.2.</span> <span class="toc_mobile_items-text">哈希算法与碰撞</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#哈希桶的内部实现及源码解析"><span class="toc_mobile_items-number">4.5.3.</span> <span class="toc_mobile_items-text">哈希桶的内部实现及源码解析</span></a></li></ol></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#算法和数据结构的重要性"><span class="toc-number">1.</span> <span class="toc-text">算法和数据结构的重要性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#算法的复杂度"><span class="toc-number">2.</span> <span class="toc-text">算法的复杂度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一些常用算法举例"><span class="toc-number">3.</span> <span class="toc-text">一些常用算法举例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基本数据结构"><span class="toc-number">4.</span> <span class="toc-text">基本数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-number">4.1.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#链表"><span class="toc-number">4.2.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈"><span class="toc-number">4.3.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#队列"><span class="toc-number">4.4.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#哈希表"><span class="toc-number">4.5.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#查找-插入-删除操作都是O-1"><span class="toc-number">4.5.1.</span> <span class="toc-text">查找/插入/删除操作都是O(1)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哈希算法与碰撞"><span class="toc-number">4.5.2.</span> <span class="toc-text">哈希算法与碰撞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哈希桶的内部实现及源码解析"><span class="toc-number">4.5.3.</span> <span class="toc-text">哈希桶的内部实现及源码解析</span></a></li></ol></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cn.bing.com/th?id=OIP.Pq_hBkZvOtJHoUqhmlgA1AHaDv&amp;pid=Api&amp;rs=1)"><div id="post-info"><div id="post-title"><div class="posttitle">算法与数据结构初步</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-01-20<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-03-05</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/算法/">算法</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/算法/数据结构/">数据结构</a></span><div class="post-meta-wordcount"><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>对常见的数据结构和算法做一个初步的了解</p>
<a id="more"></a>

<h1 id="算法和数据结构的重要性"><a href="#算法和数据结构的重要性" class="headerlink" title="算法和数据结构的重要性"></a>算法和数据结构的重要性</h1><ul>
<li>程序 = 算法 + 数据机构</li>
<li>其是计算机世界的基石，是一个开发者的内功</li>
<li>掌握好算法及数据结构之后，对代码效率的提升是本质性的</li>
</ul>
<h1 id="算法的复杂度"><a href="#算法的复杂度" class="headerlink" title="算法的复杂度"></a>算法的复杂度</h1><p>即对一个算法的复杂程度的数学描述</p>
<ul>
<li>时间复杂度<ul>
<li><code>O(1)</code> - 哈希桶/数组随机寻址 （常数）即解决问题的时间和问题规模无关，比如数组寻址，无论多大的数组，只要在连续内存中，CPU都能很快返回结果</li>
<li><code>O(N)</code> - 遍历（线性）</li>
<li><code>O(log(n))</code> - 二分查找，二叉树（对数）</li>
<li><code>O(n*log(n))</code> - 基于比较的排序算法的下界</li>
<li><code>O(n^2)</code> - 冒泡排序（平方）</li>
</ul>
</li>
<li>时间复杂度的计算是<strong>忽略</strong>常数的<ul>
<li>即<code>O(2n) == O(n)</code></li>
</ul>
</li>
<li>时间复杂度的计算中，高阶复杂度会吞掉低阶复杂度<ul>
<li>比如 <code>O(n^2) + O(n) == O(n^2)</code></li>
</ul>
</li>
</ul>
<h1 id="一些常用算法举例"><a href="#一些常用算法举例" class="headerlink" title="一些常用算法举例"></a>一些常用算法举例</h1><ul>
<li><a href="https://github.com/DeeJay0921/basic-algorithm-data-structure-demos/blob/master/src/main/java/com/github/DeeJay0921/Algorithm/BinaryTreeBfsDfs.java" target="_blank" rel="noopener">二叉树的深度/广度优先遍历</a></li>
<li><a href="https://github.com/DeeJay0921/basic-algorithm-data-structure-demos/blob/master/src/main/java/com/github/DeeJay0921/Algorithm/BinarySearch.java" target="_blank" rel="noopener">二分法查找</a></li>
<li><a href="https://github.com/DeeJay0921/basic-algorithm-data-structure-demos/blob/master/src/main/java/com/github/DeeJay0921/Algorithm/RecusionBinarySearch.java" target="_blank" rel="noopener">二分法查找（递归）</a></li>
<li><a href="https://github.com/DeeJay0921/basic-algorithm-data-structure-demos/blob/master/src/main/java/com/github/DeeJay0921/Algorithm/Sort.java" target="_blank" rel="noopener">常见的排序算法</a></li>
</ul>
<h1 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>随机寻址<ul>
<li>常数时间</li>
</ul>
</li>
<li>插入<ul>
<li>线性时间</li>
</ul>
</li>
<li>查找<ul>
<li>无序：线性时间</li>
<li>有序：对数时间（二分查找）</li>
</ul>
</li>
</ul>
<p>接下来手写一个二分查找：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 假设 数组是从小到大排好序的</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[start] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> start;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (array[end] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; array[start] || target &gt; array[end]) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; array[mid]) &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; array[mid]) &#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(binarySearch(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">20</span>&#125;, <span class="number">15</span>));</span><br><span class="line">        System.out.println(binarySearch(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">20</span>&#125;, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>和数组不同，<strong>数组是内存中连续的一系列地址</strong>，注意数组一定是<strong>连续的</strong>，</p>
<p>而链表则像一串珠子，每有新元素的时候，新开辟一块空间，后面元素中保存前一元素的地址</p>
<p>上述特性决定了链表的寻址是比较慢的（线性时间），因为只能从第一个元素开始一直往后找找到目标元素</p>
<p>但是链表的插入和删除则非常快，不会有像数组一样需要新增或者删除元素时后面的元素都得顺位移动</p>
<p>链表只需要将目标节点存储的前后节点的地址改变即可</p>
<blockquote>
<p>关于单向链表（单链表）和双链表的区别：单链表每一个节点只保存着下一个节点的地址，而双链表保存着前一个和后一个节点的地址</p>
</blockquote>
<p>手写一个简易的单链表例子来说明上述的链表结构和特性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单向链表（单链表)的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    Integer address; <span class="comment">// 简易实现 用Integer表示内存地址</span></span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Integer address, Node next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 声明3个节点</span></span><br><span class="line">        Node head = <span class="keyword">new</span> Node(<span class="number">1</span>, <span class="keyword">null</span>);</span><br><span class="line">        Node second = <span class="keyword">new</span> Node(<span class="number">2</span>, <span class="keyword">null</span>);</span><br><span class="line">        Node third = <span class="keyword">new</span> Node(<span class="number">3</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 将节点们串起来</span></span><br><span class="line">        head.next = second;</span><br><span class="line">        second.next = third;</span><br><span class="line">        <span class="comment">// 在这里就得到了一个简易的单向链表 可以使用debugger查看其内部结构</span></span><br><span class="line">        <span class="comment">// 对于链表的特殊结构，使用for循环遍历方法也有不同：</span></span><br><span class="line">        <span class="keyword">for</span> (Node currentNode = head; currentNode != <span class="keyword">null</span>; currentNode = currentNode.next) &#123;</span><br><span class="line">            System.out.println(currentNode.address);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述例子中，展示了一个单链表的结构和特性，下来写一个简易的双链表来展示链表的新增/删除元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双链表的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    Integer address; <span class="comment">// 简易实现 用Integer表示内存地址</span></span><br><span class="line">    Node next;</span><br><span class="line">    Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Integer address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 声明3个节点</span></span><br><span class="line">        Node head = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        Node second = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        Node third = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 将节点们串起来</span></span><br><span class="line">        head.next = second;</span><br><span class="line">        second.prev = head;</span><br><span class="line">        second.next = third;</span><br><span class="line">        third.prev = second;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Node currentNode = head; currentNode != <span class="keyword">null</span>; currentNode = currentNode.next) &#123;</span><br><span class="line">            <span class="comment">// 在这里对地址为2的节点进行删除</span></span><br><span class="line">            <span class="keyword">if</span> (currentNode.address == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 将上一个节点存储的下一个节点的地址改为当前节点的下一个节点的地址</span></span><br><span class="line">                currentNode.prev.next = currentNode.next;</span><br><span class="line">                currentNode.next.prev = currentNode.prev; <span class="comment">// 更改当前节点下一个节点的prev为当前节点的prev</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/DeeJay0921/basic-algorithm-data-structure-demos/blob/master/src/main/java/com/github/DeeJay0921/DataStructure/CreateDoublyLinkedList.java" target="_blank" rel="noopener">完整的双链表实现</a></p>
<ul>
<li>寻址<ul>
<li>线性时间</li>
</ul>
</li>
<li>插入/删除<ul>
<li>常数时间</li>
</ul>
</li>
<li>查找<ul>
<li>线性时间</li>
</ul>
</li>
</ul>
<p>来看一个手写<strong>翻转单链表</strong>的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package com.github.hcsp.datastructure;</span><br><span class="line"></span><br><span class="line">public class ReverseLinkedList &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Node node1 = new Node(1);</span><br><span class="line">        Node node2 = new Node(2);</span><br><span class="line">        node1.next = node2;</span><br><span class="line">        Node node3 = new Node(3);</span><br><span class="line">        node2.next = node3;</span><br><span class="line">        Node node4 = new Node(4);</span><br><span class="line">        node3.next = node4;</span><br><span class="line"></span><br><span class="line">        print(node1);</span><br><span class="line">        print(reverse(node1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 原地翻转一个单链表</span><br><span class="line">    // 传递的参数是原始链表的头节点</span><br><span class="line">    // 返回翻转后的链表的头节点</span><br><span class="line">    public static Node reverse(Node head) &#123;</span><br><span class="line">        Node prev = null;</span><br><span class="line">        Node pointer = head;</span><br><span class="line">        Node temp;</span><br><span class="line">        while (pointer != null) &#123;</span><br><span class="line">            temp = pointer.next;</span><br><span class="line">            pointer.next = prev;</span><br><span class="line">            </span><br><span class="line">            prev = pointer;</span><br><span class="line">            pointer = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Node &#123;</span><br><span class="line">        int value;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        public Node(int value) &#123;</span><br><span class="line">            this.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void print(Node head) &#123;</span><br><span class="line">        Node current = head;</span><br><span class="line">        while (current != null) &#123;</span><br><span class="line">            System.out.print(current.value);</span><br><span class="line">            if (current.next != null) &#123;</span><br><span class="line">                System.out.print(&quot;-&gt;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想简单点实现的话，直接使用一个栈结构将单链表遍历一遍设置<code>next</code>即可。</p>
<p>再看一个<strong>判断链表是否成环</strong>的例子：</p>
<p>想判断链表是否成环，主要的判断思路为：</p>
<blockquote>
<p>从同一个起点同时开始以不同速度前进的<code>2</code>个指针最终相遇，那么可以判定存在一个环。</p>
</blockquote>
<p>所以主要的判断方法为：</p>
<blockquote>
<p>先设置两个指针都指向表头，其中<code>p1</code>每次前进一个节点，<code>p2</code>每次前进两个节点，且<code>p1</code>和<code>p2</code>同时走，<br>当<code>p2</code>指向的地址为<code>null</code>，就证明链表没有环。如果在某个时刻，<code>p1</code>和<code>p2</code>指向的地址相同，那么链表就是有环的。</p>
</blockquote>
<p>简单实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判断一个单链表是否成环</span><br><span class="line"> * @param head 单链表的头结点</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private static boolean isCircle(Node head) &#123;</span><br><span class="line">    if (head == null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //定义两个指针为同一起点</span><br><span class="line">    Node n1 = head;   //慢指针</span><br><span class="line">    Node n2 = head;   //快指针</span><br><span class="line">    //只要有环的话，这个循环条件就绝对会满足，如果没有环的话，到了最后总不满足</span><br><span class="line">    while(n2.next != null &amp;&amp; n2.next.next != null) &#123;</span><br><span class="line">        n1 = n1.next; //n1一次走一步</span><br><span class="line">        n2 = n2.next.next; //n2一次走两步</span><br><span class="line">        if (n1 == n2) &#123;  //如果成环，总会有一点n1==n2</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul>
<li>FILO(First In Last Out)</li>
</ul>
<p>栈可以理解成一个杯子或者桶，先放进去的后拿出来</p>
<p>在Java虚拟机中，所有方法的调用都是在方法栈中的，最开始只有一个<code>Main</code>方法,每当一个方法调用的时候，会形成一个栈帧，该方法会被压入栈中</p>
<p>在多个方法嵌套调用时，后调用的先出栈</p>
<p><a href="https://github.com/DeeJay0921/basic-algorithm-data-structure-demos/blob/master/src/main/java/com/github/DeeJay0921/DataStructure/ImplementStack.java" target="_blank" rel="noopener">手动实现一个简易的<code>Stack</code></a></p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ul>
<li>FIFO(First In First Out)</li>
</ul>
<p>队列和栈是相对的，队列是先进去的先出来</p>
<p><a href="https://github.com/DeeJay0921/basic-algorithm-data-structure-demos/blob/master/src/main/java/com/github/DeeJay0921/DataStructure/ImplementQueue.java" target="_blank" rel="noopener">手动实现一个简易的<code>Queue</code></a></p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="查找-插入-删除操作都是O-1"><a href="#查找-插入-删除操作都是O-1" class="headerlink" title="查找/插入/删除操作都是O(1)"></a>查找/插入/删除操作都是<code>O(1)</code></h3><p>哈希表内部有若干个桶，称为哈希桶，根据存储的对象们的特点，将其分为若干个哈希桶。</p>
<p>举个例子，比如有张三，李四，王五，赵六四个人，传统的数据结构中就是一股脑的将其存进去</p>
<p>而哈希表根据要存储的对象，将其分为了若干个桶，比如说本例中根据姓氏分为了张，李，王，赵 4个哈希桶</p>
<p>那么我们在检索是否存在张三时，就不需要像传统数据结构那样去检索整个结构，而是只需要去姓张的桶里查找即可</p>
<p>这个根据对象计算出不同的值从而分出不同的桶的过程就叫<strong>哈希运算</strong></p>
<p>哈希表就是通过哈希运算将大规模的对象检索平摊到了若干个哈希桶的检索</p>
<h3 id="哈希算法与碰撞"><a href="#哈希算法与碰撞" class="headerlink" title="哈希算法与碰撞"></a>哈希算法与碰撞</h3><p>上述例子中提到的哈希运算，体现在代码里就是<code>Object.hashCode()</code>, 哈希表的愿望是将所有存储的对象近乎平均的分到每一个哈希桶里面去</p>
<p>然而存在一个问题是，我们<code>hashCode</code>的返回值为<code>int</code>，而<code>int</code>最多只有42亿，即最多只能有这么多桶，但是<code>Java</code>世界中的对象种类则为正无穷</p>
<p>所以肯定会出现哈希桶的碰撞，即同一个桶中数据过多的情况</p>
<p>比方说我现在有一个<code>HashMap</code>，内部有100个桶，我要存一百个元素，但是发生了最极端的碰撞，100个对象都存在了同一个桶中，而剩下的99个桶都是空的</p>
<p>这就引起了一个问题，此时检索<code>HashMap</code>跟检索一个链表的复杂度是一样的，原本理想的复杂度<code>O(1)</code>下降到了<code>O(n)</code></p>
<blockquote>
<p>HashMap的每一个桶内部都是一个链表，而在Java8之后，桶内部的实现是链表+红黑树，规模大了（目前超过8个会变为红黑树）会变为红黑树提升性能</p>
</blockquote>
<h3 id="哈希桶的内部实现及源码解析"><a href="#哈希桶的内部实现及源码解析" class="headerlink" title="哈希桶的内部实现及源码解析"></a>哈希桶的内部实现及源码解析</h3><p><code>Java7</code>中的<code>HashMap</code>的实现为数组+链表，桶的底层为一个数组，因为其寻址快，而每个桶存储内容的数据结构为一个链表</p>
<p>先从<code>Java7</code>的<code>HashMap</code>开始说起</p>
<p>查看源码，我们可以看到，<strong>默认容量</strong>必须为2的次幂（因为必须要进行左移运算，所以必须为2的次幂），且初始为16</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The default initial capacity - MUST be a power of two.</span><br><span class="line"> */</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br></pre></td></tr></table></figure>

<p><strong>最大容量</strong>为: <code>MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</code>即<code>2^30</code></p>
<p>而为什么哈希桶的数量一定要是2的次幂呢，原因是在进行计算要将对象放在哪个桶里的时候，进行了一个计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash &amp; (length - 1)</span><br></pre></td></tr></table></figure>

<p>长度减一然后和<code>hash</code>进行按位与,因为<code>length</code>为2的次幂，所以二进制的<code>length - 1</code>绝对会是<code>11111111</code>这种全为1的数，</p>
<p>再和<code>hash</code>进行按位与之后，保存的还是<code>hash</code>值作为数组下标，而如果不是2的次幂的话，减一之后位数上会出现0，按位与之后会造成有些桶是空的</p>
<p>而在不断put之后，在超过当前容量*负载因素的这个计算值之后(默认为16 * 0.75 = 12个)之后就开始扩容<code>resize</code>,扩容时还要重新计算所有桶的哈希值（rehash）</p>
<p>扩容默认也是扩大一倍,扩容之后将原有的内容重新计算hash之后移到新的容器中去，另外<code>resize</code>很消耗性能，初始化的时候尽量选取容量合适的<code>HashMap</code></p>
<p>详细的代码不再赘述，总结一下Java7的HashMap的问题：</p>
<ul>
<li>并发环境中容易造成死锁（形成环形链表，一直卡在<code>get()</code>）</li>
<li>容易发生碰撞，对于<code>String</code>等的<code>HashCode()</code>可以设计哈希值相等的字符进行DOS攻击（比如拼接http请求字符串，攻击tomcat）</li>
</ul>
<p>Java8之后对上述问题做了改进：</p>
<ul>
<li>数组（桶底层）和 链表+红黑树（桶内部）</li>
<li>扩容时插入顺序改进, 做了保持顺序的处理，减少了出现死锁的概率，但是仍然是线程不安全的</li>
<li>函数方法<ul>
<li><code>forEach</code></li>
<li><code>compute</code></li>
</ul>
</li>
<li><code>Map</code>的新<code>API</code><ul>
<li><code>merge</code></li>
<li><code>replace</code></li>
</ul>
</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">DeeJay</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://deejay0921.github.io/2020/01/20/算法与数据结构初步/">https://deejay0921.github.io/2020/01/20/算法与数据结构初步/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://deejay0921.github.io">DeeJay's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java    </a><a class="post-meta__tags" href="/tags/数据结构/">数据结构    </a><a class="post-meta__tags" href="/tags/算法/">算法    </a></div><div class="post_share"><div class="social-share" data-image="https://cn.bing.com/th?id=OIP.Pq_hBkZvOtJHoUqhmlgA1AHaDv&amp;pid=Api&amp;rs=1" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/02/09/Java中的字符串/"><img class="prev_cover lazyload" data-src="https://cdn.edureka.co/blog/wp-content/uploads/2017/05/Java-String.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>Java中的字符串</span></div></a></div><div class="next-post pull_right"><a href="/2020/01/17/Java之Stream/"><img class="next_cover lazyload" data-src="https://cdn.journaldev.com/wp-content/uploads/2014/04/java-8-stream.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Java之Stream</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/02/09/几类常见的数据结构(哈希表，栈，队列)的简单了解/" title="几类常见的数据结构(哈希表，栈，队列)的简单了解"><img class="relatedPosts_cover lazyload" data-src="https://revistadigital.inesem.es/informatica-y-tics/files/2015/10/inesem-java-1024x768.jpg"><div class="relatedPosts_title">几类常见的数据结构(哈希表，栈，队列)的简单了解</div></a></div><div class="relatedPosts_item"><a href="/2019/07/14/Java中的面向对象/" title="Java中的面向对象"><img class="relatedPosts_cover lazyload" data-src="https://revistadigital.inesem.es/informatica-y-tics/files/2015/10/inesem-java-1024x768.jpg"><div class="relatedPosts_title">Java中的面向对象</div></a></div><div class="relatedPosts_item"><a href="/2019/09/02/Java-File类详解及IO介绍及使用/" title="Java-File类详解及IO介绍及使用"><img class="relatedPosts_cover lazyload" data-src="https://revistadigital.inesem.es/informatica-y-tics/files/2015/10/inesem-java-1024x768.jpg"><div class="relatedPosts_title">Java-File类详解及IO介绍及使用</div></a></div><div class="relatedPosts_item"><a href="/2019/02/22/Java-集合与泛型/" title="Java-集合与泛型"><img class="relatedPosts_cover lazyload" data-src="https://revistadigital.inesem.es/informatica-y-tics/files/2015/10/inesem-java-1024x768.jpg"><div class="relatedPosts_title">Java-集合与泛型</div></a></div><div class="relatedPosts_item"><a href="/2020/01/15/Java8中的函数式编程/" title="Java8函数式编程"><img class="relatedPosts_cover lazyload" data-src="https://upload-images.jianshu.io/upload_images/16323523-273fc82a9a74ced8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><div class="relatedPosts_title">Java8函数式编程</div></a></div><div class="relatedPosts_item"><a href="/2018/12/26/Java中的IO和流/" title="Java中的IO和流"><img class="relatedPosts_cover lazyload" data-src="https://revistadigital.inesem.es/informatica-y-tics/files/2015/10/inesem-java-1024x768.jpg"><div class="relatedPosts_title">Java中的IO和流</div></a></div></div><div class="clear_both"></div></div></div></div><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2020 By DeeJay</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script></body></html>