<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>react | DeeJay's Blog</title><meta name="description" content="react"><meta name="keywords" content="前端,JS,React"><meta name="author" content="DeeJay"><meta name="copyright" content="DeeJay"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="react"><meta name="twitter:description" content="react"><meta name="twitter:image" content="https://avatars1.githubusercontent.com/u/20784273?s=400&amp;u=ba38b4835b7e3c4960763bc6dce9abb320c43f05&amp;v=4"><meta property="og:type" content="article"><meta property="og:title" content="react"><meta property="og:url" content="https://deejay0921.github.io/2018/02/16/react/"><meta property="og:site_name" content="DeeJay's Blog"><meta property="og:description" content="react"><meta property="og:image" content="https://avatars1.githubusercontent.com/u/20784273?s=400&amp;u=ba38b4835b7e3c4960763bc6dce9abb320c43f05&amp;v=4"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://deejay0921.github.io/2018/02/16/react/"><link rel="prev" title="一些知识点的总结" href="https://deejay0921.github.io/2018/03/14/一些知识点的总结/"><link rel="next" title="从Python中的self说起（理解this与箭头函数）" href="https://deejay0921.github.io/2018/02/13/从Python中的self说起（理解this与箭头函数）/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'false',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'false',
  Snackbar: undefined
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">DeeJay's Blog</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="https://avatars1.githubusercontent.com/u/20784273?s=400&amp;u=ba38b4835b7e3c4960763bc6dce9abb320c43f05&amp;v=4" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">149</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">97</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">7</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#理解JSX语法"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">理解JSX语法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#一般在下列钩子中应用setState"><span class="toc_mobile_items-number">1.0.1.</span> <span class="toc_mobile_items-text">一般在下列钩子中应用setState():</span></a></li></ol></li></ol><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#事件绑定"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">事件绑定</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#摆脱React中操蛋的bind-this-的方法"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">摆脱React中操蛋的bind(this)的方法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#React中的ref"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">React中的ref</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#React中突变数据的处理"><span class="toc_mobile_items-number"></span> <span class="toc_mobile_items-text">React中突变数据的处理</span></a></li></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#理解JSX语法"><span class="toc-number">1.</span> <span class="toc-text">理解JSX语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一般在下列钩子中应用setState"><span class="toc-number">1.0.1.</span> <span class="toc-text">一般在下列钩子中应用setState():</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#事件绑定"><span class="toc-number">2.</span> <span class="toc-text">事件绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#摆脱React中操蛋的bind-this-的方法"><span class="toc-number">3.</span> <span class="toc-text">摆脱React中操蛋的bind(this)的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#React中的ref"><span class="toc-number">3.1.</span> <span class="toc-text">React中的ref</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React中突变数据的处理"><span class="toc-number"></span> <span class="toc-text">React中突变数据的处理</span></a></li></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/top_img_index.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">react</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2018-02-16<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-09-15</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/前端/">前端</a></span><div class="post-meta-wordcount"><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>初步理解react</p>
<a id="more"></a>

<p>webpack –help -p :<br><code>shortcut for --optimize-minimize --define
               process.env.NODE_ENV=&quot;production&quot;</code></p>
<h2 id="理解JSX语法"><a href="#理解JSX语法" class="headerlink" title="理解JSX语法"></a><a href="https://babeljs.io/repl/" target="_blank" rel="noopener">理解JSX语法</a></h2><p>JSX语法注意点：</p>
<ul>
<li>是 XML 不是 HTML，所以所有的标签都要闭合，如 <img> 或 <div>。</div></li>
<li>每段 JSX 里的 XML 只能有一个根元素，不然就报错。</li>
<li>XML 里面可以用 <code>{}</code> 混入 任何 JS 代码</li>
</ul>
<p>JSX语法的理解：分为tagname,attributes,children三项来理解</p>
<p>例如： <code>const jsx = &lt;div&gt;Hello Jsx&lt;/div&gt;</code><br>经过babel之后为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var jsx = React.createElement(</span><br><span class="line">  &quot;div&quot;,</span><br><span class="line">  null,</span><br><span class="line">  &quot;Hello Jsx&quot;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这样可以理解为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  tagname: &quot;div&quot;,</span><br><span class="line">  attributes: null,</span><br><span class="line">  children: &quot;Hello Jsx&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件的tagname就不是标准的html标签了，如果有props，那么attributes也不是null了，对于children来说，如果内部还有嵌套标签，那么依次做一个递归。</p>
<p>##组件<br>react声明组件时，<strong>第一个字母必须大写</strong>。</p>
<p>两种写法：</p>
<ol>
<li>class component<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Welcome extends React.Component &#123;</span><br><span class="line">    render () &#123;</span><br><span class="line">        return &lt;h1&gt;hello,&#123;this.props.name&#125;&lt;/h1&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>或者：<br>2.functional component</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Welcome(props) &#123;</span><br><span class="line">    return &lt;h1&gt;hello,&#123;props.name&#125;&lt;/h1&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>##组件中的数据源</p>
<ol>
<li><p>props (props是父组件到子组件的，props should be pure,即不予许直接修改props）</p>
</li>
<li><p>state （state是自身维护的数据状态，但也只可以通过setState修改）</p>
</li>
</ol>
<p>组件中不可以改变props的值，state是组件中可以改变的东西</p>
<p>但是要使用this.setState()方法才能改变state的值</p>
<p>关于setState() , <a href="https://zhuanlan.zhihu.com/p/25954470" target="_blank" rel="noopener">参考</a></p>
<p>要理解2点：</p>
<ul>
<li><strong>setState不会立刻改变React组件中state的值</strong></li>
<li>函数式的setState用法(即setState()方法可以接受一个函数作为参数)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">class Welcome extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            date: new Date()</span><br><span class="line">        &#125;</span><br><span class="line">        setInterval(() =&gt; &#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                date: new Date()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render () &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;hello, &#123;this.props.name&#125;&lt;/h1&gt;</span><br><span class="line">                &lt;h2&gt;&#123;this.state.date.toString()&#125;&lt;/h2&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Welcome;</span><br></pre></td></tr></table></figure>

<p>##生命周期</p>
<p><a href="https://facebook.github.io/react/docs/react-component.html#the-component-lifecycle" target="_blank" rel="noopener">声明周期英文文档</a></p>
<p>React 的生命周期包括三个阶段：mount（挂载）、update（更新）和 unmount（移除）</p>
<p>####mount<br>mount 就是第一次让组件出现在页面中的过程。这个过程的关键就是 render 方法。React 会将 render 的返回值（一般是虚拟 DOM，也可以是 DOM 或者 null）插入到页面中。</p>
<p>这个过程会暴露几个钩子（hook）方便你往里面加代码：</p>
<ul>
<li>constructor()   初始化props 和 state</li>
<li>componentWillMount() 准备插入render中return的内容</li>
<li>render()  开始插入</li>
<li>componentDidMount()  插入之后想进行的操作</li>
</ul>
<p>####update</p>
<p>mount 之后，如果数据有任何变动，就会来到 update 过程，这个过程有 5 个钩子：</p>
<ul>
<li>1.componentWillReceiveProps(nextProps) - 我要读取 props 啦！</li>
<li><ol start="2">
<li>shouldComponentUpdate(nextProps, nextState) - 请问要不要更新组件？true / false</li>
</ol>
</li>
<li><ol start="3">
<li>componentWillUpdate() - 我要更新组件啦！</li>
</ol>
</li>
<li><ol start="4">
<li>render() - 更新！</li>
</ol>
</li>
<li><ol start="5">
<li>componentDidUpdate() - 更新完毕啦！</li>
</ol>
</li>
</ul>
<p>####unmount<br>当一个组件将要从页面中移除时，会进入 unmount 过程，这个过程就一个钩子：</p>
<ul>
<li>componentWillUnmount() - 我要死啦！</li>
</ul>
<p>你可以在这个组件死之前做一些清理工作。</p>
<h4 id="一般在下列钩子中应用setState"><a href="#一般在下列钩子中应用setState" class="headerlink" title="一般在下列钩子中应用setState():"></a>一般在下列钩子中应用setState():</h4><ul>
<li>componentWillMount</li>
<li>componentDidMount</li>
<li>componentWillReceiveProps</li>
</ul>
<h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><ul>
<li>首先明确一个概念，就是在<code>&lt;div onClick=fn&gt;&lt;/div&gt;</code>这个DOM绑定中，<code>onClick</code>后面的<code>fn</code><strong>是一个函数，而不是一个函数执行的结果</strong>，所以<strong>不能写成</strong><code>&lt;div onClick=fn()&gt;&lt;/div&gt;</code>。（重点！）</li>
</ul>
<p>明确了函数绑定时，写的<strong>是一个函数而不是函数运行的结果</strong>之后，继续明确第二个概念：</p>
<ul>
<li>bind（），对于一个函数<code>fn</code>来说,<code>fn.bind(window)</code>同样是一个函数，只不过运行的Context指定为了window。<code>fn.bind(window)</code>本身<strong>并没有执行</strong>（所以仍然是一个函数而不是函数运行的结果！）</li>
</ul>
<p>明确了上述2点之后，再来看react中的事件绑定。</p>
<p>先来看一个App组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;</span><br><span class="line">import ReactDom from &apos;react-dom&apos;</span><br><span class="line">import &apos;./index.css&apos;</span><br><span class="line"></span><br><span class="line">const rootDom = document.querySelector(&apos;#root&apos;)</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      isOn: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      //这里点击的时候的this已经不是当前组件了，所以要bind为当前组件，不然是没有testClick函数的</span><br><span class="line">      &lt;div onClick=&#123;this.testClick.bind(this)&#125;&gt; </span><br><span class="line">        &lt;button&gt;&#123;this.state.isOn ? &apos;ON&apos; : &apos;OFF&apos; &#125;&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  testClick () &#123;</span><br><span class="line">    this.setState( (prevState) =&gt; &#123; //setState()也能传函数作为参数，没什么好说的</span><br><span class="line">      return &#123;</span><br><span class="line">        isOn: !prevState.isOn</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDom.render(&lt;App&gt;&lt;/App&gt;,rootDom)</span><br></pre></td></tr></table></figure>

<p>这么一看就能理解react中的事件绑定了。</p>
<ul>
<li>还有一个小问题，对于标签默认行为的阻止，不像Vue一样有<code>.prevent</code>这种修饰符，还是要自己写的。<br>来看个例子： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;</span><br><span class="line">import ReactDom from &apos;react-dom&apos;</span><br><span class="line">import &apos;./index.css&apos;</span><br><span class="line"></span><br><span class="line">const rootDom = document.querySelector(&apos;#root&apos;)</span><br><span class="line"></span><br><span class="line">let App = () =&gt; &#123;</span><br><span class="line">  function preventClick (e) &#123; // 注意这里的e，是react自己传过来的  本身没做任何操作</span><br><span class="line">    e.preventDefault() //</span><br><span class="line">    console.log(&apos;default click has been prevent&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;/*上面已经说过，绑定事件只能写函数，不能写函数的运行结果，所以如果写了preventClick()就会报错*/&#125;</span><br><span class="line">      &lt;a href=&quot;http://www.baidu.com&quot; onClick=&#123;preventClick&#125;&gt;click me&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">ReactDom.render(&lt;App&gt;&lt;/App&gt;,rootDom)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>对于上述问题  又引申出了一个小问题，如果我想在阻止a标签的同时，事件处理函数还想接收一些其他的参数进行处理怎么写呢。</p>
<p>对于React，上面例子的<code>e.preventDefault()</code>中的e是React自己传过来的。我们如果既想写e，还想有自己规定的一些参数的话，要这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let App = () =&gt; &#123;</span><br><span class="line">  function preventClick (str,e) &#123; // 如果有其他自定义的参数，那么e永远是最后一项，而且同样也是React自己传过来的。</span><br><span class="line">    e.preventDefault() //</span><br><span class="line">    console.log(str)</span><br><span class="line">  &#125;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;/*上面已经说过，绑定事件只能写函数，不能写函数的运行结果，所以如果写了preventClick()就会报错*/&#125;</span><br><span class="line">      &lt;a href=&quot;http://www.baidu.com&quot; onClick=&#123;preventClick.bind(this,&apos;testString&apos;)&#125;&gt;click me&lt;/a&gt;</span><br><span class="line">      &#123;/*这里的preventClick.bind(this,&apos;testString&apos;)同样也是一个函数，并不是函数运行结果*/&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中，我们想在preventClick()中传一些自己用的参数，那么<strong>在点击的时候，就要bind到组件本身上，然后再传入想要的参数</strong>，注意e是不用我们自己写到参数中去的，回到函数本身的参数上，自定义的参数在前，<strong>e永远是最后一项。</strong></p>
<h2 id="摆脱React中操蛋的bind-this-的方法"><a href="#摆脱React中操蛋的bind-this-的方法" class="headerlink" title="摆脱React中操蛋的bind(this)的方法"></a>摆脱React中操蛋的bind(this)的方法</h2><p>上面的事件绑定中已经提到了bind，因为<strong>事件触发时的this已经不是当前组件本身了，所以我们要将处理函数的this重新设置为当前组件</strong>，所以有了随便一个函数后面都要<code>bind(this)</code>的情况。</p>
<p>先来看个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">  &#125;</span><br><span class="line">  render ()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.testClick.bind(this)&#125;&gt;click me&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  testClick() &#123; // 普通函数在被调用的时候，就有了this，所以要加bind()到App组件上</span><br><span class="line">    console.log(this) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述例子中，<code>testClick</code>是App组件上的函数，点击时的this已经不是App组件了，所以不能正确调用。要将其写为<code>this.testClick.bind(this)</code>而不是<code>this.testClick</code>。</p>
<p>为了摆脱上述这种烦人的写法，我们可以有如下几种方法：</p>
<ol>
<li>在<code>constructor</code>中将当前函数重新赋值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">    this.testClick = this.testClick.bind(this) //这的this是App组件，直接将testClick重新赋值一下</span><br><span class="line">  &#125;</span><br><span class="line">  render ()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.testClick&#125;&gt;click me&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  testClick() &#123; // 普通函数在被调用的时候，就有了this，所以要加bind()到App组件上</span><br><span class="line">    console.log(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>我们在constructor中给testClick重新赋了一次值，testClick变为了一个运行上下文为App组件的函数，下面直接<code>onClick={this.testClick}</code>即可。</p>
<ol start="2">
<li>public class fields syntax（不知道怎么翻译，就是利用箭头函数没有this的特性）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">  &#125;</span><br><span class="line">  render ()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.testClick&#125;&gt;click me&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  testClick = () =&gt; &#123; //箭头函数没有本身的this 所以定义的时候this已经确定为App组件了，所以不用bind</span><br><span class="line">    console.log(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>我们利用箭头函数本身没有this的特性，在App中定义testClick的时候，testClick的this就已经确定为当前上下文App组件了。所以后面直接调用<code>onClick={this.testClick}</code>即可。</p>
<ol start="3">
<li>在回调中使用箭头函数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">  &#125;</span><br><span class="line">  render ()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;(e) =&gt; &#123;return this.testClick(e)&#125;&#125;&gt;click me&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  testClick() &#123; </span><br><span class="line">    console.log(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次渲染组件时，都会生成一个全新的回调。但在有时候将其作为prop传给子组件时，会引发一次额外的渲染。所以，<strong>建议用constructor 和public class fields syntax</strong>两种方式避免<code>bind(this)</code>这种写法。</p>
<p>##值得一提的是：</p>
<p>上面说的想给事件处理函数传递另外自定义的参数时，<strong>绑定事件的时候是不用写e的，因为react是自动帮你把e作为最后一个参数传递的</strong>。</p>
<p> <code>&lt;button onClick={this.testClick.bind(this, id)}&gt;click me&lt;/button&gt;</code></p>
<p>就像上述例子一样，我们想传一个额外的参数id，在id后面是不需要写e的，<code>this.testClick.bind(this, id,e)</code>这种是不用写的。</p>
<p><strong>但是！</strong>  在我们提到的第3种方法，回调中使用函数的情况下，<strong>是需要开发者自己写上e的！</strong></p>
<p><code>&lt;button onClick={(e) =&gt; this.testClick(id, e)}&gt;click me&lt;/button&gt;</code></p>
<p>就像这样，自定义参数id的后面还要写上e。</p>
<p>详情参考文档：With an arrow function, we have to pass it explicitly, but with bind any further arguments are automatically forwarded.</p>
<p><a href="https://reactjs.org/docs/handling-events.html" target="_blank" rel="noopener">文档地址</a></p>
<h3 id="React中的ref"><a href="#React中的ref" class="headerlink" title="React中的ref"></a>React中的ref</h3><p>想直接修改原生DOM或者是组件的时候，可以使用ref。</p>
<ol>
<li>原生DOM上</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class App extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;/*ref callback*/&#125;</span><br><span class="line">        &lt;input type=&quot;text&quot; ref=&#123;(input) =&gt; this.testRef = input&#125; /&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; onClick=&#123;this.focus.bind(this)&#125; value=&quot;Click&quot; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  focus() &#123;</span><br><span class="line">    this.testRef.focus();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述例子就是一个原生DOM上使用ref的例子，react在原生的input加载完成后，通过一个回调函数，<code>(input) =&gt; this.testRef = input</code>,这里的<strong>回调参数input就是底层的DOM，接受DOM作为参数，存到testRef中。引用的时候，直接就引用到了原生的DOM</strong>。</p>
<ol start="2">
<li>ref ====&gt; class Component <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// ref ===&gt; class Component</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;TestComponent ref=&#123;(testComponent) =&gt; this.classCom = testComponent&#125;&gt;&lt;/TestComponent&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    console.log(this.classCom.state)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestComponent extends React.Component &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super()</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      name: &apos;children Component&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot;/&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>这里的ref回调函数中，<code>(testComponent) =&gt; this.classCom = testComponent</code>的参数为<strong>已经加载的 React 实例</strong>，我们可以在父组件中通过this.classCom访问到它。</p>
<ol start="3">
<li>ref ====&gt; functional Component </li>
</ol>
<p><strong>你不能在函数式组件上使用 ref 属性，因为它们没有实例</strong>,但是可以对其内部的原生DOM使用ref，参见第一条。</p>
<h1 id="React中突变数据的处理"><a href="#React中突变数据的处理" class="headerlink" title="React中突变数据的处理"></a>React中突变数据的处理</h1><p>经常会遇到设置了state之后，进行setState()了之后，页面没有进行渲染的情况。（尤其是使用PureComponent的时候）。</p>
<p>这种情况经常是由于操作习惯不好造成了<strong>原数据结构的突变</strong>。</p>
<ul>
<li>先来解释什么是原数据突变</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1]</span><br><span class="line">arr.push(2)</span><br><span class="line">console.log(arr) //[1, 2]</span><br></pre></td></tr></table></figure>

<p>我们有一个数组，进行了<strong>push操作</strong>之后，<strong>原先的数组的值改变了</strong>，由<code>[1]</code>变为了<code>[1,2]</code>。</p>
<p>看下一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr2 = [1]</span><br><span class="line">let arr3 = arr2.concat([2])</span><br><span class="line">console.log(arr2) //[1]</span><br><span class="line">console.log(arr3) //[1, 2]</span><br></pre></td></tr></table></figure>

<p>同样是一个数组，进行了<strong>concat操作</strong>之后，<strong>原先的arr2的值并没有发生改变</strong>，我们把concat之后的结果赋给了一个新变量arr3来储存。</p>
<ul>
<li>React中setState()时我们该怎么写数据</li>
</ul>
<p>上面我们提到了<strong>push操作会改变原数据，这在React中是不应该的。</strong></p>
<p>setState时，我们<strong>应该return的是一个新对象，而不是原对象</strong>。所以我们要避免那些会修改原数据的操作，例如<strong>push</strong>。</p>
<p>比如说，我们在一个组件中通过push()修改了数组，然后有一个PureComponent子组件把这个数组作为props渲染页面，这时候虽然我们在父组件中修改了数组的值，但是setState()return的时候，原数据结构已经变了，这时候虽然本身的state已经改变了，但是传到子组件的props并没有改变。</p>
<p>为了避免这种情况发生，我们<strong>一般可以采用concat</strong>等不会引起原数据突变的操作。</p>
<p>如果非要用push的话，可以通过<code>Object.assgin()</code>或者<code>...spread语法</code>来进行一份数据的拷贝，在进行操作。</p>
<p>比如说上述的arr，我们可以这么操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    this.state = &#123;</span><br><span class="line">      arr: [1]</span><br><span class="line">    &#125;;</span><br><span class="line">//进行setState()</span><br><span class="line">    this.setState( (prevState) =&gt; &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        arr: [...prevState.arr,2]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>如果目标数据是对象的话，可以通过<code>Object.assgin()</code>来进行操作</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">DeeJay</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://deejay0921.github.io/2018/02/16/react/">https://deejay0921.github.io/2018/02/16/react/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://deejay0921.github.io">DeeJay's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/前端/">前端    </a><a class="post-meta__tags" href="/tags/JS/">JS    </a><a class="post-meta__tags" href="/tags/React/">React    </a></div><div class="post_share"><div class="social-share" data-image="https://avatars1.githubusercontent.com/u/20784273?s=400&amp;u=ba38b4835b7e3c4960763bc6dce9abb320c43f05&amp;v=4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2018/03/14/一些知识点的总结/"><img class="prev_cover lazyload" data-src="undefined" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>一些知识点的总结</span></div></a></div><div class="next-post pull_right"><a href="/2018/02/13/从Python中的self说起（理解this与箭头函数）/"><img class="next_cover lazyload" data-src="undefined" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>从Python中的self说起（理解this与箭头函数）</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2017/09/02/AMD_-CMD/" title="AMD_-CMD"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">AMD_-CMD</div></a></div><div class="relatedPosts_item"><a href="/2017/08/26/经典的jQuery实现图片懒加载的一种方法/" title="经典的jQuery实现图片懒加载的一种方法"><img class="relatedPosts_cover lazyload" data-src="undefined"><div class="relatedPosts_title">经典的jQuery实现图片懒加载的一种方法</div></a></div><div class="relatedPosts_item"><a href="/2017/08/28/瀑布流布局/" title="瀑布流布局"><img class="relatedPosts_cover lazyload" data-src="undefined"><div class="relatedPosts_title">瀑布流布局</div></a></div><div class="relatedPosts_item"><a href="/2017/08/29/瀑布流_懒加载_ajax结合使用/" title="瀑布流_懒加载_ajax结合使用"><img class="relatedPosts_cover lazyload" data-src="undefined"><div class="relatedPosts_title">瀑布流_懒加载_ajax结合使用</div></a></div><div class="relatedPosts_item"><a href="/2017/08/27/左右水平轮播，渐变轮播/" title="左右水平轮播，渐变轮播"><img class="relatedPosts_cover lazyload" data-src="undefined"><div class="relatedPosts_title">左右水平轮播，渐变轮播</div></a></div><div class="relatedPosts_item"><a href="/2017/10/13/异步_-promise/" title="异步_-promise"><img class="relatedPosts_cover lazyload" data-src="undefined"><div class="relatedPosts_title">异步_-promise</div></a></div></div><div class="clear_both"></div></div></div></div><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2019 By DeeJay</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script></body></html>