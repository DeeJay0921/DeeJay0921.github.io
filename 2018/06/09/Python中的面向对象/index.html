<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content>
  <meta name="author" content="DeeJay">
  <!-- Open Graph Data -->
  <meta property="og:title" content="Python中的面向对象">
  <meta property="og:description" content="web前端 Java后端">
  <meta property="og:site_name" content="DeeJay&#39;s Blog">
  <meta property="og:type" content="article">
  <meta property="og:image" content="https://deejay0921.github.io">
  
    <link rel="alternate" href="/atom.xml" title="DeeJay&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.jpg">
  

  <!-- Site Title -->
  <title>DeeJay's Blog</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/blog-banner2.png)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">Python中的面向对象</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/DeeJay0921">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:1018805743@qq.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By DeeJay</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2018-06-09</span>
            <span class="time">01:26:21</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/Python/">Python</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/Python/">#Python</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p>Python中的面向对象</p>
<a id="more"></a>

<p>#　Python中的面向对象</p>
<h3 id="面向过程和面向对象的区别"><a href="#面向过程和面向对象的区别" class="headerlink" title="面向过程和面向对象的区别"></a>面向过程和面向对象的区别</h3><ul>
<li>面向过程：根据业务逻辑从上到下写代码</li>
<li>面向对象：将数据和函数绑定到一起，进行封装，这样能够更快速的进行开发程序，减少重复代码的书写</li>
</ul>
<h3 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h3><p>在面向对象的概念中，对象是核心，那么为了将一堆具有相同特征和行为的对象进行抽象定义，就提出了一个概念叫<strong>类</strong></p>
<p>举个例子：类就相当于小时候组装赛车的图纸，组装出来的赛车就是对象。</p>
<h3 id="类的组成"><a href="#类的组成" class="headerlink" title="类的组成"></a>类的组成</h3><p>类名，类的属性(数据)，类的方法(对数据操作的行为)</p>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def sayHi(self):</span><br><span class="line">        print(&apos;hello&apos;)</span><br><span class="line">    </span><br><span class="line">    def introduce(self):</span><br><span class="line">        print(&apos;this is %s speaking&apos;%self.name)</span><br><span class="line"></span><br><span class="line">DeeJay = Person()</span><br><span class="line"></span><br><span class="line">DeeJay.name = &apos;DeeJay&apos;</span><br><span class="line"></span><br><span class="line">DeeJay.sayHi() # hello</span><br><span class="line">DeeJay.introduce() # this is DeeJay speaking</span><br></pre></td></tr></table></figure>

<p>上面定义了一个Person类，DeeJay是这个类的一个对象。</p>
<p><code>DeeJay = Person()</code>这一句就是创建了一个Person类的对象，其中<code>Person()</code>就是在内存中创建了一个对象，同时这个语句的返回值是这个对象的<strong>引用</strong>，将其赋给了DeeJay这个变量。</p>
<p><code>DeeJay.name = &#39;DeeJay&#39;</code>这一句就是给DeeJay这个对象增添一个属性name。</p>
<p>而<code>sayHi()</code>和<code>introduce()</code>都是Person类定义时候的方法。</p>
<p>值得一提的是上面方法定义时的参数<code>self</code>,类比一下JS中构造函数内部的<code>this</code>，很好理解,当然可以不写成self,但是必须保证要有一个形参</p>
<p>另外写一个JS中构造函数创建示例的例子，来进行对比理解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayHi = function() &#123;</span><br><span class="line">    console.log(&apos;hello&apos;)</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.introduce = function() &#123;</span><br><span class="line">    console.log(`this is $&#123;this.name&#125; speaking`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let DeeJay = new Person(&apos;DeeJay&apos;)</span><br><span class="line">DeeJay.introduce()</span><br></pre></td></tr></table></figure>

<h3 id="init-self-方法"><a href="#init-self-方法" class="headerlink" title="__init__(self)方法"></a><code>__init__(self)</code>方法</h3><p>#####　简介</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    </span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def introduce(self):</span><br><span class="line">        print(&apos;this is %s speaking&apos;%self.name)</span><br><span class="line"></span><br><span class="line">DeeJay = Person()</span><br></pre></td></tr></table></figure>

<p>介绍<code>__init__()</code>就得了解对象创建的流程，在上述例子<code>DeeJay = Person()</code>这一句创建对象的语句中，有如下流程：</p>
<ol>
<li>在内存中创建了一个对象</li>
<li>Python自动调用<code>__init__(self)</code>方法,此时传入的这个self就是创建的那个对象的<strong>引用</strong></li>
<li>执行<code>__init__()</code>方法中的一些默认属性的设定</li>
<li>返回创建好的对象的<strong>引用</strong>,(前4步就是 <code>Person()</code>这个语句做的事)</li>
<li>将引用赋值给DeeJay</li>
</ol>
<h5 id="init-方法的具体使用举例："><a href="#init-方法的具体使用举例：" class="headerlink" title="__init__()方法的具体使用举例："></a><code>__init__()</code>方法的具体使用举例：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    </span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    def introduce(self):</span><br><span class="line">        print(&apos;this is %s speaking&apos;%self.name)</span><br><span class="line"></span><br><span class="line">DeeJay = Person(&apos;DeeJay&apos;,21)</span><br><span class="line"></span><br><span class="line">DeeJay.introduce() # this is DeeJay speaking</span><br></pre></td></tr></table></figure>

<p>上述例子中，<code>Person(&#39;DeeJay&#39;,21)</code>这个语句，在执行到调用<strong>init</strong>()的时候，self指向的是创建的这个对象，<strong>init</strong>()方法还可以接受除了self以外的参数，这些参数可以给创建的这个对象进行属性的初始化。</p>
<p>这么一写，就不需要创建好对象之后再进行属性的添加了。</p>
<h3 id="str-方法"><a href="#str-方法" class="headerlink" title="__str__()方法"></a><code>__str__()</code>方法</h3><p>上面的例子中，如果创建了DeeJay对象之后，使用<code>print(DeeJay)</code>来输出这个对象，得到的是：<code>&lt;__main__.Person object at 0x7f39a0ca5a58&gt;</code></p>
<p>但是如果我们定义了<code>__str__()</code>方法之后，再进行print对象的时候，就会调用这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    </span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &quot;该对象的name为：%s,age为：%d&quot;%(self.name,self.age)</span><br><span class="line"></span><br><span class="line">    def introduce(self):</span><br><span class="line">        print(&apos;this is %s speaking&apos;%self.name)</span><br><span class="line"></span><br><span class="line">DeeJay = Person(&apos;DeeJay&apos;,21)</span><br><span class="line"></span><br><span class="line">Yang = Person(&apos;Yang&apos;,22)</span><br><span class="line"></span><br><span class="line"># print(DeeJay) # &lt;__main__.Person object at 0x7f39a0ca5a58&gt;</span><br><span class="line">print(DeeJay) # 该对象的name为：DeeJay,age为：21</span><br><span class="line">print(Yang) # 该对象的name为：Yang,age为：22</span><br></pre></td></tr></table></figure>

<p>值得注意的是，<code>__str__()</code>中是输出return的值。</p>
<h3 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h3><p>如果有一个对象，需要对其属性进行修改时，一般有2种方法：</p>
<ul>
<li>对象.属性 = 数据 # 直接修改</li>
<li>对象.方法()  # 间接修改</li>
</ul>
<p>一般为了保护对象的属性，即不能随意修改，不建议直接给对象属性直接赋值，一般我们可以采用定义一个方法，来进行给对象添加属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Dog():</span><br><span class="line">    def get_age(self):</span><br><span class="line">        return self.age</span><br><span class="line"></span><br><span class="line">wangwang = Dog()</span><br><span class="line">wangwang.age = 10 # 一般不这么写  而是通过定义一个方法来进行添加属性</span><br><span class="line"></span><br><span class="line">print(wangwang.get_age())</span><br></pre></td></tr></table></figure>

<p>所以可以写成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Dog():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__age = 0 # 定义了一个私有属性 __age</span><br><span class="line"></span><br><span class="line">    def set_age(self,new_age):</span><br><span class="line">        if(new_age &gt; 0):</span><br><span class="line">            self.__age = new_age</span><br><span class="line">        else:</span><br><span class="line">            self.__age = 0 # 可以在添加属性的时候，同时处理一些异常值的情况</span><br><span class="line"></span><br><span class="line">    def get_age(self):</span><br><span class="line">        return self.__age</span><br><span class="line"></span><br><span class="line">wangwang = Dog()</span><br><span class="line">wangwang.set_age(10)</span><br><span class="line"></span><br><span class="line">print(wangwang.get_age()) # 10</span><br><span class="line"></span><br><span class="line">wangwang.set_age(-10)</span><br><span class="line">print(wangwang.get_age()) # 0</span><br></pre></td></tr></table></figure>

<p>这样就通过方法来设置这个私有属性。注意私有属性前要加<code>__</code>,比如说上述例子中的<code>__age</code>,这样通过<code>wangwang.__age</code>就访问不到这个</p>
<h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><p>先来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Dog:</span><br><span class="line">    def print1(self):</span><br><span class="line">        print(&apos;---1----&apos;)</span><br><span class="line"></span><br><span class="line">    def print2(self):</span><br><span class="line">        print(&apos;----2---&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dog = Dog()</span><br><span class="line"></span><br><span class="line">dog.print1() # ---1----</span><br><span class="line">dog.print2() # ----2---</span><br></pre></td></tr></table></figure>

<p>Dog这个类创建出来的dog对象，可以使用定义的<code>print1()</code>和<code>print2()</code>这两个方法。</p>
<p>现在稍作修改,将<code>print1()</code>改为<code>__print1()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Dog:</span><br><span class="line">    def __print1(self):</span><br><span class="line">        print(&apos;---1----&apos;)</span><br><span class="line"></span><br><span class="line">    def print2(self):</span><br><span class="line">        print(&apos;----2---&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dog = Dog()</span><br><span class="line"></span><br><span class="line">dog.print2() # ----2---</span><br><span class="line">dog.__print1() # 报错了 AttributeError: &apos;Dog&apos; object has no attribute &apos;__print1&apos;</span><br></pre></td></tr></table></figure>

<p>那么<code>__print1()</code>就是一个私有方法，不允许直接让对象调用，只能在其他方法内部进行调用。</p>
<p>举个实际的例子来说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Msg():</span><br><span class="line">    def __init__(self,money):</span><br><span class="line">        self.money = money</span><br><span class="line"></span><br><span class="line">    def __sendMsg(self):</span><br><span class="line">        print(&quot;发送短信&quot;)</span><br><span class="line">        self.money -= 10</span><br><span class="line"></span><br><span class="line">    def checkMoneyAndSendMsg(self):</span><br><span class="line">        if(self.money &gt; 10):</span><br><span class="line">            self.__sendMsg() # 调用私有方法 </span><br><span class="line">        else:</span><br><span class="line">            print(&apos;余额不够&apos;)</span><br><span class="line"></span><br><span class="line">message1 = Msg(100)</span><br><span class="line">message1.checkMoneyAndSendMsg() # 发送短信</span><br><span class="line"></span><br><span class="line">message2 = Msg(0)</span><br><span class="line">message2.checkMoneyAndSendMsg() # 余额不够</span><br></pre></td></tr></table></figure>

<p>这个Msg类定义了一个私有方法<code>__sendMsg()</code>用来发送短信，但是得先判断money属性是否足够，所有不允许直接使用对象调用，而是给个公有方法，判断之后在该方法里进行<code>self.__sendMsg()</code>来进行调用</p>
<p>###　<code>__del__()</code></p>
<p>创建对象后,Python默认调用<code>__init__()</code></p>
<p>删除对象时，则会调用<code>__del__()</code></p>
<p>注意这个删除对象，值得是当前指向这个对象的所有引用都消失的时候，程序会自动调用<code>__del__()</code></p>
<p>来看例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Test():</span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&apos;I\&apos;m dead!&apos;)</span><br><span class="line"></span><br><span class="line">t1 = Test()</span><br><span class="line">del t1 # I&apos;m dead!</span><br></pre></td></tr></table></figure>

<p>注意<code>del t1</code>仅仅是将t1对创建的那个对象的引用删除了，如果t1指向的对象同时还在其他地方被引用，那这个对象就没被删除,<code>__del__()</code>不会触发。</p>
<p>可以使用<code>sys</code>模块的<code>sys.getrefcount()</code>方法来判断当前目标有几个引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class T:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">t1 = T()</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">print(sys.getrefcount(t1)) # 2</span><br><span class="line"></span><br><span class="line"># 注意这边输出的是2  因为调用sys.getrefcount(t1) 的时候 将t1也传入了一次</span><br><span class="line"># 所以输出的引用数为 2 </span><br><span class="line"></span><br><span class="line">t2 = t1 # 现在将t1的引用复制一份给t2</span><br><span class="line"></span><br><span class="line">print(sys.getrefcount(t1)) # 3</span><br><span class="line"></span><br><span class="line">del t2</span><br><span class="line"></span><br><span class="line">print(sys.getrefcount(t1)) # 2</span><br><span class="line"></span><br><span class="line">del t1</span><br><span class="line"></span><br><span class="line">print(sys.getrefcount(t1)) # 报错了  NameError: name &apos;t1&apos; is not defined</span><br><span class="line"></span><br><span class="line"># 所以这个方法返回值最小就为2</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>先来看一下最简单的一个继承：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Animal():</span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&apos;eating...&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Dog(Animal): # Dog类继承Animal类</span><br><span class="line">    def bark(self):</span><br><span class="line">        print(&apos;wang wang&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wangcai = Dog()</span><br><span class="line">wangcai.eat() # eating...</span><br></pre></td></tr></table></figure>

<p><code>class Dog(Animal):</code> 就实现了继承</p>
<p>子类可以继承父类(以及父类的父类等)的属性和方法</p>
<h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>子类可以在内部重新定义继承来的方法 称为重写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Dog:</span><br><span class="line">    def bark(self):</span><br><span class="line">        print(&apos;汪汪汪&apos;)</span><br><span class="line"></span><br><span class="line">class Husky(Dog):</span><br><span class="line">    def bark(self):</span><br><span class="line">        print(&apos;哈士奇在汪汪汪&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">h = Husky()</span><br><span class="line">h.bark() # 哈士奇在汪汪汪</span><br></pre></td></tr></table></figure>

<p>这样就实现了重写，但是会有这样一个需求，子类在重写的方法中还想调用父类中被重写的方法，这时候有2种方法：</p>
<p>第一种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Dog:</span><br><span class="line">    def bark(self):</span><br><span class="line">        print(&apos;汪汪汪&apos;)</span><br><span class="line"></span><br><span class="line">class Husky(Dog):</span><br><span class="line">    def bark(self):</span><br><span class="line">        print(&apos;哈士奇在汪汪汪&apos;)</span><br><span class="line">        # 第一种方式</span><br><span class="line">        Dog.bark(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">h = Husky()</span><br><span class="line"># 想在h.bark()中调用Dog类中被重写的bark()</span><br><span class="line">h.bark() # 哈士奇在汪汪汪 汪汪汪</span><br></pre></td></tr></table></figure>

<p>通过在子类的<code>bark()</code>中写上<code>Dog.bark(self)</code>即可调用，注意self不可省略</p>
<p>第二种，使用<code>super()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Dog:</span><br><span class="line">    def bark(self):</span><br><span class="line">        print(&apos;汪汪汪&apos;)</span><br><span class="line"></span><br><span class="line">class Husky(Dog):</span><br><span class="line">    def bark(self):</span><br><span class="line">        print(&apos;哈士奇在汪汪汪&apos;)</span><br><span class="line">        # 第二种方式</span><br><span class="line">        super().bark()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">h = Husky()</span><br><span class="line"># 想在h.bark()中调用Dog类中被重写的bark()</span><br><span class="line">h.bark() # 哈士奇在汪汪汪 汪汪汪</span><br></pre></td></tr></table></figure>

<p>直接写<code>super().bark()</code>即可</p>
<h3 id="私有属性和私有变量的继承机制"><a href="#私有属性和私有变量的继承机制" class="headerlink" title="私有属性和私有变量的继承机制"></a>私有属性和私有变量的继承机制</h3><p>来介绍一下私有属性和方法的继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__privateProperty = &apos;private&apos;</span><br><span class="line">        self.publicProperty = &apos;public&apos;</span><br><span class="line"></span><br><span class="line">    def __privateFn(self):</span><br><span class="line">        print(&apos;privateFn&apos;)</span><br><span class="line">    </span><br><span class="line">    def publicFn(self):</span><br><span class="line">        print(&apos;publicFn&apos;)</span><br><span class="line"></span><br><span class="line">class B(A):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">b = B()</span><br><span class="line"></span><br><span class="line">b.publicFn() # publicFn</span><br><span class="line">print(b.publicProperty) # public</span><br><span class="line"></span><br><span class="line">b.__privateFn() # 报错 AttributeError: &apos;B&apos; object has no attribute &apos;__privateFn&apos;</span><br><span class="line">print(b.__privateProperty) # 报错 AttributeError: &apos;B&apos; object has no attribute &apos;__privateProperty&apos;</span><br></pre></td></tr></table></figure>

<p>通过例子我们可以看出，<strong>私有属性和私有方法，是不可以直接被继承的</strong></p>
<p>但是也有例外，我们如果定义一个共有方法，在其中使用私有方法和属性的话，这个是允许的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__privateProperty = &apos;private&apos;</span><br><span class="line">        self.publicProperty = &apos;public&apos;</span><br><span class="line"></span><br><span class="line">    def __privateFn(self):</span><br><span class="line">        print(&apos;privateFn&apos;)</span><br><span class="line">    </span><br><span class="line">    def publicFn(self):</span><br><span class="line">        print(&apos;publicFn&apos;)</span><br><span class="line"></span><br><span class="line">    def anotherPublicFn(self): #定义一个共有方法来使用私有变量</span><br><span class="line">        print(self.__privateProperty)</span><br><span class="line">        self.__privateFn()</span><br><span class="line"></span><br><span class="line">class B(A):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">b = B()</span><br><span class="line">b.anotherPublicFn() # private privateFn</span><br></pre></td></tr></table></figure>

<p>如上述例子所示。</p>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>多继承指的是一个类同时继承多个类，举个例子，骡子继承驴和马</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Horse:</span><br><span class="line">    def horseSay(self):</span><br><span class="line">        print(&apos;我是马&apos;)</span><br><span class="line"></span><br><span class="line">class Donkey:</span><br><span class="line">    def DonkeySay(self):</span><br><span class="line">        print(&apos;我是驴&apos;)</span><br><span class="line"></span><br><span class="line">class Mule(Horse,Donkey): # 实现了多继承</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">mule = Mule()</span><br><span class="line">mule.horseSay() # 我是马</span><br><span class="line">mule.DonkeySay() # 我是驴</span><br></pre></td></tr></table></figure>

<p>上述例子，Mule类就实现了对Horse类和Donkey类的多继承。</p>
<h3 id="多继承中的注意点-mro"><a href="#多继承中的注意点-mro" class="headerlink" title="多继承中的注意点  __mro__"></a>多继承中的注意点  <code>__mro__</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Base(object):</span><br><span class="line">    def test(self):</span><br><span class="line">        print(&apos;Base&apos;)</span><br><span class="line"></span><br><span class="line">class A(Base):</span><br><span class="line">    def test(self):</span><br><span class="line">        print(&apos;A&apos;)</span><br><span class="line"></span><br><span class="line">class B(Base):</span><br><span class="line">    def test(self):</span><br><span class="line">        print(&apos;B&apos;)</span><br><span class="line"></span><br><span class="line">class C(A,B):</span><br><span class="line">    def test(self):</span><br><span class="line">        print(&apos;C&apos;)</span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line">c.test()</span><br></pre></td></tr></table></figure>

<p>现在有如上例子，C类是对A和B多继承，A和B都继承自Base类，其中他们都有一个test方法，现在如果调用c.test()，到底输出什么？</p>
<p>我们可以输出<code>C.__mro__</code>,结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&lt;class &apos;__main__.C&apos;&gt;, &lt;class &apos;__main__.A&apos;&gt;, &lt;class &apos;__main__.B&apos;&gt;, &lt;class &apos;__main__.Base&apos;&gt;, &lt;class &apos;object&apos;&gt;)</span><br></pre></td></tr></table></figure>

<p>输出了一个元祖，同时表明了去寻找方法的路径，即由C-&gt;A-&gt;B-&gt;Base-&gt;object依次查找，如果找不到就报错说没有该方法。</p>
<p>所以我们知道上面例子会输出啥，先查找到C中的test,如果C中没定义test(),就去A里面找,以此类推。</p>
<p><code>__mro__</code>就是调用一个方法的搜索顺序</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态：定义时的类型和运行时的类型不一样，此时就成为多态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Dog(object):</span><br><span class="line">    def print_self(self):</span><br><span class="line">        print(&apos;汪汪汪&apos;)</span><br><span class="line"></span><br><span class="line">class Husky(Dog):</span><br><span class="line">    def print_self(self):</span><br><span class="line">        print(&apos;我是哈士奇&apos;)</span><br><span class="line"></span><br><span class="line">def introduce(obj): #定义一个函数</span><br><span class="line">    obj.print_self() # 调用传入的obj的print_self()</span><br><span class="line"></span><br><span class="line">dog = Dog()</span><br><span class="line">husky = Husky()</span><br><span class="line"></span><br><span class="line">introduce(dog) # 汪汪汪</span><br><span class="line">introduce(husky) # 我是哈士奇</span><br></pre></td></tr></table></figure>

<p>上述例子就是一个多态，<code>introduce()</code>方法定义时只知道要调用一个对象的方法，但是至于这个方法是调用父类还是子类，要等到开始运行的时候才能确定。</p>
<h3 id="类属性-实例属性"><a href="#类属性-实例属性" class="headerlink" title="类属性  实例属性"></a>类属性  实例属性</h3><p>先来搞清楚什么叫<code>类对象</code>，什么叫<code>实例对象</code><br>我们在Python中定义了一个类之后，这个类也是一个对象，被称为类对象，<br>而通过类创建的对象，为了和类对象区分，称为示例对象。</p>
<p>类属性就是<code>类对象</code>所拥有的属性，它被<code>类对象</code>的<code>实例对象</code>所共有，在内存中只存在<strong>一个副本</strong>。</p>
<p>下面的例子就是 <code>类属性</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class People(object):</span><br><span class="line">    name = &apos;DeeJay&apos; # 共有的 类属性</span><br><span class="line">    __age = 21 # 私有的 类属性</span><br><span class="line"></span><br><span class="line">p = People()</span><br><span class="line"></span><br><span class="line">print(p.name) # DeeJay</span><br><span class="line">print(People.name) # DeeJay</span><br><span class="line"></span><br><span class="line">print(p.__age) # AttributeError: &apos;People&apos; object has no attribute &apos;__age&apos;</span><br><span class="line">print(People.__age) # AttributeError: &apos;People&apos; object has no attribute &apos;__age&apos;</span><br></pre></td></tr></table></figure>

<p>上述例子中，在定义类的时候，直接给类定义了属性，那么这些属性就是<code>类属性</code></p>
<p>那<code>实例对象</code>中的属性就叫<code>实例属性</code>,来看例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">p = Person(&apos;DeeJay&apos;)</span><br><span class="line">print(p.name) # DeeJay</span><br></pre></td></tr></table></figure>

<p>上述例子中，并没有在Person类中直接定义属性，而是在创建实例对象的时候，给实例对象内部创建了属性，所以被称为实例属性。</p>
<ul>
<li><code>实例对象</code>和<code>类对象</code>的区别</li>
</ul>
<p>那么对于<code>实例属性</code>来讲，它只和具体的实例有关系，并且一个实例对象和另一个实例对象之间是<strong>不共享</strong>的;</p>
<p>相应的对于<code>类属性</code>来说，<code>类属性</code>所属于类对象，并且多个实例对象之间，共享同一个<code>类属性</code>，另外前面已经提到过，<code>类属性</code>只会定义一次。</p>
<p>对于<code>类属性</code>来讲，一个类创建的所有对象中，都<strong>共享</strong>这个类中的<code>类属性</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    name = &apos;DeeJay&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = Person()</span><br><span class="line">p2 = Person()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(p1.name) # DeeJay</span><br><span class="line">Person.name = &apos;Yang&apos; # 修改了类属性之后  由于多个实例之间共享 所以所有的实例都改变了</span><br><span class="line">print(p1.name) # Yang</span><br><span class="line">print(p2.name) # Yang</span><br></pre></td></tr></table></figure>

<h3 id="类方法-实例方法-静态方法"><a href="#类方法-实例方法-静态方法" class="headerlink" title="类方法  实例方法  静态方法"></a>类方法  实例方法  静态方法</h3><p>先来回顾一下类属性和实例属性以及实例方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Game(object):</span><br><span class="line">    num = 0 # Game类的类属性</span><br><span class="line"></span><br><span class="line">    def __init__(self,name): # 这个方法  称为实例方法</span><br><span class="line">        self.name = name # name为创建的实例的属性</span><br><span class="line"></span><br><span class="line">rainbowSix = Game(&apos;rainbowSix Siege&apos;)</span><br></pre></td></tr></table></figure>

<p>上述例子中,num为Game的类属性，<code>__init__(self)</code>是rainbowSix的<code>实例方法</code>，而name是rainbowSix的<code>实例属性</code>。</p>
<p>那么 如果想给Game类增加一个<code>类方法</code>，可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Game(object):</span><br><span class="line">    num = 0 # Game类的类属性</span><br><span class="line"></span><br><span class="line">    def __init__(self,name): # 这个方法  称为实例方法</span><br><span class="line">        self.name = name # name为创建的实例的属性</span><br><span class="line"></span><br><span class="line">    def printName(self): # printName 也是实例方法</span><br><span class="line">        print(self.name)</span><br><span class="line">    </span><br><span class="line">    @classmethod # 类方法定义使用装饰器</span><br><span class="line">    def get_Game_num(cls): # 形参不写self写cls表示传入的是class的引用</span><br><span class="line">        return cls.num</span><br><span class="line"></span><br><span class="line">rainbowSix = Game(&apos;rainBowSix Siege&apos;)</span><br><span class="line">rainbowSix.printName() # rainBowSix Siege  实例对象调用实例方法</span><br><span class="line">print(Game.get_Game_num()) # 0  类对象调用类方法 </span><br><span class="line"></span><br><span class="line"># 值得注意的是，想调用类方法，实例对象也是可以的</span><br><span class="line"></span><br><span class="line">print(rainbowSix.get_Game_num()) # 0</span><br></pre></td></tr></table></figure>

<p>通过一个装饰器<code>@classmethod</code>来定义一个类方法</p>
<p>上述例子展示了怎么定义即调用一个类方法，再强调一下，调用类方法有2种方法:</p>
<ul>
<li>使用类对象直接调用</li>
<li>通过该类创建的实例对象也可以调用类方法</li>
</ul>
<p>其中不管怎么调用，<code>cls</code>形参指向的还是这个Game类。</p>
<p>接下来再来看静态方法，同样定义也是需要一个<code>@staticmethod</code>装饰器来定义一个静态方法。</p>
<p>不同的是，实例方法接收一个<code>self</code>表示实例对象，类方法接收一个<code>cls</code>参数表示接收一个类对象，而静态方法<strong>可以</strong>不接收参数(当然也可以接收自定义的一些参数)。</p>
<p>静态方法一般只完成一些基本的功能，和类以及实例都没什么太大的关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Game(object):</span><br><span class="line">    num = 0 # Game类的类属性</span><br><span class="line"></span><br><span class="line">    def __init__(self,name): # 这个方法  称为实例方法</span><br><span class="line">        self.name = name # name为创建的实例的属性</span><br><span class="line"></span><br><span class="line">    def printName(self): # printName 也是实例方法</span><br><span class="line">        print(self.name)</span><br><span class="line">    </span><br><span class="line">    @classmethod # 定义类方法</span><br><span class="line">    def get_Game_num(cls): # 形参不写self写cls表示传入的是class的引用</span><br><span class="line">        return cls.num</span><br><span class="line">    </span><br><span class="line">    @staticmethod # 定义静态方法</span><br><span class="line">    def introClass(): # 可以不接受任何参数</span><br><span class="line">        print(&apos;这是一个关于游戏的class&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rainbowSix = Game(&apos;rainBowSix Siege&apos;)</span><br><span class="line"># 关于静态方法的调用  同样也是2种方式 通过类或者是实例对象</span><br><span class="line">rainbowSix.introClass() # 实例对象调用</span><br><span class="line">Game.introClass() # 类对象调用</span><br></pre></td></tr></table></figure>

<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用class中的方法来解耦</span><br><span class="line">class factory:</span><br><span class="line">    def method(self):</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>

<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 在基类中定义一些方法 但是不实现 留到子类中重写方法来实现功能</span><br><span class="line">class Store(object:</span><br><span class="line">    def select_car(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def order(self):</span><br><span class="line">        self.select_car()</span><br><span class="line"></span><br><span class="line">class carStore(Store):</span><br><span class="line">    def select_car(self): # 在子类中重写方法来实现功能</span><br></pre></td></tr></table></figure>


        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

