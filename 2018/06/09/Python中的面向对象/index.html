<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Python中的面向对象 | DeeJay's Blog</title><meta name="description" content="Python中的面向对象"><meta name="keywords" content="Python"><meta name="author" content="DeeJay"><meta name="copyright" content="DeeJay"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Python中的面向对象"><meta name="twitter:description" content="Python中的面向对象"><meta name="twitter:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/1200px-Python-logo-notext.svg.png"><meta property="og:type" content="article"><meta property="og:title" content="Python中的面向对象"><meta property="og:url" content="https://deejay0921.github.io/2018/06/09/Python中的面向对象/"><meta property="og:site_name" content="DeeJay's Blog"><meta property="og:description" content="Python中的面向对象"><meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/1200px-Python-logo-notext.svg.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://deejay0921.github.io/2018/06/09/Python中的面向对象/"><link rel="prev" title="Python中的真假值" href="https://deejay0921.github.io/2018/06/09/Python中的真假值/"><link rel="next" title="Python中列表(dict)和元祖(tuple)的相关操作" href="https://deejay0921.github.io/2018/06/09/Python中列表(dict)和元祖(tuple)的相关操作/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'false',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'false',
  Snackbar: undefined
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">DeeJay's Blog</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="https://avatars1.githubusercontent.com/u/20784273?s=400&amp;u=ba38b4835b7e3c4960763bc6dce9abb320c43f05&amp;v=4" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">152</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">99</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">7</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#面向过程和面向对象的区别"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">面向过程和面向对象的区别</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#类和对象的关系"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">类和对象的关系</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#类的组成"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">类的组成</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#init-self-方法"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">__init__(self)方法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#init-方法的具体使用举例："><span class="toc_mobile_items-number">4.0.1.</span> <span class="toc_mobile_items-text">__init__()方法的具体使用举例：</span></a></li></ol></li></ol><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#str-方法"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">__str__()方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#私有属性"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">私有属性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#私有方法"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">私有方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#继承"><span class="toc_mobile_items-number"></span> <span class="toc_mobile_items-text">继承</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#重写"><span class="toc_mobile_items-number"></span> <span class="toc_mobile_items-text">重写</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#私有属性和私有变量的继承机制"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">私有属性和私有变量的继承机制</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#多继承"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">多继承</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#多继承中的注意点-mro"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">多继承中的注意点  __mro__</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#多态"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">多态</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#类属性-实例属性"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">类属性  实例属性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#类方法-实例方法-静态方法"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">类方法  实例方法  静态方法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#简单工厂模式"><span class="toc_mobile_items-number"></span> <span class="toc_mobile_items-text">简单工厂模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#工厂方法模式"><span class="toc_mobile_items-number"></span> <span class="toc_mobile_items-text">工厂方法模式</span></a></li></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#面向过程和面向对象的区别"><span class="toc-number">1.</span> <span class="toc-text">面向过程和面向对象的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类和对象的关系"><span class="toc-number">2.</span> <span class="toc-text">类和对象的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的组成"><span class="toc-number">3.</span> <span class="toc-text">类的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#init-self-方法"><span class="toc-number">4.</span> <span class="toc-text">__init__(self)方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#init-方法的具体使用举例："><span class="toc-number">4.0.1.</span> <span class="toc-text">__init__()方法的具体使用举例：</span></a></li></ol></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#str-方法"><span class="toc-number">5.</span> <span class="toc-text">__str__()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#私有属性"><span class="toc-number">6.</span> <span class="toc-text">私有属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#私有方法"><span class="toc-number">7.</span> <span class="toc-text">私有方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承"><span class="toc-number"></span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重写"><span class="toc-number"></span> <span class="toc-text">重写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#私有属性和私有变量的继承机制"><span class="toc-number">1.</span> <span class="toc-text">私有属性和私有变量的继承机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多继承"><span class="toc-number">2.</span> <span class="toc-text">多继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多继承中的注意点-mro"><span class="toc-number">3.</span> <span class="toc-text">多继承中的注意点  __mro__</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态"><span class="toc-number">4.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类属性-实例属性"><span class="toc-number">5.</span> <span class="toc-text">类属性  实例属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类方法-实例方法-静态方法"><span class="toc-number">6.</span> <span class="toc-text">类方法  实例方法  静态方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#简单工厂模式"><span class="toc-number"></span> <span class="toc-text">简单工厂模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#工厂方法模式"><span class="toc-number"></span> <span class="toc-text">工厂方法模式</span></a></li></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/1200px-Python-logo-notext.svg.png)"><div id="post-info"><div id="post-title"><div class="posttitle">Python中的面向对象</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2018-06-09<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-11-17</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Python/">Python</a></span><div class="post-meta-wordcount"><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>Python中的面向对象</p>
<a id="more"></a>

<p>#　Python中的面向对象</p>
<h3 id="面向过程和面向对象的区别"><a href="#面向过程和面向对象的区别" class="headerlink" title="面向过程和面向对象的区别"></a>面向过程和面向对象的区别</h3><ul>
<li>面向过程：根据业务逻辑从上到下写代码</li>
<li>面向对象：将数据和函数绑定到一起，进行封装，这样能够更快速的进行开发程序，减少重复代码的书写</li>
</ul>
<h3 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h3><p>在面向对象的概念中，对象是核心，那么为了将一堆具有相同特征和行为的对象进行抽象定义，就提出了一个概念叫<strong>类</strong></p>
<p>举个例子：类就相当于小时候组装赛车的图纸，组装出来的赛车就是对象。</p>
<h3 id="类的组成"><a href="#类的组成" class="headerlink" title="类的组成"></a>类的组成</h3><p>类名，类的属性(数据)，类的方法(对数据操作的行为)</p>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def sayHi(self):</span><br><span class="line">        print(&apos;hello&apos;)</span><br><span class="line">    </span><br><span class="line">    def introduce(self):</span><br><span class="line">        print(&apos;this is %s speaking&apos;%self.name)</span><br><span class="line"></span><br><span class="line">DeeJay = Person()</span><br><span class="line"></span><br><span class="line">DeeJay.name = &apos;DeeJay&apos;</span><br><span class="line"></span><br><span class="line">DeeJay.sayHi() # hello</span><br><span class="line">DeeJay.introduce() # this is DeeJay speaking</span><br></pre></td></tr></table></figure>

<p>上面定义了一个Person类，DeeJay是这个类的一个对象。</p>
<p><code>DeeJay = Person()</code>这一句就是创建了一个Person类的对象，其中<code>Person()</code>就是在内存中创建了一个对象，同时这个语句的返回值是这个对象的<strong>引用</strong>，将其赋给了DeeJay这个变量。</p>
<p><code>DeeJay.name = &#39;DeeJay&#39;</code>这一句就是给DeeJay这个对象增添一个属性name。</p>
<p>而<code>sayHi()</code>和<code>introduce()</code>都是Person类定义时候的方法。</p>
<p>值得一提的是上面方法定义时的参数<code>self</code>,类比一下JS中构造函数内部的<code>this</code>，很好理解,当然可以不写成self,但是必须保证要有一个形参</p>
<p>另外写一个JS中构造函数创建示例的例子，来进行对比理解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayHi = function() &#123;</span><br><span class="line">    console.log(&apos;hello&apos;)</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.introduce = function() &#123;</span><br><span class="line">    console.log(`this is $&#123;this.name&#125; speaking`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let DeeJay = new Person(&apos;DeeJay&apos;)</span><br><span class="line">DeeJay.introduce()</span><br></pre></td></tr></table></figure>

<h3 id="init-self-方法"><a href="#init-self-方法" class="headerlink" title="__init__(self)方法"></a><code>__init__(self)</code>方法</h3><p>#####　简介</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    </span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def introduce(self):</span><br><span class="line">        print(&apos;this is %s speaking&apos;%self.name)</span><br><span class="line"></span><br><span class="line">DeeJay = Person()</span><br></pre></td></tr></table></figure>

<p>介绍<code>__init__()</code>就得了解对象创建的流程，在上述例子<code>DeeJay = Person()</code>这一句创建对象的语句中，有如下流程：</p>
<ol>
<li>在内存中创建了一个对象</li>
<li>Python自动调用<code>__init__(self)</code>方法,此时传入的这个self就是创建的那个对象的<strong>引用</strong></li>
<li>执行<code>__init__()</code>方法中的一些默认属性的设定</li>
<li>返回创建好的对象的<strong>引用</strong>,(前4步就是 <code>Person()</code>这个语句做的事)</li>
<li>将引用赋值给DeeJay</li>
</ol>
<h5 id="init-方法的具体使用举例："><a href="#init-方法的具体使用举例：" class="headerlink" title="__init__()方法的具体使用举例："></a><code>__init__()</code>方法的具体使用举例：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    </span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    def introduce(self):</span><br><span class="line">        print(&apos;this is %s speaking&apos;%self.name)</span><br><span class="line"></span><br><span class="line">DeeJay = Person(&apos;DeeJay&apos;,21)</span><br><span class="line"></span><br><span class="line">DeeJay.introduce() # this is DeeJay speaking</span><br></pre></td></tr></table></figure>

<p>上述例子中，<code>Person(&#39;DeeJay&#39;,21)</code>这个语句，在执行到调用<strong>init</strong>()的时候，self指向的是创建的这个对象，<strong>init</strong>()方法还可以接受除了self以外的参数，这些参数可以给创建的这个对象进行属性的初始化。</p>
<p>这么一写，就不需要创建好对象之后再进行属性的添加了。</p>
<h3 id="str-方法"><a href="#str-方法" class="headerlink" title="__str__()方法"></a><code>__str__()</code>方法</h3><p>上面的例子中，如果创建了DeeJay对象之后，使用<code>print(DeeJay)</code>来输出这个对象，得到的是：<code>&lt;__main__.Person object at 0x7f39a0ca5a58&gt;</code></p>
<p>但是如果我们定义了<code>__str__()</code>方法之后，再进行print对象的时候，就会调用这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    </span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &quot;该对象的name为：%s,age为：%d&quot;%(self.name,self.age)</span><br><span class="line"></span><br><span class="line">    def introduce(self):</span><br><span class="line">        print(&apos;this is %s speaking&apos;%self.name)</span><br><span class="line"></span><br><span class="line">DeeJay = Person(&apos;DeeJay&apos;,21)</span><br><span class="line"></span><br><span class="line">Yang = Person(&apos;Yang&apos;,22)</span><br><span class="line"></span><br><span class="line"># print(DeeJay) # &lt;__main__.Person object at 0x7f39a0ca5a58&gt;</span><br><span class="line">print(DeeJay) # 该对象的name为：DeeJay,age为：21</span><br><span class="line">print(Yang) # 该对象的name为：Yang,age为：22</span><br></pre></td></tr></table></figure>

<p>值得注意的是，<code>__str__()</code>中是输出return的值。</p>
<h3 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h3><p>如果有一个对象，需要对其属性进行修改时，一般有2种方法：</p>
<ul>
<li>对象.属性 = 数据 # 直接修改</li>
<li>对象.方法()  # 间接修改</li>
</ul>
<p>一般为了保护对象的属性，即不能随意修改，不建议直接给对象属性直接赋值，一般我们可以采用定义一个方法，来进行给对象添加属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Dog():</span><br><span class="line">    def get_age(self):</span><br><span class="line">        return self.age</span><br><span class="line"></span><br><span class="line">wangwang = Dog()</span><br><span class="line">wangwang.age = 10 # 一般不这么写  而是通过定义一个方法来进行添加属性</span><br><span class="line"></span><br><span class="line">print(wangwang.get_age())</span><br></pre></td></tr></table></figure>

<p>所以可以写成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Dog():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__age = 0 # 定义了一个私有属性 __age</span><br><span class="line"></span><br><span class="line">    def set_age(self,new_age):</span><br><span class="line">        if(new_age &gt; 0):</span><br><span class="line">            self.__age = new_age</span><br><span class="line">        else:</span><br><span class="line">            self.__age = 0 # 可以在添加属性的时候，同时处理一些异常值的情况</span><br><span class="line"></span><br><span class="line">    def get_age(self):</span><br><span class="line">        return self.__age</span><br><span class="line"></span><br><span class="line">wangwang = Dog()</span><br><span class="line">wangwang.set_age(10)</span><br><span class="line"></span><br><span class="line">print(wangwang.get_age()) # 10</span><br><span class="line"></span><br><span class="line">wangwang.set_age(-10)</span><br><span class="line">print(wangwang.get_age()) # 0</span><br></pre></td></tr></table></figure>

<p>这样就通过方法来设置这个私有属性。注意私有属性前要加<code>__</code>,比如说上述例子中的<code>__age</code>,这样通过<code>wangwang.__age</code>就访问不到这个</p>
<h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><p>先来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Dog:</span><br><span class="line">    def print1(self):</span><br><span class="line">        print(&apos;---1----&apos;)</span><br><span class="line"></span><br><span class="line">    def print2(self):</span><br><span class="line">        print(&apos;----2---&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dog = Dog()</span><br><span class="line"></span><br><span class="line">dog.print1() # ---1----</span><br><span class="line">dog.print2() # ----2---</span><br></pre></td></tr></table></figure>

<p>Dog这个类创建出来的dog对象，可以使用定义的<code>print1()</code>和<code>print2()</code>这两个方法。</p>
<p>现在稍作修改,将<code>print1()</code>改为<code>__print1()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Dog:</span><br><span class="line">    def __print1(self):</span><br><span class="line">        print(&apos;---1----&apos;)</span><br><span class="line"></span><br><span class="line">    def print2(self):</span><br><span class="line">        print(&apos;----2---&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dog = Dog()</span><br><span class="line"></span><br><span class="line">dog.print2() # ----2---</span><br><span class="line">dog.__print1() # 报错了 AttributeError: &apos;Dog&apos; object has no attribute &apos;__print1&apos;</span><br></pre></td></tr></table></figure>

<p>那么<code>__print1()</code>就是一个私有方法，不允许直接让对象调用，只能在其他方法内部进行调用。</p>
<p>举个实际的例子来说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Msg():</span><br><span class="line">    def __init__(self,money):</span><br><span class="line">        self.money = money</span><br><span class="line"></span><br><span class="line">    def __sendMsg(self):</span><br><span class="line">        print(&quot;发送短信&quot;)</span><br><span class="line">        self.money -= 10</span><br><span class="line"></span><br><span class="line">    def checkMoneyAndSendMsg(self):</span><br><span class="line">        if(self.money &gt; 10):</span><br><span class="line">            self.__sendMsg() # 调用私有方法 </span><br><span class="line">        else:</span><br><span class="line">            print(&apos;余额不够&apos;)</span><br><span class="line"></span><br><span class="line">message1 = Msg(100)</span><br><span class="line">message1.checkMoneyAndSendMsg() # 发送短信</span><br><span class="line"></span><br><span class="line">message2 = Msg(0)</span><br><span class="line">message2.checkMoneyAndSendMsg() # 余额不够</span><br></pre></td></tr></table></figure>

<p>这个Msg类定义了一个私有方法<code>__sendMsg()</code>用来发送短信，但是得先判断money属性是否足够，所有不允许直接使用对象调用，而是给个公有方法，判断之后在该方法里进行<code>self.__sendMsg()</code>来进行调用</p>
<p>###　<code>__del__()</code></p>
<p>创建对象后,Python默认调用<code>__init__()</code></p>
<p>删除对象时，则会调用<code>__del__()</code></p>
<p>注意这个删除对象，值得是当前指向这个对象的所有引用都消失的时候，程序会自动调用<code>__del__()</code></p>
<p>来看例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Test():</span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&apos;I\&apos;m dead!&apos;)</span><br><span class="line"></span><br><span class="line">t1 = Test()</span><br><span class="line">del t1 # I&apos;m dead!</span><br></pre></td></tr></table></figure>

<p>注意<code>del t1</code>仅仅是将t1对创建的那个对象的引用删除了，如果t1指向的对象同时还在其他地方被引用，那这个对象就没被删除,<code>__del__()</code>不会触发。</p>
<p>可以使用<code>sys</code>模块的<code>sys.getrefcount()</code>方法来判断当前目标有几个引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class T:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">t1 = T()</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">print(sys.getrefcount(t1)) # 2</span><br><span class="line"></span><br><span class="line"># 注意这边输出的是2  因为调用sys.getrefcount(t1) 的时候 将t1也传入了一次</span><br><span class="line"># 所以输出的引用数为 2 </span><br><span class="line"></span><br><span class="line">t2 = t1 # 现在将t1的引用复制一份给t2</span><br><span class="line"></span><br><span class="line">print(sys.getrefcount(t1)) # 3</span><br><span class="line"></span><br><span class="line">del t2</span><br><span class="line"></span><br><span class="line">print(sys.getrefcount(t1)) # 2</span><br><span class="line"></span><br><span class="line">del t1</span><br><span class="line"></span><br><span class="line">print(sys.getrefcount(t1)) # 报错了  NameError: name &apos;t1&apos; is not defined</span><br><span class="line"></span><br><span class="line"># 所以这个方法返回值最小就为2</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>先来看一下最简单的一个继承：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Animal():</span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&apos;eating...&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Dog(Animal): # Dog类继承Animal类</span><br><span class="line">    def bark(self):</span><br><span class="line">        print(&apos;wang wang&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wangcai = Dog()</span><br><span class="line">wangcai.eat() # eating...</span><br></pre></td></tr></table></figure>

<p><code>class Dog(Animal):</code> 就实现了继承</p>
<p>子类可以继承父类(以及父类的父类等)的属性和方法</p>
<h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>子类可以在内部重新定义继承来的方法 称为重写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Dog:</span><br><span class="line">    def bark(self):</span><br><span class="line">        print(&apos;汪汪汪&apos;)</span><br><span class="line"></span><br><span class="line">class Husky(Dog):</span><br><span class="line">    def bark(self):</span><br><span class="line">        print(&apos;哈士奇在汪汪汪&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">h = Husky()</span><br><span class="line">h.bark() # 哈士奇在汪汪汪</span><br></pre></td></tr></table></figure>

<p>这样就实现了重写，但是会有这样一个需求，子类在重写的方法中还想调用父类中被重写的方法，这时候有2种方法：</p>
<p>第一种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Dog:</span><br><span class="line">    def bark(self):</span><br><span class="line">        print(&apos;汪汪汪&apos;)</span><br><span class="line"></span><br><span class="line">class Husky(Dog):</span><br><span class="line">    def bark(self):</span><br><span class="line">        print(&apos;哈士奇在汪汪汪&apos;)</span><br><span class="line">        # 第一种方式</span><br><span class="line">        Dog.bark(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">h = Husky()</span><br><span class="line"># 想在h.bark()中调用Dog类中被重写的bark()</span><br><span class="line">h.bark() # 哈士奇在汪汪汪 汪汪汪</span><br></pre></td></tr></table></figure>

<p>通过在子类的<code>bark()</code>中写上<code>Dog.bark(self)</code>即可调用，注意self不可省略</p>
<p>第二种，使用<code>super()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Dog:</span><br><span class="line">    def bark(self):</span><br><span class="line">        print(&apos;汪汪汪&apos;)</span><br><span class="line"></span><br><span class="line">class Husky(Dog):</span><br><span class="line">    def bark(self):</span><br><span class="line">        print(&apos;哈士奇在汪汪汪&apos;)</span><br><span class="line">        # 第二种方式</span><br><span class="line">        super().bark()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">h = Husky()</span><br><span class="line"># 想在h.bark()中调用Dog类中被重写的bark()</span><br><span class="line">h.bark() # 哈士奇在汪汪汪 汪汪汪</span><br></pre></td></tr></table></figure>

<p>直接写<code>super().bark()</code>即可</p>
<h3 id="私有属性和私有变量的继承机制"><a href="#私有属性和私有变量的继承机制" class="headerlink" title="私有属性和私有变量的继承机制"></a>私有属性和私有变量的继承机制</h3><p>来介绍一下私有属性和方法的继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__privateProperty = &apos;private&apos;</span><br><span class="line">        self.publicProperty = &apos;public&apos;</span><br><span class="line"></span><br><span class="line">    def __privateFn(self):</span><br><span class="line">        print(&apos;privateFn&apos;)</span><br><span class="line">    </span><br><span class="line">    def publicFn(self):</span><br><span class="line">        print(&apos;publicFn&apos;)</span><br><span class="line"></span><br><span class="line">class B(A):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">b = B()</span><br><span class="line"></span><br><span class="line">b.publicFn() # publicFn</span><br><span class="line">print(b.publicProperty) # public</span><br><span class="line"></span><br><span class="line">b.__privateFn() # 报错 AttributeError: &apos;B&apos; object has no attribute &apos;__privateFn&apos;</span><br><span class="line">print(b.__privateProperty) # 报错 AttributeError: &apos;B&apos; object has no attribute &apos;__privateProperty&apos;</span><br></pre></td></tr></table></figure>

<p>通过例子我们可以看出，<strong>私有属性和私有方法，是不可以直接被继承的</strong></p>
<p>但是也有例外，我们如果定义一个共有方法，在其中使用私有方法和属性的话，这个是允许的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__privateProperty = &apos;private&apos;</span><br><span class="line">        self.publicProperty = &apos;public&apos;</span><br><span class="line"></span><br><span class="line">    def __privateFn(self):</span><br><span class="line">        print(&apos;privateFn&apos;)</span><br><span class="line">    </span><br><span class="line">    def publicFn(self):</span><br><span class="line">        print(&apos;publicFn&apos;)</span><br><span class="line"></span><br><span class="line">    def anotherPublicFn(self): #定义一个共有方法来使用私有变量</span><br><span class="line">        print(self.__privateProperty)</span><br><span class="line">        self.__privateFn()</span><br><span class="line"></span><br><span class="line">class B(A):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">b = B()</span><br><span class="line">b.anotherPublicFn() # private privateFn</span><br></pre></td></tr></table></figure>

<p>如上述例子所示。</p>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>多继承指的是一个类同时继承多个类，举个例子，骡子继承驴和马</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Horse:</span><br><span class="line">    def horseSay(self):</span><br><span class="line">        print(&apos;我是马&apos;)</span><br><span class="line"></span><br><span class="line">class Donkey:</span><br><span class="line">    def DonkeySay(self):</span><br><span class="line">        print(&apos;我是驴&apos;)</span><br><span class="line"></span><br><span class="line">class Mule(Horse,Donkey): # 实现了多继承</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">mule = Mule()</span><br><span class="line">mule.horseSay() # 我是马</span><br><span class="line">mule.DonkeySay() # 我是驴</span><br></pre></td></tr></table></figure>

<p>上述例子，Mule类就实现了对Horse类和Donkey类的多继承。</p>
<h3 id="多继承中的注意点-mro"><a href="#多继承中的注意点-mro" class="headerlink" title="多继承中的注意点  __mro__"></a>多继承中的注意点  <code>__mro__</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Base(object):</span><br><span class="line">    def test(self):</span><br><span class="line">        print(&apos;Base&apos;)</span><br><span class="line"></span><br><span class="line">class A(Base):</span><br><span class="line">    def test(self):</span><br><span class="line">        print(&apos;A&apos;)</span><br><span class="line"></span><br><span class="line">class B(Base):</span><br><span class="line">    def test(self):</span><br><span class="line">        print(&apos;B&apos;)</span><br><span class="line"></span><br><span class="line">class C(A,B):</span><br><span class="line">    def test(self):</span><br><span class="line">        print(&apos;C&apos;)</span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line">c.test()</span><br></pre></td></tr></table></figure>

<p>现在有如上例子，C类是对A和B多继承，A和B都继承自Base类，其中他们都有一个test方法，现在如果调用c.test()，到底输出什么？</p>
<p>我们可以输出<code>C.__mro__</code>,结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&lt;class &apos;__main__.C&apos;&gt;, &lt;class &apos;__main__.A&apos;&gt;, &lt;class &apos;__main__.B&apos;&gt;, &lt;class &apos;__main__.Base&apos;&gt;, &lt;class &apos;object&apos;&gt;)</span><br></pre></td></tr></table></figure>

<p>输出了一个元祖，同时表明了去寻找方法的路径，即由C-&gt;A-&gt;B-&gt;Base-&gt;object依次查找，如果找不到就报错说没有该方法。</p>
<p>所以我们知道上面例子会输出啥，先查找到C中的test,如果C中没定义test(),就去A里面找,以此类推。</p>
<p><code>__mro__</code>就是调用一个方法的搜索顺序</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态：定义时的类型和运行时的类型不一样，此时就成为多态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Dog(object):</span><br><span class="line">    def print_self(self):</span><br><span class="line">        print(&apos;汪汪汪&apos;)</span><br><span class="line"></span><br><span class="line">class Husky(Dog):</span><br><span class="line">    def print_self(self):</span><br><span class="line">        print(&apos;我是哈士奇&apos;)</span><br><span class="line"></span><br><span class="line">def introduce(obj): #定义一个函数</span><br><span class="line">    obj.print_self() # 调用传入的obj的print_self()</span><br><span class="line"></span><br><span class="line">dog = Dog()</span><br><span class="line">husky = Husky()</span><br><span class="line"></span><br><span class="line">introduce(dog) # 汪汪汪</span><br><span class="line">introduce(husky) # 我是哈士奇</span><br></pre></td></tr></table></figure>

<p>上述例子就是一个多态，<code>introduce()</code>方法定义时只知道要调用一个对象的方法，但是至于这个方法是调用父类还是子类，要等到开始运行的时候才能确定。</p>
<h3 id="类属性-实例属性"><a href="#类属性-实例属性" class="headerlink" title="类属性  实例属性"></a>类属性  实例属性</h3><p>先来搞清楚什么叫<code>类对象</code>，什么叫<code>实例对象</code><br>我们在Python中定义了一个类之后，这个类也是一个对象，被称为类对象，<br>而通过类创建的对象，为了和类对象区分，称为示例对象。</p>
<p>类属性就是<code>类对象</code>所拥有的属性，它被<code>类对象</code>的<code>实例对象</code>所共有，在内存中只存在<strong>一个副本</strong>。</p>
<p>下面的例子就是 <code>类属性</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class People(object):</span><br><span class="line">    name = &apos;DeeJay&apos; # 共有的 类属性</span><br><span class="line">    __age = 21 # 私有的 类属性</span><br><span class="line"></span><br><span class="line">p = People()</span><br><span class="line"></span><br><span class="line">print(p.name) # DeeJay</span><br><span class="line">print(People.name) # DeeJay</span><br><span class="line"></span><br><span class="line">print(p.__age) # AttributeError: &apos;People&apos; object has no attribute &apos;__age&apos;</span><br><span class="line">print(People.__age) # AttributeError: &apos;People&apos; object has no attribute &apos;__age&apos;</span><br></pre></td></tr></table></figure>

<p>上述例子中，在定义类的时候，直接给类定义了属性，那么这些属性就是<code>类属性</code></p>
<p>那<code>实例对象</code>中的属性就叫<code>实例属性</code>,来看例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">p = Person(&apos;DeeJay&apos;)</span><br><span class="line">print(p.name) # DeeJay</span><br></pre></td></tr></table></figure>

<p>上述例子中，并没有在Person类中直接定义属性，而是在创建实例对象的时候，给实例对象内部创建了属性，所以被称为实例属性。</p>
<ul>
<li><code>实例对象</code>和<code>类对象</code>的区别</li>
</ul>
<p>那么对于<code>实例属性</code>来讲，它只和具体的实例有关系，并且一个实例对象和另一个实例对象之间是<strong>不共享</strong>的;</p>
<p>相应的对于<code>类属性</code>来说，<code>类属性</code>所属于类对象，并且多个实例对象之间，共享同一个<code>类属性</code>，另外前面已经提到过，<code>类属性</code>只会定义一次。</p>
<p>对于<code>类属性</code>来讲，一个类创建的所有对象中，都<strong>共享</strong>这个类中的<code>类属性</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    name = &apos;DeeJay&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = Person()</span><br><span class="line">p2 = Person()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(p1.name) # DeeJay</span><br><span class="line">Person.name = &apos;Yang&apos; # 修改了类属性之后  由于多个实例之间共享 所以所有的实例都改变了</span><br><span class="line">print(p1.name) # Yang</span><br><span class="line">print(p2.name) # Yang</span><br></pre></td></tr></table></figure>

<h3 id="类方法-实例方法-静态方法"><a href="#类方法-实例方法-静态方法" class="headerlink" title="类方法  实例方法  静态方法"></a>类方法  实例方法  静态方法</h3><p>先来回顾一下类属性和实例属性以及实例方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Game(object):</span><br><span class="line">    num = 0 # Game类的类属性</span><br><span class="line"></span><br><span class="line">    def __init__(self,name): # 这个方法  称为实例方法</span><br><span class="line">        self.name = name # name为创建的实例的属性</span><br><span class="line"></span><br><span class="line">rainbowSix = Game(&apos;rainbowSix Siege&apos;)</span><br></pre></td></tr></table></figure>

<p>上述例子中,num为Game的类属性，<code>__init__(self)</code>是rainbowSix的<code>实例方法</code>，而name是rainbowSix的<code>实例属性</code>。</p>
<p>那么 如果想给Game类增加一个<code>类方法</code>，可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Game(object):</span><br><span class="line">    num = 0 # Game类的类属性</span><br><span class="line"></span><br><span class="line">    def __init__(self,name): # 这个方法  称为实例方法</span><br><span class="line">        self.name = name # name为创建的实例的属性</span><br><span class="line"></span><br><span class="line">    def printName(self): # printName 也是实例方法</span><br><span class="line">        print(self.name)</span><br><span class="line">    </span><br><span class="line">    @classmethod # 类方法定义使用装饰器</span><br><span class="line">    def get_Game_num(cls): # 形参不写self写cls表示传入的是class的引用</span><br><span class="line">        return cls.num</span><br><span class="line"></span><br><span class="line">rainbowSix = Game(&apos;rainBowSix Siege&apos;)</span><br><span class="line">rainbowSix.printName() # rainBowSix Siege  实例对象调用实例方法</span><br><span class="line">print(Game.get_Game_num()) # 0  类对象调用类方法 </span><br><span class="line"></span><br><span class="line"># 值得注意的是，想调用类方法，实例对象也是可以的</span><br><span class="line"></span><br><span class="line">print(rainbowSix.get_Game_num()) # 0</span><br></pre></td></tr></table></figure>

<p>通过一个装饰器<code>@classmethod</code>来定义一个类方法</p>
<p>上述例子展示了怎么定义即调用一个类方法，再强调一下，调用类方法有2种方法:</p>
<ul>
<li>使用类对象直接调用</li>
<li>通过该类创建的实例对象也可以调用类方法</li>
</ul>
<p>其中不管怎么调用，<code>cls</code>形参指向的还是这个Game类。</p>
<p>接下来再来看静态方法，同样定义也是需要一个<code>@staticmethod</code>装饰器来定义一个静态方法。</p>
<p>不同的是，实例方法接收一个<code>self</code>表示实例对象，类方法接收一个<code>cls</code>参数表示接收一个类对象，而静态方法<strong>可以</strong>不接收参数(当然也可以接收自定义的一些参数)。</p>
<p>静态方法一般只完成一些基本的功能，和类以及实例都没什么太大的关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Game(object):</span><br><span class="line">    num = 0 # Game类的类属性</span><br><span class="line"></span><br><span class="line">    def __init__(self,name): # 这个方法  称为实例方法</span><br><span class="line">        self.name = name # name为创建的实例的属性</span><br><span class="line"></span><br><span class="line">    def printName(self): # printName 也是实例方法</span><br><span class="line">        print(self.name)</span><br><span class="line">    </span><br><span class="line">    @classmethod # 定义类方法</span><br><span class="line">    def get_Game_num(cls): # 形参不写self写cls表示传入的是class的引用</span><br><span class="line">        return cls.num</span><br><span class="line">    </span><br><span class="line">    @staticmethod # 定义静态方法</span><br><span class="line">    def introClass(): # 可以不接受任何参数</span><br><span class="line">        print(&apos;这是一个关于游戏的class&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rainbowSix = Game(&apos;rainBowSix Siege&apos;)</span><br><span class="line"># 关于静态方法的调用  同样也是2种方式 通过类或者是实例对象</span><br><span class="line">rainbowSix.introClass() # 实例对象调用</span><br><span class="line">Game.introClass() # 类对象调用</span><br></pre></td></tr></table></figure>

<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用class中的方法来解耦</span><br><span class="line">class factory:</span><br><span class="line">    def method(self):</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>

<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 在基类中定义一些方法 但是不实现 留到子类中重写方法来实现功能</span><br><span class="line">class Store(object:</span><br><span class="line">    def select_car(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def order(self):</span><br><span class="line">        self.select_car()</span><br><span class="line"></span><br><span class="line">class carStore(Store):</span><br><span class="line">    def select_car(self): # 在子类中重写方法来实现功能</span><br></pre></td></tr></table></figure>

</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">DeeJay</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://deejay0921.github.io/2018/06/09/Python中的面向对象/">https://deejay0921.github.io/2018/06/09/Python中的面向对象/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://deejay0921.github.io">DeeJay's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python    </a></div><div class="post_share"><div class="social-share" data-image="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/1200px-Python-logo-notext.svg.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2018/06/09/Python中的真假值/"><img class="prev_cover lazyload" data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/1200px-Python-logo-notext.svg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>Python中的真假值</span></div></a></div><div class="next-post pull_right"><a href="/2018/06/09/Python中列表(dict)和元祖(tuple)的相关操作/"><img class="next_cover lazyload" data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/1200px-Python-logo-notext.svg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Python中列表(dict)和元祖(tuple)的相关操作</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2018/06/09/Python中的列表生成式/" title="Python中的列表生成式"><img class="relatedPosts_cover lazyload" data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/1200px-Python-logo-notext.svg.png"><div class="relatedPosts_title">Python中的列表生成式</div></a></div><div class="relatedPosts_item"><a href="/2018/06/10/Python中关于字典的一些API/" title="Python中关于字典的一些API"><img class="relatedPosts_cover lazyload" data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/1200px-Python-logo-notext.svg.png"><div class="relatedPosts_title">Python中关于字典的一些API</div></a></div><div class="relatedPosts_item"><a href="/2018/06/09/Python中字符串的常见操作/" title="Python中字符串的常见操作"><img class="relatedPosts_cover lazyload" data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/1200px-Python-logo-notext.svg.png"><div class="relatedPosts_title">Python中字符串的常见操作</div></a></div><div class="relatedPosts_item"><a href="/2018/06/12/Python中值得关注的一些知识点/" title="Python中值得关注的一些知识点"><img class="relatedPosts_cover lazyload" data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/1200px-Python-logo-notext.svg.png"><div class="relatedPosts_title">Python中值得关注的一些知识点</div></a></div><div class="relatedPosts_item"><a href="/2018/06/09/Python中的set类型-以及-数组去重问题/" title="Python中的set类型-以及-数组去重问题"><img class="relatedPosts_cover lazyload" data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/1200px-Python-logo-notext.svg.png"><div class="relatedPosts_title">Python中的set类型-以及-数组去重问题</div></a></div><div class="relatedPosts_item"><a href="/2018/06/09/Python中的__new__(cls)-以及-单例模式/" title="Python中的__new__(cls)-以及-单例模式"><img class="relatedPosts_cover lazyload" data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/1200px-Python-logo-notext.svg.png"><div class="relatedPosts_title">Python中的__new__(cls)-以及-单例模式</div></a></div></div><div class="clear_both"></div></div></div></div><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2019 By DeeJay</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script></body></html>