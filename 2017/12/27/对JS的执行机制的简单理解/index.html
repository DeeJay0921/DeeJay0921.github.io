<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content>
  <meta name="author" content="DeeJay">
  <!-- Open Graph Data -->
  <meta property="og:title" content="对JS的执行机制的简单理解">
  <meta property="og:description" content="web前端 Java后端">
  <meta property="og:site_name" content="DeeJay&#39;s Blog">
  <meta property="og:type" content="article">
  <meta property="og:image" content="https://deejay0921.github.io">
  
    <link rel="alternate" href="/atom.xml" title="DeeJay&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.jpg">
  

  <!-- Site Title -->
  <title>DeeJay's Blog</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/blog-banner2.png)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">对JS的执行机制的简单理解</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/DeeJay0921">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:1018805743@qq.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By DeeJay</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2017-12-27</span>
            <span class="time">18:00:32</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/前端/">前端</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/前端/">#前端</a> <a class="tag" href="/tags/JS/">#JS</a> <a class="tag" href="/tags/JS执行机制/">#JS执行机制</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p>对JS的执行机制的简单理解</p>
<a id="more"></a>

<h2 id="一，JS是单线程"><a href="#一，JS是单线程" class="headerlink" title="一，JS是单线程"></a>一，JS是单线程</h2><p>JS从一开始设计就是单线程，这样可以避免一些复杂的同步问题。</p>
<p>HTML 5提出了web worker标准，可以允许JS创建多个线程，但是<strong>子线程完全受主线程控制，且不得操作DOM</strong>。<strong>JS的单线程本质并没有发生改变</strong>（也不可能改变）。</p>
<h2 id="二，task-queue"><a href="#二，task-queue" class="headerlink" title="二，task queue"></a>二，task queue</h2><p>单线程的缺点是，所有任务都要排队，前一个任务执行完，后一个才能进行执行。这样带来的弊端就是，如果前一个任务耗时很长，并且不是因为cpu计算复杂等的原因引起的（比如ajax去请求数据），那么这时傻傻等着前一个任务执行完就很不合适。<br>为此，JS中的任务分为<strong>同步任务</strong>（synchronous）和<strong>异步任务</strong>（asynchronous）：</p>
<ul>
<li>同步任务：  指的是在主线程上排队执行的任务，前一个任务执行完，后一个才能执行。</li>
<li>异步任务： 指的是 <strong>不进入主线程，而是进入任务队列（task queue），当task queue中的某个任务执行完成了，才通知主线程，该任务才会进入主线程</strong>。</li>
</ul>
<h4 id="！具体的执行机制！"><a href="#！具体的执行机制！" class="headerlink" title="！具体的执行机制！"></a>！具体的执行机制！</h4><ol>
<li>所有的<strong>同步任务</strong>，都在主线程上执行，形成一个execution context task(执行栈)；</li>
<li>主线程之外，还有一个<strong>task queue</strong>，只要<strong>异步任务</strong>执行完，就<strong>在task queue中放置一个事件</strong>；</li>
<li>一旦execution context task中的同步任务执行完，就去<strong>查看task queue中的事件</strong>。找到<strong>该事件（可以是多个）对应的异步任务</strong>，这些<strong>异步任务就进入execution context task</strong>，开始进行执行。</li>
<li>主线程<strong>循环重复查看task queue</strong>，有事件就再去找到对应的异步任务，加到执行栈中执行。只要<strong>主线程空了，就去查看task queue找事件对应的异步任务进行执行</strong>，不断循环。</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/7113407-3fbfb0b4ed2ecad1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="执行机制示意图"></p>
<h2 id="三，事件和回调函数"><a href="#三，事件和回调函数" class="headerlink" title="三，事件和回调函数"></a>三，事件和回调函数</h2><p>首先明确一点，<strong>异步任务必须指定回调函数</strong>，回调函数就是会被主线程挂起来暂缓执行的代码。例如监听click,scroll这些事件时，要设置相应的回调函数，ajax请求数据的时候，也会设置相应的回调。当<strong>主线程开始执行异步任务的时候，就是执行对应的回调函数。</strong></p>
<p>task queue是一个<strong>事件的队列</strong>，设备每完成一个<strong>异步任务</strong>，就像task queue中添加一个事件，表示这个事件对应的异步任务可以进入执行栈进行执行了。</p>
<p>并且这个task queue是一个<strong>先进先出</strong>的数据结构，排在前面的事件，优先被主线程读取。只要主线程执行栈一为空，task queue中第一位事件就自动进入执行栈。但是因为setTimeOut等，主线程要先检查一下执行时间，某些事件要到了规定时间才能开始执行（即进入主线程执行栈）。</p>
<p>task queue中的事件，除了设备的事件外，也包括用户产生的事件（例如click,scroll）这种，所有的异步任务，都有对应的回调函数，这些事件发生后，这些事件就进入task queue，然后等待主线程读取。当主线程开始执行的时候，就执行这些事件对应的回调函数。</p>
<h2 id="四，！Event-Loop"><a href="#四，！Event-Loop" class="headerlink" title="四，！Event Loop!"></a>四，！Event Loop!</h2><p>上面提到的主线程从task queue读取事件，执行其对应的异步任务这个过程是不断循环的，所以这个运行机制被称为 <strong>Event Loop</strong>.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7113407-d1a7e2af0af40636.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="event loop 图解"></p>
<p>在主线程运行的时候，产生了heap和stack,其中stack（栈）中的代码调用各种webAPI（比如click,scroll,ajax）这些操作，在执行的时候，将相应的事件加入task queue中，当stack中的代码执行完之后，就会去task queue中读取事件，依次执行这些事件对应的回调函数。</p>
<p>另外，<strong>执行栈中的代码（同步任务）总是先于task queue的代码（异步任务）。</strong></p>
<h2 id="五，对setTimeout-setInterval的理解"><a href="#五，对setTimeout-setInterval的理解" class="headerlink" title="五，对setTimeout/setInterval的理解"></a>五，对setTimeout/setInterval的理解</h2><p>这俩运行机制都是一样的，task queue除了可以放置异步任务对应的事件，还能放置定时事件，即规定某些代码（setTimeout的回调）在多少时间后进行。</p>
<h6 id="setTimeout-callback-0"><a href="#setTimeout-callback-0" class="headerlink" title="setTimeout(callback,0)"></a>setTimeout(callback,0)</h6><p>这个就是制定cb在<strong>主线程最早空闲的时候运行</strong>。意味着，要<strong>等主线程所有的同步任务执行完，然后task queue中前面的事件对应的异步任务也执行完之后才执行</strong>。</p>
<p>setTimeout做的事就把这个定时事件插入了task queue，执行要等主线程的执行栈清空才回去读取事件，所以如果前面的代码执行很耗时的话，setTimeout指定的cb不会在规定的时间执行。</p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

