<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content>
  <meta name="author" content="DeeJay">
  <!-- Open Graph Data -->
  <meta property="og:title" content="JS-this_原型链_继承-相关问题">
  <meta property="og:description" content="web前端 Java后端">
  <meta property="og:site_name" content="DeeJay&#39;s Blog">
  <meta property="og:type" content="article">
  <meta property="og:image" content="https://deejay0921.github.io">
  
    <link rel="alternate" href="/atom.xml" title="DeeJay&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.jpg">
  

  <!-- Site Title -->
  <title>DeeJay's Blog</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/blog-banner2.png)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">JS-this_原型链_继承-相关问题</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/DeeJay0921">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:1018805743@qq.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By DeeJay</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2017-09-02</span>
            <span class="time">01:29:23</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/前端/">前端</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/前端/">#前端</a> <a class="tag" href="/tags/JS/">#JS</a> <a class="tag" href="/tags/this/">#this</a> <a class="tag" href="/tags/原型/">#原型</a> <a class="tag" href="/tags/prototype/">#prototype</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p>JS-this_原型链_继承-相关问题</p>
<a id="more"></a>

<p>##this</p>
<p>###1,apply、call 、bind有什么作用，什么区别</p>
<ul>
<li>apply/call:调用一个函数，传入函数执行上下文及参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn.call(context,param1,param2...);</span><br><span class="line">fn.apply(context,paramArray;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>语法很简单，第一个参数都是希望设置的this对象，不同之处在于call方法接收参数列表，而apply接收参数数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var value = 100;</span><br><span class="line">var obj4 = &#123;</span><br><span class="line">    value: 200</span><br><span class="line">&#125;</span><br><span class="line">function fn4(a,b) &#123;</span><br><span class="line">    console.log(this.value + a + b);</span><br><span class="line">&#125;</span><br><span class="line">fn4(3,4); // 107</span><br><span class="line">fn4.call(obj4,3,4);//207</span><br><span class="line">fn4.apply(obj4,[3,4]); //207</span><br></pre></td></tr></table></figure>

<ul>
<li>bind:返回一个函数，并且使函数内部的this为传入的第一个参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">    name: &apos;deejay&apos;,</span><br><span class="line">    age: 20,</span><br><span class="line">    fn: function () &#123;</span><br><span class="line">        console.log(this); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var obj3 = &#123;</span><br><span class="line">    a: 3,</span><br><span class="line">&#125;</span><br><span class="line">var fn3 = obj1.fn.bind(obj3);</span><br><span class="line">fn3(); //obj3</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>apply/call是指的调用一个函数，传入这个函数的执行上下文和参数。而bind是指的是返回一个函数，并且使函数内部的this为传入的第一个参数。<br>call/apply在函数调用时使用，bind在函数声明时使用。 bind() 方法会返回执行上下文被改变的函数而不会立即执行，而call/apply是直接执行该函数。</p>
<p>###2,以下代码输出什么?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var john = &#123;</span><br><span class="line">    firstName: &quot;John&quot;</span><br><span class="line">&#125;</span><br><span class="line">function func() &#123;</span><br><span class="line">    alert(this.firstName + &quot;: hi!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">john.sayHi = func</span><br><span class="line">john.sayHi()//John: hi!</span><br></pre></td></tr></table></figure>

<p>###3,以下代码输出什么?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func()</span><br><span class="line">function func() &#123;</span><br><span class="line">    alert(this) //window</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看做window.func();</p>
<p>###4，下面代码输出什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&apos;click&apos;, function(e)&#123;</span><br><span class="line">    console.log(this); //#document</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(this);//window</span><br><span class="line">    &#125;, 200);</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<p>setTimeoutl这个方法执行的函数this是全局对象,<br>在事件处理程序中this代表事件源DOM对象</p>
<p>###5，下面代码输出什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var john = &#123;</span><br><span class="line">    firstName: &quot;John&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function func() &#123;</span><br><span class="line">    alert( this.firstName )</span><br><span class="line">&#125;</span><br><span class="line">func.call(john);//John</span><br></pre></td></tr></table></figure>

<p>使用了call方法，调用了func(),并且将内部this修改为john</p>
<p>###6，以下代码有什么问题，如何修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var module= &#123;</span><br><span class="line">  bind: function()&#123;</span><br><span class="line">    $btn.on(&apos;click&apos;, function()&#123;</span><br><span class="line">      console.log(this) //this指什么</span><br><span class="line">      this.showMsg();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  showMsg: function()&#123;</span><br><span class="line">    console.log(&apos;deejay&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题出在了在事件处理程序中this代表事件源DOM对象，所以点击的时候的this是当前点击的DOM元素，没有showMsg这个方法，解决方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var module= &#123;</span><br><span class="line">    bind: function()&#123;</span><br><span class="line">        var self = this;</span><br><span class="line">        console.log(self);</span><br><span class="line">        $btn.on(&apos;click&apos;, function()&#123;</span><br><span class="line">            console.log(this); //this指的是当前触发点击事件的DOM元素</span><br><span class="line">            self.showMsg()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    showMsg: function()&#123;</span><br><span class="line">        console.log(&apos;deejay&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里设置一个self保存有showMsg()方法的this，即module，然后调用showMsg</p>
<p>##原型链</p>
<p>###7，有如下代码，解释Person、 prototype、<strong>proto</strong>、p、constructor之间的关联。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line">    console.log(&apos;My name is :&apos; + this.name);</span><br><span class="line">&#125;</span><br><span class="line">var p = new Person(&quot;deejay&quot;)</span><br><span class="line">p.sayName();//My name is :deejay</span><br></pre></td></tr></table></figure>

<p>本例中，Person作为构造函数，创建了它的实例p,实例p存在一个属性__proto__，等于Person.prototype,而Person中存在一个Person.prototype对象，其有一个属性constructor，这个属性又指向Person。<br>即有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.__proto__ === Person.prototype;</span><br><span class="line">Person.prototype.constructor === Person;</span><br></pre></td></tr></table></figure>

<p>###8，上例中，对对象 p可以这样调用 p.toString()。toString是哪里来的? 画出原型图?并解释什么是原型链。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7113407-312e708a999fa825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"></p>
<p>原型图如图所示，当调用p的toString()时，会先在实例中寻找，如果找不到，再到p.__proto__属性中，即Person.prototype中寻找，当在Person.prototype中寻找不到时，会到Person.prototype.__proto__中也就是Object.prototype中寻找，然后就寻找到了toString()。<br>所以整个过程为p 到 p.__proto__  再到 p.__proto__.__proto__中，逐级向上查找即为原型链。</p>
<p>###9，对String做扩展，实现如下方式获取字符串中频率最高的字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;ahbbccdeddddfg&apos;;</span><br><span class="line">var ch = str.getMostOften();</span><br><span class="line">console.log(ch); //d , 因为d 出现了5次</span><br></pre></td></tr></table></figure>

<p>给str的构造函数String的prototype添加函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    String.prototype.getMostOften = function () &#123;</span><br><span class="line">//等价于 str.__proto__.getMostOften = ...</span><br><span class="line">        var dict = &#123;&#125;;</span><br><span class="line">        var count;</span><br><span class="line">        var maxvalue = 0;</span><br><span class="line">        for (var i = 0; i &lt; this.length; i ++) &#123;</span><br><span class="line">            if (dict[this[i]]) &#123;</span><br><span class="line">                dict[this[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                dict[this[i]] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (var key in dict) &#123;</span><br><span class="line">            if (dict[key] &gt; maxvalue) &#123;</span><br><span class="line">                maxvalue = dict[key];</span><br><span class="line">                count = key;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">    var str = &apos;ahbbccdeddddfg&apos;;</span><br><span class="line">    var ch = str.getMostOften();</span><br><span class="line">    console.log(ch); //d , 因为d 出现了5次</span><br></pre></td></tr></table></figure>

<p>###10， instanceOf有什么作用？内部逻辑是如何实现的？<br>instanceOf用来判断某个对象是否是某函数的实例</p>
<p>主要实现逻辑为，先判断p.__proto__  是否为Person.prototype，如果不是，接着判断p.__proto__ .__proto__ 是否为Person.prototype,…直到为null返回false，如果在查找途中发现是Person.prototype的实例，返回true</p>
<p>##继承</p>
<p>###11，继承有什么作用?</p>
<p>继承是指一个对象直接使用另一对象的属性和方法。</p>
<p>如果要创建一个子类，不用重新复制一遍父类的代码，可以直接继承然后进行添加子类自己的属性和方法</p>
<p>###12，下面两种写法有什么区别?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//方法1</span><br><span class="line">function People(name, sex)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.sex = sex;</span><br><span class="line">    this.printName = function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var p1 = new People(&apos;前端&apos;, 2)</span><br><span class="line"></span><br><span class="line">//方法2</span><br><span class="line">function Person(name, sex)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.printName = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var p1 = new Person(&apos;deejay&apos;, 21);</span><br></pre></td></tr></table></figure>

<p>方法1是在每次创建一个实例的时候都会相应的给实例也创建一个printName()，如果创建了多个实例的话每个实例都会有一个相同的printName()。<br>方法2是在构造函数的prototype中添加一个printName()，作为所有实例的公共方法，这样多个所有被创建的实例自身只有自身的属性，而printName()是公用的，只有一个，节省了内存。</p>
<p>###13， Object.create 有什么作用？兼容性如何？<br>Object.create() 方法会使用指定的原型对象及其属性去创建一个新的对象。<br>Object.create是ES5方法</p>
<p>###14， hasOwnProperty有什么作用？ 如何使用？</p>
<p>是Object.prototype的一个方法，可以判断一个对象是否包含自定义属性而不是原型链上的属性，hasOwnProperty是JS中唯一一个处理属性但是不查找原型链的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age) &#123;</span><br><span class="line">    this.name = name;;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var p1 = new Person(&apos;deejay&apos;,21);</span><br><span class="line">p1.hasOwnProperty(&apos;name&apos;);//true</span><br><span class="line">p1.hasOwnProperty(&apos;age&apos;);//true</span><br><span class="line">p1.hasOwnProperty(&apos;sayName&apos;);//false</span><br></pre></td></tr></table></figure>

<p>###15，如下代码中call的作用是什么?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, sex)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line">function Male(name, sex, age)&#123;</span><br><span class="line">    Person.call(this, name, sex);    //这里的 call 有什么作用</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的call即为在Male构造函数内部调用Person构造函数，将Male创建的实例this传给Person，达到的效果就是<strong>复制了Person构造函数中的所有属性</strong></p>
<p>###16，补全代码，实现继承 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, sex)&#123;</span><br><span class="line">    // todo ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = function()&#123;</span><br><span class="line">    // todo ...</span><br><span class="line">&#125;;    </span><br><span class="line"></span><br><span class="line">function Male(name, sex, age)&#123;</span><br><span class="line">   //todo ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//todo ...</span><br><span class="line">Male.prototype.getAge = function()&#123;</span><br><span class="line">    //todo ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var deejay= new Male(&apos;deejay&apos;, &apos;男&apos;, 21);</span><br><span class="line">deejay.printName();</span><br></pre></td></tr></table></figure>

<p>实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, sex)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.printName = function()&#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Male(name, sex, age)&#123;</span><br><span class="line">    Person.call(this,name,sex); // 复制Person内部的属性</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Male.prototype = Object.create(Person.prototype); // 实现方法的继承</span><br><span class="line">Male.prototype.getAge = function()&#123;</span><br><span class="line">    console.log(this.age)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var deejay = new Male(&apos;deejay&apos;, &apos;男&apos;, 21);</span><br><span class="line">deejay.printName();//deejay</span><br></pre></td></tr></table></figure>


        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

