<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content>
  <meta name="author" content="DeeJay">
  <!-- Open Graph Data -->
  <meta property="og:title" content="JS-this">
  <meta property="og:description" content="web前端 Java后端">
  <meta property="og:site_name" content="DeeJay&#39;s Blog">
  <meta property="og:type" content="article">
  <meta property="og:image" content="https://deejay0921.github.io">
  
    <link rel="alternate" href="/atom.xml" title="DeeJay&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.jpg">
  

  <!-- Site Title -->
  <title>DeeJay's Blog</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/blog-banner2.png)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">JS-this</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/DeeJay0921">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:1018805743@qq.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By DeeJay</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2017-09-01</span>
            <span class="time">18:00:32</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/前端/">前端</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/前端/">#前端</a> <a class="tag" href="/tags/JS/">#JS</a> <a class="tag" href="/tags/this/">#this</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p>JS对象，原型</p>
<a id="more"></a>


<p><a href="https://zhuanlan.zhihu.com/p/23804247" target="_blank" rel="noopener">转换为call/apply来看待this的值</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/25991271" target="_blank" rel="noopener">彻底搞懂this</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2018/06/javascript-this.html" target="_blank" rel="noopener">阮一峰-this原理</a></p>
<p>#this<br>由于运行期绑定的特性，js中的this含义非常多，它可以是全局对象，当前对象或者任意对象，这完全取决于函数的调用方式<br>随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，就是<strong>this指的是，调用函数的那个对象。</strong></p>
<p>##作为函数调用<br>在函数被直接调用时this绑定到全局对象。在浏览器中，window就是全局对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(this);//window</span><br><span class="line">function fn1() &#123;</span><br><span class="line">    console.log(this); //window</span><br><span class="line">&#125;</span><br><span class="line">fn1();</span><br></pre></td></tr></table></figure>

<p>##内部函数<br>函数嵌套产生的内部函数的this不是其父函数，仍然是全局变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function fn0() &#123;</span><br><span class="line">    function fn () &#123;</span><br><span class="line">        console.log(this);//window</span><br><span class="line">    &#125;</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br><span class="line">fn0();</span><br></pre></td></tr></table></figure>

<p>##setTimeout,setInterval<br>这2个方法执行的函数this也是全局对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&apos;click&apos;,function (e) &#123;</span><br><span class="line">    console.log(this);//#document</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        console.log(this);//window</span><br><span class="line">    &#125;,200)</span><br><span class="line">&#125;,false)</span><br></pre></td></tr></table></figure>

<p>##作为构造函数去调用<br>所谓构造函数，就是通过这个函数生成一个新对象(object)。这时，<strong>this就指这个新对象</strong>。<br>new运算符接受一个函数F及其参数： new F(arguments)，这一过程分为3步：</p>
<ul>
<li>1.创建类的实例。这步是把一个空的对象的proto属性设为F.prototype p1 = {};</li>
<li>2.初始化实例。函数F被传入参数并调用，关键字this被设定为该实例 p1.name = ‘deejay’ p1.sayName=… <strong>此时的this为这个p1实例</strong></li>
<li>3.返回实例 return p1<br>##作为对象方法去调用<br>在JS中，函数也是对象，因此函数可以作为一个对象的属性，此时该函数被称为该对象的方法，在使用这种调用方式时，this被自然绑定到该对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">    name: &apos;deejay&apos;,</span><br><span class="line">    age: 20,</span><br><span class="line">    fn: function () &#123;</span><br><span class="line">        console.log(this); //obj1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj1.fn();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj2 = &#123;</span><br><span class="line">    name: &apos;deejay&apos;,</span><br><span class="line">    age: 20,</span><br><span class="line">    obj3: &#123;</span><br><span class="line">        fn: function () &#123;</span><br><span class="line">            console.log(this); //obj3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj2.obj3.fn(); //总结，谁最后点的fn(),this就为谁</span><br></pre></td></tr></table></figure>

<p>###小陷阱</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var fn2 = obj1.fn;</span><br><span class="line">fn2();//window</span><br></pre></td></tr></table></figure>

<p>##DOM对象绑定事件<br>在事件处理程序中this代表事件源DOM对象（低版本IE有bug，指向了window）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&apos;click&apos;,function (e) &#123;</span><br><span class="line">    console.log(this);//#document</span><br><span class="line">    var _document = this;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        console.log(this);//window</span><br><span class="line">        console.log(_document); // $document</span><br><span class="line">    &#125;,200)</span><br><span class="line">&#125;,false);</span><br></pre></td></tr></table></figure>

<p>setTimeout中是window，事件处理程序中是事件源DOM对象</p>
<p>##Function.prototype.bind<br>切换作用域，任何函数都有的一个方法<br>bind，返回一个函数，并且使函数内部的this为传入的第一个参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">    name: &apos;deejay&apos;,</span><br><span class="line">    age: 20,</span><br><span class="line">    fn: function () &#123;</span><br><span class="line">        console.log(this); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var obj3 = &#123;</span><br><span class="line">    a: 3,</span><br><span class="line">&#125;</span><br><span class="line">var fn3 = obj1.fn.bind(obj3);</span><br><span class="line">fn3(); //obj3</span><br></pre></td></tr></table></figure>

<p>#使用call和apply设置this</p>
<ul>
<li><strong>call,apply，调用一个函数，传入函数执行上下文及参数</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn.call(context,param1,param2...);</span><br><span class="line">fn.apply(context,paramArray;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>语法很简单，第一个参数都是希望设置的this对象，不同之处在于call方法接收参数列表，而apply接收参数数组<br>使用举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var value = 100;</span><br><span class="line">var obj4 = &#123;</span><br><span class="line">    value: 200</span><br><span class="line">&#125;</span><br><span class="line">function fn4(a,b) &#123;</span><br><span class="line">    console.log(this.value + a + b);</span><br><span class="line">&#125;</span><br><span class="line">fn4(3,4); // 107</span><br><span class="line">fn4.call(obj4,3,4);//207</span><br><span class="line">fn4.apply(obj4,[3,4]); //207</span><br></pre></td></tr></table></figure>

<p><strong>利用call/apply改变this解决问题</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,4,5];</span><br><span class="line">Math.max.apply(null,arr); //得到最大值</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//    让类数组对象arguments使用数组的方法</span><br><span class="line">    function joinStr() &#123;</span><br><span class="line">//        return arguments.join(&apos;-&apos;);//error</span><br><span class="line">        return [].join.call(arguments,&apos;-&apos;); //等价于下面的写法</span><br><span class="line">//       return  Array.prototype.join.call(arguments,&apos;-&apos;);</span><br><span class="line">//        如果想使用bind</span><br><span class="line">        var　newJoin = Array.prototype.join.bind(arguments);</span><br><span class="line">        return newJoin(&apos;-&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    var res = joinStr(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;);</span><br><span class="line">    console.log(res);//a-b-c</span><br></pre></td></tr></table></figure>

<p>####caller<br>在函数A调用函数B时，被调用函数B会自动生成一个caller属性，指向调用它的函数对象，如果函数当前没被调用，或并未被其他函数调用，则caller为null</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn4() &#123;</span><br><span class="line">    console.log(fn4.caller); // null</span><br><span class="line">    function fn() &#123;</span><br><span class="line">        console.log(fn.caller); //fn4()</span><br><span class="line">    &#125;</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br><span class="line">fn4();</span><br></pre></td></tr></table></figure>

<p>####arguments<br>在函数调用时，会自动在该函数内部生成一个名为arguments的隐藏对象<br>该对象类似于数组，可以使用[]运算符获取函数调用时的传递的实参<br>只有函数被调用时，arguments对象才会创建，未调用时其值为null</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn5(name,age) &#123;</span><br><span class="line">    console.log(arguments); //[&quot;dejay&quot;, 20, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span><br><span class="line">    name= &apos;xxx&apos;;</span><br><span class="line">    console.log(arguments); //[&quot;xxx&quot;, 20, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span><br><span class="line">    arguments[1] = 30;</span><br><span class="line">    console.log(arguments);//[&quot;xxx&quot;, 30, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span><br><span class="line">&#125;</span><br><span class="line">fn5(&apos;dejay&apos;,20);</span><br></pre></td></tr></table></figure>

<p>####callee<br>当函数被调用时，它的arguments.callee对象就会指向自身，也就是一个对自己的引用。<br>由于arguments在函数调用时才有效，所以未调用时arguments.callee是不存在的，即为null.callee，并且引用它会有异常.</p>
<p>匿名函数的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var i = 0;</span><br><span class="line">window.onclick = function () &#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">    if (i &lt; 5) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        setTimeout(arguments.callee,200);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#关于this的指向的总结（具体见上述代码例子）：</p>
<p>##1,window的情况： </p>
<ul>
<li>作为函数调用</li>
<li>作为内部函数调用</li>
<li>setTimeout,setInterval</li>
<li>小陷阱的情况也属于作为函数调用<br>##2,作为构造函数去调用，即new的时候：</li>
<li>指向构造函数创建的那个实例<br>##3，作为对象方法去调用（例如工厂模式时）：</li>
<li>在使用对象方法调用方式时，this被自然绑定到该对象。<br>##4，DOM对象绑定事件：</li>
<li>此时为事件源DOM对象<br>##5，apply/call</li>
<li>this为apply/call指定的值<br>#函数的执行环境<br>JS中的函数既可以被当做普通函数执行，也可以作为对象的方法执行，这是导致this含义丰富的主要原因。<br>一个函数被执行时，会创建一个执行环境(ExecutionContext)，函数的所有的行为均发生在此执行环境中，构建该执行环境时，JS会首先创建arguments变量，其中包含调用函数时传入的参数。<br>接下来创建作用域链，然后初始化变量。首先初始化函数的形参表，值为arguments变量中对应的值，如果arguments变量中没有对应值，则该形参初始化为undefined。<br>如果该函数中含有内部函数，则初始化这些内部函数。如果没有，继续初始化该函数内定义的局部变量，需要注意的是这些变量初始化为undefined，其赋值操作在执行环境创建成功后，函数执行才会执行，这点对于我们理解JS中的变量作用域非常重要，最后this变量赋值，会根据函数调用方式不同，赋给this全局对象，当前对象等。<br>至此函数的执行环境创建成功，函数会开始逐行执行，所需变量均从之前构建好的执行环境中读取。<br>##三种变量</li>
<li>实例变量： （this）类的实例才能访问到的变量</li>
<li>静态变量： （属性） 直接类型对象能访问到的变量</li>
<li>私有变量： （局部变量）当前作用域内才有效的变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function ClassA() &#123;</span><br><span class="line">    var a = 1; //私有变量 只有函数内部可以访问</span><br><span class="line">    this.b = 2; // 实例变量，只有实例可以访问</span><br><span class="line">&#125;</span><br><span class="line">ClassA.c = 3; //静态变量，也就是属性，类型访问</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(a); //error  外部不能访问函数内部的局部变量</span><br><span class="line">console.log(ClassA.b);//undefined  ClassA没有b这个属性 即静态变量</span><br><span class="line">console.log(ClassA.c); //3  ClassA的一个属性c</span><br><span class="line"></span><br><span class="line">var classa = new ClassA();</span><br><span class="line">console.log(classa.a); //undefined</span><br><span class="line">console.log(classa.b);// 2  实例对象才有实例变量</span><br><span class="line">console.log(classa.c); //undefined</span><br></pre></td></tr></table></figure>


        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

