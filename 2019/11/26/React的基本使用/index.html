<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>React的基本使用 | DeeJay's Blog</title><meta name="description" content="React的基本使用"><meta name="keywords" content="前端,React"><meta name="author" content="DeeJay"><meta name="copyright" content="DeeJay"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="React的基本使用"><meta name="twitter:description" content="React的基本使用"><meta name="twitter:image" content="https://blog.dashlane.com/wp-content/uploads/2016/02/react-logo-2.png"><meta property="og:type" content="article"><meta property="og:title" content="React的基本使用"><meta property="og:url" content="https://deejay0921.github.io/2019/11/26/React的基本使用/"><meta property="og:site_name" content="DeeJay's Blog"><meta property="og:description" content="React的基本使用"><meta property="og:image" content="https://blog.dashlane.com/wp-content/uploads/2016/02/react-logo-2.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://deejay0921.github.io/2019/11/26/React的基本使用/"><link rel="prev" title="React Hooks的基本介绍" href="https://deejay0921.github.io/2019/12/09/React Hooks的基本介绍/"><link rel="next" title="Vue后端渲染之Nuxt.js" href="https://deejay0921.github.io/2019/11/19/Vue后端渲染之Nuxt.js/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'false',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'false',
  Snackbar: undefined
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">DeeJay's Blog</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="https://avatars1.githubusercontent.com/u/20784273?s=400&amp;u=ba38b4835b7e3c4960763bc6dce9abb320c43f05&amp;v=4" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">153</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">99</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">7</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#JSX"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">JSX</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#元素渲染"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">元素渲染</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#组件"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">组件</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#state"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">state</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#setState-updater-callback"><span class="toc_mobile_items-number">3.1.1.</span> <span class="toc_mobile_items-text">setState(updater[, callback])</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#组件生命周期"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">组件生命周期</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#render"><span class="toc_mobile_items-number">3.2.1.</span> <span class="toc_mobile_items-text">render()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#constructor-NaN"><span class="toc_mobile_items-number">3.2.2.</span> <span class="toc_mobile_items-text">constructor()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#componentDidMount"><span class="toc_mobile_items-number">3.2.3.</span> <span class="toc_mobile_items-text">componentDidMount()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#componentDidUpdate-prevProps-prevState-snapshot"><span class="toc_mobile_items-number">3.2.4.</span> <span class="toc_mobile_items-text">componentDidUpdate(prevProps, prevState, snapshot)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#componentWillUnmount"><span class="toc_mobile_items-number">3.2.5.</span> <span class="toc_mobile_items-text">componentWillUnmount()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#shouldComponentUpdate-nextProps-nextState"><span class="toc_mobile_items-number">3.2.6.</span> <span class="toc_mobile_items-text">shouldComponentUpdate(nextProps, nextState)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#static-getDerivedStateFromProps-props-state"><span class="toc_mobile_items-number">3.2.7.</span> <span class="toc_mobile_items-text">static getDerivedStateFromProps(props, state)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#getSnapshotBeforeUpdate-prevProps-prevState"><span class="toc_mobile_items-number">3.2.8.</span> <span class="toc_mobile_items-text">getSnapshotBeforeUpdate(prevProps, prevState)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#定义错误边界组件"><span class="toc_mobile_items-number">3.2.9.</span> <span class="toc_mobile_items-text">定义错误边界组件</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#static-getDerivedStateFromError-error"><span class="toc_mobile_items-number">3.2.10.</span> <span class="toc_mobile_items-text">static getDerivedStateFromError(error)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#componentDidCatch-error-info"><span class="toc_mobile_items-number">3.2.11.</span> <span class="toc_mobile_items-text">componentDidCatch(error, info)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#废弃的一些钩子"><span class="toc_mobile_items-number">3.2.12.</span> <span class="toc_mobile_items-text">废弃的一些钩子</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#component-forceUpdate-callback"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">component.forceUpdate(callback)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#props"><span class="toc_mobile_items-number">3.4.</span> <span class="toc_mobile_items-text">props</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#props-children"><span class="toc_mobile_items-number">3.4.1.</span> <span class="toc_mobile_items-text">props.children</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Render-Props"><span class="toc_mobile_items-number">3.4.2.</span> <span class="toc_mobile_items-text">Render Props</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#props添加默认值defaultProps"><span class="toc_mobile_items-number">3.4.3.</span> <span class="toc_mobile_items-text">props添加默认值defaultProps</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#使用propTypes进行类型检查"><span class="toc_mobile_items-number">3.4.4.</span> <span class="toc_mobile_items-text">使用propTypes进行类型检查</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#事件处理"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">事件处理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#React事件处理函数中的this"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">React事件处理函数中的this</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#事件处理函数的参数"><span class="toc_mobile_items-number">4.1.1.</span> <span class="toc_mobile_items-text">事件处理函数的参数</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#React中的条件渲染"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">React中的条件渲染</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#React中的列表渲染"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">React中的列表渲染</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#React中的Form"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">React中的Form</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#受控表单"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text">受控表单</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#处理不同的受控表单的输入"><span class="toc_mobile_items-number">7.1.1.</span> <span class="toc_mobile_items-text">处理不同的受控表单的输入</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#非受控表单"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text">非受控表单</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#lt-input-type-quot-file-quot-gt-文件上传表单"><span class="toc_mobile_items-number">7.3.</span> <span class="toc_mobile_items-text">&lt;input type=&quot;file&quot;&gt;文件上传表单</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#受控组件vs非受控组件"><span class="toc_mobile_items-number">7.4.</span> <span class="toc_mobile_items-text">受控组件vs非受控组件</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#React中的Ref"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">React中的Ref</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Refs"><span class="toc_mobile_items-number">8.1.</span> <span class="toc_mobile_items-text">Refs</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#React-createRef"><span class="toc_mobile_items-number">8.1.1.</span> <span class="toc_mobile_items-text">React.createRef()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#回调Refs"><span class="toc_mobile_items-number">8.1.2.</span> <span class="toc_mobile_items-text">回调Refs</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Refs转发"><span class="toc_mobile_items-number">8.2.</span> <span class="toc_mobile_items-text">Refs转发</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#React中的高阶组件HOC-High-Order-Component"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">React中的高阶组件HOC(High Order Component)</span></a></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JSX"><span class="toc-number">1.</span> <span class="toc-text">JSX</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#元素渲染"><span class="toc-number">2.</span> <span class="toc-text">元素渲染</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#组件"><span class="toc-number">3.</span> <span class="toc-text">组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#state"><span class="toc-number">3.1.</span> <span class="toc-text">state</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#setState-updater-callback"><span class="toc-number">3.1.1.</span> <span class="toc-text">setState(updater[, callback])</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组件生命周期"><span class="toc-number">3.2.</span> <span class="toc-text">组件生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#render"><span class="toc-number">3.2.1.</span> <span class="toc-text">render()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constructor-NaN"><span class="toc-number">3.2.2.</span> <span class="toc-text">constructor()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#componentDidMount"><span class="toc-number">3.2.3.</span> <span class="toc-text">componentDidMount()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#componentDidUpdate-prevProps-prevState-snapshot"><span class="toc-number">3.2.4.</span> <span class="toc-text">componentDidUpdate(prevProps, prevState, snapshot)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#componentWillUnmount"><span class="toc-number">3.2.5.</span> <span class="toc-text">componentWillUnmount()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shouldComponentUpdate-nextProps-nextState"><span class="toc-number">3.2.6.</span> <span class="toc-text">shouldComponentUpdate(nextProps, nextState)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static-getDerivedStateFromProps-props-state"><span class="toc-number">3.2.7.</span> <span class="toc-text">static getDerivedStateFromProps(props, state)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getSnapshotBeforeUpdate-prevProps-prevState"><span class="toc-number">3.2.8.</span> <span class="toc-text">getSnapshotBeforeUpdate(prevProps, prevState)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定义错误边界组件"><span class="toc-number">3.2.9.</span> <span class="toc-text">定义错误边界组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static-getDerivedStateFromError-error"><span class="toc-number">3.2.10.</span> <span class="toc-text">static getDerivedStateFromError(error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#componentDidCatch-error-info"><span class="toc-number">3.2.11.</span> <span class="toc-text">componentDidCatch(error, info)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#废弃的一些钩子"><span class="toc-number">3.2.12.</span> <span class="toc-text">废弃的一些钩子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#component-forceUpdate-callback"><span class="toc-number">3.3.</span> <span class="toc-text">component.forceUpdate(callback)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#props"><span class="toc-number">3.4.</span> <span class="toc-text">props</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#props-children"><span class="toc-number">3.4.1.</span> <span class="toc-text">props.children</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Render-Props"><span class="toc-number">3.4.2.</span> <span class="toc-text">Render Props</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#props添加默认值defaultProps"><span class="toc-number">3.4.3.</span> <span class="toc-text">props添加默认值defaultProps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用propTypes进行类型检查"><span class="toc-number">3.4.4.</span> <span class="toc-text">使用propTypes进行类型检查</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#事件处理"><span class="toc-number">4.</span> <span class="toc-text">事件处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#React事件处理函数中的this"><span class="toc-number">4.1.</span> <span class="toc-text">React事件处理函数中的this</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#事件处理函数的参数"><span class="toc-number">4.1.1.</span> <span class="toc-text">事件处理函数的参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React中的条件渲染"><span class="toc-number">5.</span> <span class="toc-text">React中的条件渲染</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React中的列表渲染"><span class="toc-number">6.</span> <span class="toc-text">React中的列表渲染</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React中的Form"><span class="toc-number">7.</span> <span class="toc-text">React中的Form</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#受控表单"><span class="toc-number">7.1.</span> <span class="toc-text">受控表单</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#处理不同的受控表单的输入"><span class="toc-number">7.1.1.</span> <span class="toc-text">处理不同的受控表单的输入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#非受控表单"><span class="toc-number">7.2.</span> <span class="toc-text">非受控表单</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lt-input-type-quot-file-quot-gt-文件上传表单"><span class="toc-number">7.3.</span> <span class="toc-text">&lt;input type=&quot;file&quot;&gt;文件上传表单</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#受控组件vs非受控组件"><span class="toc-number">7.4.</span> <span class="toc-text">受控组件vs非受控组件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React中的Ref"><span class="toc-number">8.</span> <span class="toc-text">React中的Ref</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Refs"><span class="toc-number">8.1.</span> <span class="toc-text">Refs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#React-createRef"><span class="toc-number">8.1.1.</span> <span class="toc-text">React.createRef()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#回调Refs"><span class="toc-number">8.1.2.</span> <span class="toc-text">回调Refs</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Refs转发"><span class="toc-number">8.2.</span> <span class="toc-text">Refs转发</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React中的高阶组件HOC-High-Order-Component"><span class="toc-number">9.</span> <span class="toc-text">React中的高阶组件HOC(High Order Component)</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://blog.dashlane.com/wp-content/uploads/2016/02/react-logo-2.png)"><div id="post-info"><div id="post-title"><div class="posttitle">React的基本使用</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-11-26<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-12-29</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/前端/">前端</a></span><div class="post-meta-wordcount"><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>最近准备好好从头开始系统的复习和学习一波React相关技术，本文作为第一篇，先来回顾一波React的基本使用</p>
<a id="more"></a>

<h1 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h1><p>可以将JSX作为看做一个普通的表达式，其内部可以进行标签属性的绑定，事件的监听等操作。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;img src=&#123;user.avatarUrl&#125;&gt;&lt;/img&gt;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为 <code>JSX</code> 语法上更接近<code>JavaScript</code> 而不是<code>HTML</code>，所以<code>React DOM</code>使用 <code>camelCase</code>（小驼峰命名）来定义属性的名称，而不使用<code>HTML</code> 属性名称的命名约定。<br>例如，<code>JSX</code> 里的 <code>class</code> 变成了 <code>className</code>，而<code>tabindex</code>则变为<code>tabIndex</code>。</p>
</blockquote>
<p>另外值得一提的是，<code>React DOM</code>在渲染所有输入内容之前，默认会进行转义,可以有效的防止XSS注入。</p>
<p><code>JSX</code>的写法在编译时其实会被转换为<code>React.createElement()</code>创建的对象,比如代码里面写成:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const element = (</span><br><span class="line">  &lt;h1 className=&quot;greeting&quot;&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">  &lt;/h1&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>就完全等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const element = React.createElement(</span><br><span class="line">  &apos;h1&apos;,</span><br><span class="line">  &#123;className: &apos;greeting&apos;&#125;,</span><br><span class="line">  &apos;Hello, world!&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这个函数创建了一个包含标签类型属性等信息的一个对象。</p>
<h1 id="元素渲染"><a href="#元素渲染" class="headerlink" title="元素渲染"></a>元素渲染</h1><p><code>React</code>是通过<code>ReactDOM.render</code>方法将其目标<code>React</code>元素挂载到<code>DOM</code>节点上的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;</span><br><span class="line">ReactDOM.render(element, document.getElementById(&apos;root&apos;));</span><br></pre></td></tr></table></figure>

<p>对于这种元素，如果想更新的话，可以再次调用<code>ReactDOM.render</code>去进行渲染。不过对于组件内部的<code>state</code>和<code>props</code>变化，<code>React</code>会自动更新。</p>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p><code>React</code>中的组件分为<code>Function Component</code>和<code>Class Component</code>,其中<code>Class Component</code>有一些额外的特性，之后的例子基本都采用这种写法</p>
<h2 id="state"><a href="#state" class="headerlink" title="state"></a><code>state</code></h2><p>组件内部有一些自己维护的数据状态，就可以使用<code>state</code>。<code>state</code>的初始化操作一般放到<code>class</code>的<code>constructor</code>中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;&#125;; // 初始化操作放在这里</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="setState-updater-callback"><a href="#setState-updater-callback" class="headerlink" title="setState(updater[, callback])"></a><code>setState(updater[, callback])</code></h3><p>对于修改<code>state</code>的操作，<code>React</code>提供了<code>setState()</code>方法，这个方法是合并修改的，即<code>state</code>有多个属性如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.state = &#123;</span><br><span class="line">    name: &quot;yang&quot;,</span><br><span class="line">    age: 23</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们调用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;</span><br><span class="line">    name: &quot;zhang&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>之后，其<code>name</code>属性的改动会更新到<code>state</code>上，但是不会对<code>state</code>的<code>age</code>属性去做修改.<br>但是<code>setState</code>对于<code>state</code>的修改是一个异步的操作，其内部会对多个相同的<code>state</code>操作进行合并操作，所以调用<code>setState</code>之后如果马上去使用<code>state</code>的话，其内部的值是没更新的，见下例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">        name: &quot;Yang&quot;,</span><br><span class="line">        age: 23,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">clickBtn = () =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">        name: &quot;zhang&quot;,</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(this.state); // &#123;name: &quot;Yang&quot;, age: 23&#125; 在这state并没有同步更新</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这种情况，<code>setState</code>方法可以传入第二个参数作为<code>callback</code>，其回调函数内部可以获得同步修改之后的值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">clickBtn = (e) =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">        name: &quot;Zhang&quot;</span><br><span class="line">    &#125;, () =&gt; &#123;</span><br><span class="line">        console.log(this.state);// &#123;name: &quot;Zhang&quot;, age: 23&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>另外如果<code>setState()</code>了之后想获得更新后的<code>state</code>的话，也可以在<code>componentDidUpdate(prevState, prevProps, snapShot)</code>中获取到</p>
</blockquote>
<p>除此之外还会有一种情况，比方说我频繁的去调用<code>setState</code>，且每次的<code>state</code>的值的改动会依赖上一次的<code>state</code>的值，这种情况下，普通的调用<code>setState</code>并不会像同步的那样去更新<code>state</code>的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">        counter: 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clickBtn = () =&gt; &#123;</span><br><span class="line">    for (let i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            counter: this.state.counter + 1</span><br><span class="line">        &#125;, () =&gt; &#123;</span><br><span class="line">            console.log(this.state); // console 5次 &#123;counter: 1&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上例所示，这样调用<code>setState</code>的话，<code>state</code>上一次的改动是异步操作，所以几次循环的<code>counter</code>值都为0，最后得到的<code>counter</code>为1。</p>
<p>为了针对上述这种情况，<code>setState</code>方法的第一个参数也可以传入一个函数，其函数的参数为<code>(state, props)</code>，即用上一个 <code>state</code>作为第一个参数，将此次更新被应用时的<code>props</code>做为第二个参数</p>
<p>那么我们做如下改动:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">clickBtn = () =&gt; &#123;</span><br><span class="line">    for (let i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">        this.setState((state, props) =&gt; &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                counter: state.counter + 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, () =&gt; &#123;</span><br><span class="line">            console.log(this.state);  // console 5次 &#123;counter: 5&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即可达到效果，此时<code>counter</code>即为5了</p>
<details>
    <summary>setState扩展阅读：StackOverflow: Dan谈论setState()的更新队列原则</summary>

<pre><code>[原文链接在这](https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973)
总结一下的他的发言：
1. 只要是在事件处理函数中调用的setState，不管有几个组件调用了无论多少次，最后都只会合成一次更新去调用一次render
2. 在事件处理函数中，这种队列的合并总是会按照调用的顺序来进行合并的，即对于同一属性的更新，最后一次的更新永远会覆盖前面的
3. 到React16及之前的版本，都只有事件处理函数式按照上述原则来的，在其他场景比如Ajax请求回调中，这种维持队列更新的原则就不成立
4. React准备在未来的React17中将这种维持队列更新的原则应用到所有地方，
但是在这之前如果想在事件处理函数之外的地方应用，请使用ReactDOM.unstable_batchedUpdates( () =&gt; {doSth;})</code></pre></details>


<p>另外还可以看这个<a href="https://github.com/facebook/react/issues/11527" target="_blank" rel="noopener">Github Issue: gaearon解释为什么state设计成异步更新</a></p>
<h2 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h2><p><a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener">官方图示</a></p>
<p>图示里面很清晰，当第一次挂载时，调用的钩子为：</p>
<ol>
<li><strong><code>constructor()</code></strong></li>
<li><code>static getDerivedStateFromProps()</code></li>
<li><strong><code>render()</code></strong></li>
<li><strong><code>componentDidMount()</code></strong></li>
</ol>
<blockquote>
<p><code>componentWillMount()</code>已被废弃，不建议再使用</p>
</blockquote>
<p>当组件的 props 或 state 发生变化时会触发更新, 调用的钩子为：</p>
<ol>
<li><code>static getDerivedStateFromProps()</code></li>
<li><strong><code>shouldComponentUpdate()</code></strong></li>
<li><strong><code>render()</code></strong></li>
<li><code>getSnapshotBeforeUpdate()</code></li>
<li><strong><code>componentDidUpdate()</code></strong></li>
</ol>
<blockquote>
<p><code>componentWillUpdate()</code> <code>componentWillReceiveProps()</code>已被废弃</p>
</blockquote>
<p>组件卸载时，调用的钩子为:</p>
<ul>
<li><code>componentWillUnmount()</code></li>
</ul>
<p>另外的，当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用：</p>
<ol>
<li><code>static getDerivedStateFromError()</code></li>
<li><strong><code>componentDidCatch()</code></strong></li>
</ol>
<p>接下来介绍一些常用的钩子函数：</p>
<h3 id="render"><a href="#render" class="headerlink" title="render()"></a><code>render()</code></h3><p><code>render()</code>方法是 class 组件中唯一必须实现的方法。</p>
<p><code>render()</code>函数应该为<strong>纯函数</strong>，这意味着在不修改组件 state 的情况下，每次调用时都返回相同的结果，并且它<strong>不会直接与浏览器交互。</strong></p>
<p>如需与浏览器进行交互，请在<code>componentDidMount()</code>或其他生命周期方法中执行你的操作。保持<code>render()</code> 为纯函数，可以使组件更容易思考。</p>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor()"></a><code>constructor()</code></h3><p>只有一个原则，在<code>constructor()</code>中只做3件事：</p>
<ol>
<li><code>super(props)</code>，否则，<code>this.props</code>在构造函数中可能会出现未定义的 bug。</li>
<li>通过给<code>this.state</code>赋值对象来初始化内部<code>state</code></li>
<li>为事件处理函数绑定实例,例如：<code>this.btnClick = this.btnClick.bind(this)</code></li>
</ol>
<p>在<code>constructor()</code>中没有任何必要调用<code>setState()</code>，如有需要直接给<code>this.state</code>赋值即可。</p>
<p>另外，给<code>state</code>赋值<code>props</code>的话，只会保存<code>props</code>的初始值，如果后续<code>props</code>发生变化，其<code>state</code>中的值是<strong>不会</strong>随之更新的，应当避免这种使用，直接使用<code>this.props.xxx</code>即可。</p>
<p>具体可以看这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//ParentComponent</span><br><span class="line">clickBtn = () =&gt; &#123;</span><br><span class="line">    this.setState((state) =&gt; (&#123;</span><br><span class="line">        counter: state.counter + 1</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;SubComponent counter=&#123;this.state.counter&#125; /&gt;</span><br><span class="line"></span><br><span class="line">            &lt;button onClick=&#123;this.clickBtn&#125;&gt;</span><br><span class="line">                click to add counter</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SubComponent</span><br><span class="line">constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">        counter: props.counter</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例中，父组件触发更新时，子组件中，<code>props</code>可以正常更新，但是<code>state.counter</code>并不会更新，仅仅还是第一次的<code>props.counter</code>的值</p>
<h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount()"></a><code>componentDidMount()</code></h3><p><code>componentDidMount()</code>会在组件挂载后（插入<code>DOM</code>树中）立即调用。依赖于<code>DOM</code> 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。</p>
<p>另外在<code>componentDidMount</code>中调用<code>setState()</code>的话，会再次触发<code>render()</code>,可能会有性能问题，所以尽量在<code>constructor()</code>中将<code>state</code>就初始化好。</p>
<h3 id="componentDidUpdate-prevProps-prevState-snapshot"><a href="#componentDidUpdate-prevProps-prevState-snapshot" class="headerlink" title="componentDidUpdate(prevProps, prevState, snapshot)"></a><code>componentDidUpdate(prevProps, prevState, snapshot)</code></h3><p><code>componentDidUpdate()</code>会在更新后会被立即调用。首次渲染<strong>不会执行此方法</strong>。</p>
<p>当组件更新后，可以在此处对<code>DOM</code>进行操作。如果你对更新前后<code>的 props</code>进行了比较，也可以选择在此处进行网络请求。（例如，当<code>props</code>未发生变化时，则不会执行网络请求）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">//    比如说可以这样使用</span><br><span class="line">    if (this.props.userID !== prevProps.userID) &#123;</span><br><span class="line">        this.getData(this.props.userID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外也可以在<code>componentDidUpdate()</code>中调用<code>setState()</code>，但是要预留好出口，即<strong>一定要有条件判断，否则就会陷入死循环</strong>。</p>
<p>其第三个参数<code>snapshot</code>是钩子<code>getSnapshotBeforeUpdate</code>的返回值(如果你定义了的话，没定义就是<code>undefined</code>)</p>
<h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount()"></a><code>componentWillUnmount()</code></h3><p><code>componentWillUnmount()</code> 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如清除 <code>timer</code>，取消网络请求或清除在<code>componentDidMount()</code>中创建的订阅等</p>
<p>另外，不该在<code>componentWillUnmount()</code> 调用<code>setState()</code></p>
<h3 id="shouldComponentUpdate-nextProps-nextState"><a href="#shouldComponentUpdate-nextProps-nextState" class="headerlink" title="shouldComponentUpdate(nextProps, nextState)"></a><code>shouldComponentUpdate(nextProps, nextState)</code></h3><p>当 <code>props/state</code>发生变化时，<code>shouldComponentUpdate()</code>会在渲染执行之前被调用。返回值默认为<code>true</code>。<strong>首次渲染或使用<code>forceUpdate()</code>时不会调用该方法</strong>。</p>
<p>一般是不需要定义该钩子去修改默认行为的，如需做一些性能优化的话，可以考虑<code>React.PureComponent</code>而不是去改其内部逻辑。</p>
<p>如果无论如何都要自己实现<code>shouldComponentUpdate()</code>,可以通过<code>this.props</code>与<code>nextProps</code> 以及<code>this.state</code>与<code>nextState</code> 进行比较，并返回<code>false</code> 以告知<code>React</code>可以跳过更新。</p>
<p>请注意，返回<code>false</code><strong>并不会阻止子组件在<code>state</code>更改时重新渲染</strong>。</p>
<blockquote>
<p><code>shouldComponentUpdate()</code>返回<code>false</code>之后，不会去调用<code>render()</code>和<code>componentWillUpdate(已废弃)</code>以及<code>componentDidUpdate()</code></p>
</blockquote>
<p>另外官方提到说，后续版本可能就算返回了<code>false</code>,也有可能导致组件重新渲染</p>
<details>
    <summary>扩展了解: React.PureComponent</summary>

<pre><code>React.PureComponent和常规的React.Component的区别在于:

React.PureComponent中以浅层对比prop和state的方式来实现了shouldComponentUpdate()。

其内部只对对象做了浅层比较，所以涉及到state/props嵌套较深的情况的时候，尽量不要用React.PureComponent,考虑其他办法，比如forceUpdate()等

总的来说，对于结构简单的state/props，使用React.PureComponent可提高性能</code></pre></details>

<h3 id="static-getDerivedStateFromProps-props-state"><a href="#static-getDerivedStateFromProps-props-state" class="headerlink" title="static getDerivedStateFromProps(props, state)"></a><code>static getDerivedStateFromProps(props, state)</code></h3><p><code>getDerivedStateFromProps</code>会在<strong>调用<code>render</code>方法之前</strong>调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来<strong>更新<code>state</code></strong>，如果返回<code>null</code>则不更新任何内容。</p>
<p>本钩子访问不到组件实例，且用处真的不多，不做过多了解，只需要了解到每次渲染前都会触发<code>static getDerivedStateFromProps()</code>即可。</p>
<blockquote>
<p>一般不需要使用本钩子，常用的场景都有简单的解决方案, 见: <a href="https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html" target="_blank" rel="noopener">you-probably-dont-need-derived-state</a></p>
</blockquote>
<h3 id="getSnapshotBeforeUpdate-prevProps-prevState"><a href="#getSnapshotBeforeUpdate-prevProps-prevState" class="headerlink" title="getSnapshotBeforeUpdate(prevProps, prevState)"></a><code>getSnapshotBeforeUpdate(prevProps, prevState)</code></h3><p>本钩子也<strong>不常用</strong>。</p>
<p><code>getSnapshotBeforeUpdate()</code>在最近一次渲染输出（提交到<code>DOM</code>节点）之前调用。</p>
<p>它使得组件能在发生更改之前从<code>DOM</code>中捕获一些信息（例如，滚动位置）。</p>
<p>此生命周期的任何返回值将作为参数传递给<code>componentDidUpdate()</code>(第三个参数)。</p>
<p>来看具体用法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class SubComponent extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.spanRef = React.createRef();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">        // 定义了getSnapshotBeforeUpdate之后就要定义componentDidUpdate 否则会报warning</span><br><span class="line">        // 因为getSnapshotBeforeUpdate()的返回值只有在componentDidUpdate中使用</span><br><span class="line">        const spanNode = this.spanRef.current;</span><br><span class="line">        return spanNode.innerText; // 无需返回值时返回null即可</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidUpdate(prevProps, prevState, snapShot) &#123;</span><br><span class="line">        // 在这可以获得getSnapshotBeforeUpdate返回的快照 </span><br><span class="line">        // 比如更新后的props.counter为5 会console snapShot props.counter: 4</span><br><span class="line">        console.log(&quot;snapShot&quot;, snapShot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;SubComponent&lt;/h2&gt;</span><br><span class="line">                &lt;span ref=&#123;this.spanRef&#125;&gt;</span><br><span class="line">                    props.counter: &#123;this.props.counter&#125;</span><br><span class="line">                &lt;/span&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义错误边界组件"><a href="#定义错误边界组件" class="headerlink" title="定义错误边界组件"></a>定义错误边界组件</h3><p><strong>任意的</strong><code>React</code>组件，只要定义了<code>static getDerivedStateFromError(error)</code>或者<code>componentDidCatch(error, info)</code>之后，就会成为一个错误边界，其子组件如果出错的话，错误会在这个错误边界组件中被上述2个方法捕获到，所以可以做一些错误处理，比如说更换为出错提示的UI等。</p>
<p>在这看一个错误边界组件的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// ErrorBoundary.js</span><br><span class="line">export default class ErrorBoundary extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            isError: false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static getDerivedStateFromError(error) &#123;</span><br><span class="line">        //    getDerivedStateFromError将抛出的错误作为参数，并返回一个值以更新 state</span><br><span class="line">        console.log(&quot;getDerivedStateFromError: &quot;,error);</span><br><span class="line">        return &#123;</span><br><span class="line">            isError: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        if(this.state.isError) &#123;</span><br><span class="line">            return &lt;h1&gt;出错啦~&lt;/h1&gt;</span><br><span class="line">        &#125;</span><br><span class="line">        return this.props.children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了上述的错误处理组件之后，我们可以将之前的组件作为该错误处理组件的子组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ErrorBoundary&gt;</span><br><span class="line">    &lt;SubComponent counter=&#123;this.state.counter&#125;/&gt;</span><br><span class="line">&lt;/ErrorBoundary&gt;</span><br></pre></td></tr></table></figure>

<h3 id="static-getDerivedStateFromError-error"><a href="#static-getDerivedStateFromError-error" class="headerlink" title="static getDerivedStateFromError(error)"></a><code>static getDerivedStateFromError(error)</code></h3><p> <code>getDerivedStateFromError</code>将抛出的错误作为参数，并返回一个值以更新<code>state</code>,比如上文声明的错误边界组件中的：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> static getDerivedStateFromError(error) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        isError: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p><code>getDerivedStateFromError()</code> 会在<strong>渲染阶段</strong>调用，因此不允许出现副作用。 如遇此类情况，请改用<code>componentDidCatch()</code>。</p>
</blockquote>
<h3 id="componentDidCatch-error-info"><a href="#componentDidCatch-error-info" class="headerlink" title="componentDidCatch(error, info)"></a><code>componentDidCatch(error, info)</code></h3><p> <code>componentDidCatch</code>的第二个参数是一个带错误栈信息的错误信息对象</p>
<p> <code>componentDidCatch()</code>会在<strong>commit阶段</strong>被调用(commit阶段见<a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener">图示</a>)，因此允许执行副作用。 它应该用于记录错误之类的情况</p>
<h3 id="废弃的一些钩子"><a href="#废弃的一些钩子" class="headerlink" title="废弃的一些钩子"></a>废弃的一些钩子</h3><ul>
<li><code>componentWillMount()</code></li>
<li><code>componentWillReceiveProps(nextProps)</code></li>
<li><code>componentWillUpdate(nextProps, nextState)</code></li>
</ul>
<p>上述钩子已经被官方废弃，虽然仍然可以使用，但是并不推荐，官方同时也给出了<a href="https://zh-hans.reactjs.org/blog/2018/03/27/update-on-async-rendering.html" target="_blank" rel="noopener">替代方案</a></p>
<h2 id="component-forceUpdate-callback"><a href="#component-forceUpdate-callback" class="headerlink" title="component.forceUpdate(callback)"></a><code>component.forceUpdate(callback)</code></h2><p>默认情况下，<strong>当组件的<code>state</code>或<code>props</code>发生变化时，组件将重新渲染</strong>。如果<code>render()</code>方法依赖于其他数据，则可以调用 <code>forceUpdate()</code> 强制让组件重新渲染。</p>
<p>调用<code>forceUpdate()</code>将致使组件调用<code>render()</code>方法，此操作会跳过该组件的 <code>shouldComponentUpdate()</code>。</p>
<p>但其子组件会触发正常的生命周期方法，包括<code>shouldComponentUpdate()</code> 方法。<strong>这意味着如果子组件的<code>shouldComponentUpdate</code>返回false的话，子组件不会被重新渲染</strong>。</p>
<p>如果标记发生变化，<code>React</code>仍将只更新<code>DOM</code>。</p>
<blockquote>
<p>通常你应该避免使用<code>forceUpdate()</code>，尽量<code>在 render()</code>中使用<code>this.props</code>和<code>this.state</code></p>
</blockquote>
<h2 id="props"><a href="#props" class="headerlink" title="props"></a><code>props</code></h2><p>对于<code>FunctionComponent</code>来讲，<code>props</code>就是函数的参数，对于<code>ClassComponent</code>，<code>props</code>会被挂到当前组件实例上，通过<code>this.props</code>可以进行访问。</p>
<blockquote>
<p>一样的，<code>props</code>不允许子组件对其进行修改</p>
</blockquote>
<h3 id="props-children"><a href="#props-children" class="headerlink" title="props.children"></a><code>props.children</code></h3><p>每个组件都可以获取到<code>props.children</code>。它包含组件的开始标签和结束标签之间的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Welcome&gt;Hello world!&lt;/Welcome&gt;</span><br></pre></td></tr></table></figure>

<p>在<code>Welcome</code>组件中获取<code>props.children</code>，就可以得到字符串<code>Hello world!</code></p>
<p>对于<code>class</code>组件，请使用<code>this.props.children</code>来获取</p>
<p><code>props.children</code>是一个特殊的<code>prop</code>，通常由<code>JSX</code>表达式中的子组件组成，而非组件本身定义</p>
<h3 id="Render-Props"><a href="#Render-Props" class="headerlink" title="Render Props"></a><code>Render Props</code></h3><p> <code>render prop</code>是指一种在<code>React</code>组件之间使用一个值为函数的<code>prop</code>共享代码的简单技术,即传入一个函数作为<code>props</code>给其他组件：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &lt;DataProvider render=&#123;data =&gt; (</span><br><span class="line">  &lt;h1&gt;Hello &#123;data.target&#125;&lt;/h1&gt;</span><br><span class="line">)&#125;/&gt;</span><br></pre></td></tr></table></figure>

<p> 常用的使用场景: 需要<strong>动态决定组件内部什么东西是需要渲染的</strong>，官方举了大概这么个例子：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> export default class LearnReact extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            x: 0,</span><br><span class="line">            y: 0,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleMouseMove = (e) =&gt; &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            x: e.clientX,</span><br><span class="line">            y: e.clientY,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;learnReact&quot; onMouseMove=&#123;this.handleMouseMove&#125;&gt;</span><br><span class="line">                &lt;p&gt;当前的鼠标位置是 (&#123;this.state.x&#125;, &#123;this.state.y&#125;)&lt;/p&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 现在需要复用该组件内部获取鼠标位置的逻辑做一些额外的操作，比如要获取到当前鼠标位置，达到页面上图片跟着鼠标位置而移动的效果。</p>
<p>比如我们指定目标组件采用<code>&lt;ImgCanMove mouse={ { x, y } } /&gt;</code>这样的方式进行接收参数，其内部实现大概为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import PropTypes from &quot;prop-types&quot;;</span><br><span class="line"></span><br><span class="line">export default class ImgCanMove extends React.Component&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        const mouse = this.props.mouse;</span><br><span class="line">        return (</span><br><span class="line">            &lt;img src=&quot;../logo.png&quot; alt=&quot;目标图片&quot; style=&#123; &#123; position: &apos;absolute&apos;, left: mouse.x, top: mouse.y &#125; &#125; /&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ImgCanMove.propTypes = &#123;</span><br><span class="line">    mouse: PropTypes.shape(&#123;</span><br><span class="line">        x: PropTypes.number.isRequired,</span><br><span class="line">        y: PropTypes.number.isRequired</span><br><span class="line">    &#125;).isRequired</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来就是重点，如果我们不使用<code>render prop</code>去动态的决定其内部渲染什么内容时，我们这时只能将<code>&lt;ImgCanMove /&gt;</code>放到父组件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// LearnReact.js</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;learnReact&quot; onMouseMove=&#123;this.handleMouseMove&#125;&gt;</span><br><span class="line">                &#123;/*&lt;p&gt;当前的鼠标位置是 (&#123;this.state.x&#125;, &#123;this.state.y&#125;)&lt;/p&gt;*/&#125;</span><br><span class="line">                &lt;ImgCanMove mouse=&#123;this.state&#125; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这种方法没什么问题，但是这种情况下，丧失了可复用性，比如我现在又有新的组件也要复用其内部获取鼠标位置的逻辑，那么又得创建一个新组件。</p>
<p>鉴于上述原因，这时候可以使用<code>render prop</code>，动态去决定<code>&lt;LearnReact /&gt;</code>内部渲染什么内容,先修改其内部<code>render()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// LearnReact.js 修改render()</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;learnReact&quot; onMouseMove=&#123;this.handleMouseMove&#125;&gt;</span><br><span class="line">                &#123;/*&lt;p&gt;当前的鼠标位置是 (&#123;this.state.x&#125;, &#123;this.state.y&#125;)&lt;/p&gt;*/&#125;</span><br><span class="line">                &#123;/*&lt;ImgCanMove mouse=&#123;this.state&#125; /&gt;*/&#125;</span><br><span class="line">                &#123;this.props.render(this.state)&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此时，<code>&lt;LearnReact /&gt;</code>内部渲染什么内容就通过<code>this.props.render</code>来动态决定了，剩下的只需要在调用时动态给定这个<code>render prop</code>就可以了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 外部使用 render prop</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            // 这里传入一个(mouse) =&gt; (&lt;ImgCanMove mouse=&#123;mouse&#125; /&gt;) 函数来让LearnReact动态渲染ImgCanMove组件</span><br><span class="line">            &lt;LearnReact render=&#123;(mouse) =&gt; (</span><br><span class="line">                &lt;ImgCanMove mouse=&#123;mouse&#125; /&gt;</span><br><span class="line">            )&#125; /&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述就是一个简单使用<code>render prop</code>的例子。可以体会到<strong>render prop 是一个用于告知组件需要渲染什么内容的函数 prop。</strong></p>
<p>另外别误会，任何被用于告知组件需要渲染什么内容的函数<code>prop</code>在技术上都可以被称为<code>“render prop”</code>，即<code>prop</code>的名字不一定非得是<code>render</code></p>
<p>补充一点需要注意的：当在<code>React.PureComponent</code>中使用<code>Render Props</code>时，<strong>浅比较的值永远是<code>false</code></strong>,所以这时候使用<code>React.PureComponent</code>并不能达到效果，官方给出的解决方案有：</p>
<ol>
<li>放弃使用<code>React.PureComponent</code>转为<code>React.Component</code></li>
<li>如果能将传入的<code>prop</code>设定为组件的实例方法的话，是可以解决问题的： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class RenderPropWrapper extends React.PureComponent &#123;</span><br><span class="line">    //  我们将要传入的render prop设置为实例一个方法，</span><br><span class="line">    //  那么在使用时，其指向地址都是一致的，能避免浅比较都为false的情况</span><br><span class="line">    renderTheCat(mouse) &#123;</span><br><span class="line">        return &lt;ImgCanMove mouse=&#123;mouse&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;LearnReact render=&#123;this.renderTheCat&#125; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="props添加默认值defaultProps"><a href="#props添加默认值defaultProps" class="headerlink" title="props添加默认值defaultProps"></a><code>props</code>添加默认值<code>defaultProps</code></h3><p><code>defaultProps</code>可以为<code>Class</code>组件添加默认<code>props</code>。这一般用于<code>props</code>未赋值，但又不能为<code>null</code>的情况:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SubComponent.defaultProps = &#123;</span><br><span class="line">    counter: 0</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>未指定<code>props.counter</code>的时候，会按照当前给定的默认值来取值</p>
<p>如果你正在使用像<code>transform-class-properties</code>的<code>Babel</code>转换工具，你也可以在<code>React</code>组件类中声明<code>defaultProps</code>作为<code>static</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">export default class SubComponent extends React.Component &#123;</span><br><span class="line">    static defaultProps = &#123;</span><br><span class="line">        counter: 0</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;SubComponent&lt;/h2&gt;</span><br><span class="line">                &lt;span&gt;</span><br><span class="line">                    props.counter: &#123;this.props.counter&#125;</span><br><span class="line">                &lt;/span&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用propTypes进行类型检查"><a href="#使用propTypes进行类型检查" class="headerlink" title="使用propTypes进行类型检查"></a>使用<code>propTypes</code>进行类型检查</h3><blockquote>
<p>自<code>React v15.5</code>起，<code>React.PropTypes</code>已移入另一个包中。请使用<code>prop-types</code>库 代替。详情请见<a href="https://zh-hans.reactjs.org/blog/2017/04/07/react-v15.5.0.html#migrating-from-reactproptypes" target="_blank" rel="noopener">博客</a></p>
</blockquote>
<p>详细的用法可以见<a href="https://www.npmjs.com/package/prop-types" target="_blank" rel="noopener">npm usage</a></p>
<details>
    <summary>或者点击查看: prop-types使用举例</summary>

<pre><code>import PropTypes from &apos;prop-types&apos;;
MyComponent.propTypes = {
  // 你可以将属性声明为 JS 原生类型，默认情况下
  // 这些属性都是可选的。
  optionalArray: PropTypes.array,
  optionalBool: PropTypes.bool,
  optionalFunc: PropTypes.func,
  optionalNumber: PropTypes.number,
  optionalObject: PropTypes.object,
  optionalString: PropTypes.string,
  optionalSymbol: PropTypes.symbol,

  // 任何可被渲染的元素（包括数字、字符串、元素或数组）
  // (或 Fragment) 也包含这些类型。
  optionalNode: PropTypes.node,

  // 一个 React 元素。
  optionalElement: PropTypes.element,

  // 一个 React 元素类型（即，MyComponent）。
  optionalElementType: PropTypes.elementType,

  // 你也可以声明 prop 为类的实例，这里使用
  // JS 的 instanceof 操作符。
  optionalMessage: PropTypes.instanceOf(Message),

  // 你可以让你的 prop 只能是特定的值，指定它为
  // 枚举类型。
  optionalEnum: PropTypes.oneOf([&apos;News&apos;, &apos;Photos&apos;]),

  // 一个对象可以是几种类型中的任意一个类型
  optionalUnion: PropTypes.oneOfType([
    PropTypes.string,
    PropTypes.number,
    PropTypes.instanceOf(Message)
  ]),

  // 可以指定一个数组由某一类型的元素组成
  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),

  // 可以指定一个对象由某一类型的值组成
  optionalObjectOf: PropTypes.objectOf(PropTypes.number),

  // 可以指定一个对象由特定的类型值组成
  optionalObjectWithShape: PropTypes.shape({
    color: PropTypes.string,
    fontSize: PropTypes.number
  }),

  // An object with warnings on extra properties
  optionalObjectWithStrictShape: PropTypes.exact({
    name: PropTypes.string,
    quantity: PropTypes.number
  }),   

  // 你可以在任何 PropTypes 属性后面加上 `isRequired` ，确保
  // 这个 prop 没有被提供时，会打印警告信息。
  requiredFunc: PropTypes.func.isRequired,

  // 任意类型的数据
  requiredAny: PropTypes.any.isRequired,

  // 你可以指定一个自定义验证器。它在验证失败时应返回一个 Error 对象。
  // 请不要使用 `console.warn` 或抛出异常，因为这在 `onOfType` 中不会起作用。
  customProp: function(props, propName, componentName) {
    if (!/matchme/.test(props[propName])) {
      return new Error(
        &apos;Invalid prop `&apos; + propName + &apos;` supplied to&apos; +
        &apos; `&apos; + componentName + &apos;`. Validation failed.&apos;
      );
    }
  },

  // 你也可以提供一个自定义的 `arrayOf` 或 `objectOf` 验证器。
  // 它应该在验证失败时返回一个 Error 对象。
  // 验证器将验证数组或对象中的每个值。验证器的前两个参数
  // 第一个是数组或对象本身
  // 第二个是他们当前的键。
  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) {
    if (!/matchme/.test(propValue[key])) {
      return new Error(
        &apos;Invalid prop `&apos; + propFullName + &apos;` supplied to&apos; +
        &apos; `&apos; + componentName + &apos;`. Validation failed.&apos;
      );
    }
  })
};</code></pre></details>

<p>另外可以通过对<code>props.children</code>做类型限制来限制能在本组件中只接收一个元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import Props_Types from &quot;prop-types&quot;;</span><br><span class="line"></span><br><span class="line">export default class SubComponent extends React.Component &#123;</span><br><span class="line">    // static defaultProps = &#123;</span><br><span class="line">    //     counter: 0</span><br><span class="line">    // &#125;;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;SubComponent&lt;/h2&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &#123;this.props.children&#125;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SubComponent.propTypes = &#123;</span><br><span class="line">    children: Props_Types.element.isRequired // </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>将<code>children</code>的类型设为<code>Props_Types.element</code>即可，我们设置了上述的检查后，如果这么使用的话:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;SubComponent&gt;</span><br><span class="line">    &lt;h2&gt;children1&lt;/h2&gt;</span><br><span class="line">    &lt;h3&gt;children2&lt;/h3&gt;</span><br><span class="line">&lt;/SubComponent&gt;</span><br></pre></td></tr></table></figure>

<p>就会看到报错： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed prop type: Invalid prop `children` of type `array` supplied to `SubComponent`, expected a single ReactElement.</span><br></pre></td></tr></table></figure>

<p>此时如果想要允许多个元素传入，可以将类型检查改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SubComponent.propTypes = &#123;</span><br><span class="line">    children: Props_Types.arrayOf(Props_Types.element)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><p>看完了组件的相关概念，来关心一下<code>React</code>中的事件处理</p>
<p><code>React</code>中的事件处理都是驼峰写法: <code>&lt;button onClick={this.clickBtn}&gt;&lt;/button&gt;</code></p>
<p>另外由于没有类似<code>Vue</code>的修饰符，所以对于组织默认行为或者阻止冒泡等需求，需要手动去调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">clickBtn = (e) =&gt; &#123;</span><br><span class="line">    e.preventDefault(); // 在这里手动调用</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">    this.setState((state) =&gt; (&#123;</span><br><span class="line">        counter: state.counter + 1</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick=&#123;this.clickBtn&#125;&gt;</span><br><span class="line">                click to add counter</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>事件处理函数中的<code>e</code>是一个<code>React</code>自己合成的事件对象，具体文档见 <a href="https://zh-hans.reactjs.org/docs/events.html" target="_blank" rel="noopener">SyntheticEvent</a></p>
</blockquote>
<h2 id="React事件处理函数中的this"><a href="#React事件处理函数中的this" class="headerlink" title="React事件处理函数中的this"></a>React事件处理函数中的<code>this</code></h2><p>需要注意的是，<code>JSX</code>回调函数中的<code>this</code>, 如果你忘记绑定<code>this.handleClick</code>并把它传入了 <code>onClick</code>，当你调用这个函数的时候<code>this</code>的值为<code>undefined</code>而非当前组件实例。</p>
<p>分析一下原因，为什么调用的事件处理函数中的<code>this</code>是<code>undefined</code>?</p>
<p>先来看一个<code>JS</code>的小例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class TestThis &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.attr = &quot;aaa&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    consoleAttr() &#123;</span><br><span class="line">        console.log(this.attr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const test = new TestThis();</span><br><span class="line">test.consoleAttr();// aaa</span><br><span class="line">let tempMethod = test.consoleAttr;</span><br><span class="line">tempMethod.bind(test)(); // aaa 硬性绑定到当前实例即可获得this</span><br><span class="line">tempMethod(); // Cannot read property &apos;attr&apos; of undefined 即 this 为undefined</span><br></pre></td></tr></table></figure>

<p>上述例子中将内部的方法重新赋值再次调用之后<code>this</code>指向就改变了。</p>
<p>明白上面例子后，再来了解一下<code>JSX</code>中传递的是什么东西: </p>
<blockquote>
<p>With JSX you pass a function as the event handler, rather than a string.</p>
</blockquote>
<p>官方文档说的很清楚，传递的是一个<code>function</code>，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick=&#123;this.clickBtn&#125;&gt;</span><br><span class="line">                click to add counter</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">// 在这里的&lt;button onClick=&#123;this.clickBtn&#125;&gt;其实就等价于:</span><br><span class="line">render() &#123;</span><br><span class="line">    const tempClickBtn = this.clickBtn;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick=&#123;tempClickBtn&#125;&gt;</span><br><span class="line">                click to add counter</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以造成了这种你在事件处理函数中得到的<code>this</code>其实是<code>undefined</code>的情况</p>
<p>那么为了避免这种情况，一般采用三种方法:</p>
<ol>
<li><p>在<code>constructor</code>中将每一个事件处理函数手动绑定到当前实例(真的不推荐，太麻烦)</p>
</li>
<li><p>使用<code>public class fields</code>语法直接声明事件处理函数即可:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clickBtn = (e) =&gt; &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在回调中使用箭头函数:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">clickBtn(e) &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick=&#123;(e) =&gt; this.clickBtn(e)&#125;&gt;</span><br><span class="line">                click to add counter</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="事件处理函数的参数"><a href="#事件处理函数的参数" class="headerlink" title="事件处理函数的参数"></a>事件处理函数的参数</h3><p>如果要想给事件处理方法传递更多参数时，只能通过：</p>
<ol>
<li><p>回调函数的写法:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">clickBtn(info, e) &#123;</span><br><span class="line">    console.log(info);</span><br><span class="line">    console.log(e);</span><br><span class="line">&#125;;</span><br><span class="line">&lt;!--回调函数的 e 必须显式的传递给事件处理方法 --&gt;</span><br><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick=&#123;(e) =&gt; this.clickBtn(&quot;123&quot;, e)&#125;&gt;</span><br><span class="line">                click to add counter</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>bind的写法:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">clickBtn(info, e) &#123;</span><br><span class="line">    console.log(info);</span><br><span class="line">    console.log(e);</span><br><span class="line">&#125;;</span><br><span class="line">// bind的写法不需要显式的传递 e</span><br><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick=&#123;this.clickBtn.bind(this, &quot;123&quot;)&#125;&gt;</span><br><span class="line">                click to add counter</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="React中的条件渲染"><a href="#React中的条件渲染" class="headerlink" title="React中的条件渲染"></a>React中的条件渲染</h1><p><code>React</code>中的条件渲染都是通过<code>if</code>或者<code>条件运算符</code>进行控制的。</p>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">export default class LearnReact extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            isShow: true</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        if(this.state.isShow) &#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;div&gt;isShow = true&lt;/div&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;isShow = false&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述例子就通过了<code>state.isShow</code>来控制不同的元素进行渲染</p>
<p>此外你还可以通过变量来储存元素，这对于大段的内容来说，可以进行局部的修改:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">export default class LearnReact extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            isShow: true</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    toggleIsShow = () =&gt; &#123;</span><br><span class="line">        this.setState((state) =&gt; &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                isShow: !state.isShow</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    render() &#123;</span><br><span class="line">        let element;</span><br><span class="line">        if(this.state.isShow) &#123;</span><br><span class="line">            element = &lt;div&gt;isShow = true&lt;/div&gt;;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            element = &lt;div&gt;isShow = false&lt;/div&gt;;</span><br><span class="line">        &#125;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;element&#125;</span><br><span class="line">                &lt;button onClick=&#123;this.toggleIsShow&#125;&gt;</span><br><span class="line">                    Click to toggle isShow</span><br><span class="line">                &lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述例子就是在通过变量来控制局部渲染的例子。</p>
<p>另外还可以通过<code>&amp;&amp;</code>或者三目运算符等来进行控制渲染,比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let element;</span><br><span class="line">if(this.state.isShow) &#123;</span><br><span class="line">    element = &lt;div&gt;isShow = true&lt;/div&gt;;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    element = &lt;div&gt;isShow = false&lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以简化为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let element = this.state.isShow ? &lt;div&gt;isShow = true&lt;/div&gt; : &lt;div&gt;isShow = false&lt;/div&gt;;</span><br></pre></td></tr></table></figure>

<p>这些<code>JS</code>的常规操作都可以在<code>JSX</code>中进行。</p>
<p>另外值得一提的是，可以在<code>render</code>函数中<code>return null</code>来隐藏组件组织组件渲染，且<strong>该组件的生命周期钩子依旧会被调用</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">export default class SubComponent extends React.Component &#123;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        console.log(&quot;SubComponent Mounted&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        if(!this.props.isShow) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;SubComponent&lt;/h2&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="React中的列表渲染"><a href="#React中的列表渲染" class="headerlink" title="React中的列表渲染"></a>React中的列表渲染</h1><p>进行列表渲染，首先需要给每一个渲染项一个<code>key</code>属性，且这个<code>key</code>属性只有放在就近的数组上下文中才有意义。</p>
<p>具体列表渲染的方式很简单，主要是通过<code>map</code>方法直接返回一个元素数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">export default class LearnReact extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            nameList: [&quot;Yang&quot;, &quot;Zhang&quot;, &quot;Wang&quot;]</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        const nameElements = this.state.nameList.map((e, i) =&gt; &#123;</span><br><span class="line">            return &lt;li key=&#123;i&#125;&gt;&#123;e&#125;&lt;/li&gt;;</span><br><span class="line">        &#125;);</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &#123;nameElements&#125;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于组件也是一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    const SubComponentList = this.state.nameList.map((e, i) =&gt; &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;SubComponent</span><br><span class="line">                key=&#123;i&#125; </span><br><span class="line">                name=&#123;e&#125;</span><br><span class="line">            &gt;&#123;e&#125;&lt;/SubComponent&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;);</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &#123;SubComponentList&#125;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以嵌入在<code>JSX</code>里，但是要注意可读性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                this.state.nameList.map((e, i) =&gt; &#123;</span><br><span class="line">                    return (</span><br><span class="line">                        &lt;SubComponent</span><br><span class="line">                            key=&#123;i&#125;</span><br><span class="line">                            name=&#123;e&#125;</span><br><span class="line">                        &gt;&#123;e&#125;&lt;/SubComponent&gt;</span><br><span class="line">                    );</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="React中的Form"><a href="#React中的Form" class="headerlink" title="React中的Form"></a>React中的Form</h1><blockquote>
<p>扩展阅读: <a href="https://goshakkk.name/on-forms-react/" target="_blank" rel="noopener">What you need to know about forms in React</a></p>
</blockquote>
<p>由于表单元素会有一些内部的<code>state</code>，所以<code>React</code>中对于<code>Form</code>分成了<strong>受控表单</strong>和<strong>非受控表单</strong>两类。</p>
<p><strong>当一个表单有一个<code>value</code>作为<code>prop</code>时，它就成为了一个受控组件（当然<code>checkbox</code>和<code>radio</code>对应的<code>prop</code>是<code>checked</code>）</strong></p>
<h2 id="受控表单"><a href="#受控表单" class="headerlink" title="受控表单"></a>受控表单</h2><p>对于受控表单，给定一个<code>value</code>作为<code>prop</code>，这个<code>value</code>应当为组件内部的<code>state</code>,然后监听其内部值发生变化时进行修改<code>setState()</code>:</p>
<p>拿最简单的<code>&lt;input type=&quot;text&quot; /&gt;</code>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">export default class LearnReact extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            val: &quot;&quot;,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    handleChange = (e) =&gt; &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            val: e.target.value.toUpperCase()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;input type=&quot;text&quot; value=&#123;this.state.val&#125; onChange=&#123;this.handleChange&#125;/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述例子对于<code>input</code>输入做了处理，每次值变化更新<code>state</code>且转换为大写，这就是受控组件的通常用法。</p>
<p>对于<code>&lt;input type=&quot;text&quot;&gt;</code>,<code>&lt;textarea&gt;</code> 和<code>&lt;select&gt;</code> 之类的标签传入的<code>prop</code>都为<code>value</code></p>
<p>而对于<code>&lt;input type=&quot;checkbox&quot; /&gt;</code>和 <code>&lt;input type=&quot;radio&quot; /&gt;</code>则为<code>checked</code></p>
<h3 id="处理不同的受控表单的输入"><a href="#处理不同的受控表单的输入" class="headerlink" title="处理不同的受控表单的输入"></a>处理不同的受控表单的输入</h3><p>当一个组件中拥有多个受控表单的时候，需要在同一函数中对其值做处理，这时有2种情况：</p>
<ol>
<li><p>表单类型互不相同，比如说有<code>&lt;input type=&quot;text&quot;&gt;</code> <code>&lt;input type=&quot;checkbox&quot; /&gt;</code> 和<code>&lt;select&gt;</code>等：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">export default class LearnReact extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            val: &quot;&quot;,</span><br><span class="line">            selectedVal: [],</span><br><span class="line">            checked: false</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleChange = (e) =&gt; &#123;</span><br><span class="line">        console.log(e.target.type);</span><br><span class="line">        let stateKey;</span><br><span class="line">        let propKey;</span><br><span class="line">        switch (e.target.type) &#123;</span><br><span class="line">            case &quot;text&quot;: &#123;</span><br><span class="line">                stateKey = &quot;val&quot;;</span><br><span class="line">                propKey = &quot;value&quot;;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case &quot;checkbox&quot;: &#123;</span><br><span class="line">                stateKey = &quot;checked&quot;;</span><br><span class="line">                propKey = &quot;checked&quot;;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case &quot;select-one&quot;: &#123;</span><br><span class="line">                stateKey = &quot;selectedVal&quot;;</span><br><span class="line">                propKey = &quot;value&quot;;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case &quot;select-multiple&quot;: &#123;</span><br><span class="line">                stateKey = &quot;selectedVal&quot;;</span><br><span class="line">                propKey = &quot;value&quot;;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">             [stateKey]: e.target[propKey]</span><br><span class="line">        &#125;,() =&gt; &#123;</span><br><span class="line">            console.log(this.state);</span><br><span class="line">        &#125;)</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     render() &#123;</span><br><span class="line">          return (</span><br><span class="line">              &lt;div&gt;</span><br><span class="line">                  &lt;input type=&quot;text&quot; value=&#123;this.state.val&#125; onChange=&#123;this.handleChange&#125;/&gt;</span><br><span class="line">                  &lt;br/&gt;</span><br><span class="line">                  &lt;input type=&quot;checkbox&quot; checked=&#123;this.state.checked&#125; onChange=&#123;this.handleChange&#125;/&gt;</span><br><span class="line">                  &lt;br/&gt;</span><br><span class="line">                  &lt;select value=&#123;this.state.selectedVal&#125; onChange=&#123;this.handleChange&#125; multiple=&#123;true&#125;&gt;</span><br><span class="line">                      &lt;option value=&quot;grapefruit&quot;&gt;葡萄柚&lt;/option&gt;</span><br><span class="line">                      &lt;option value=&quot;lime&quot;&gt;酸橙&lt;/option&gt;</span><br><span class="line">                      &lt;option value=&quot;coconut&quot;&gt;椰子&lt;/option&gt;</span><br><span class="line">                      &lt;option value=&quot;mango&quot;&gt;芒果&lt;/option&gt;</span><br><span class="line">                  &lt;/select&gt;</span><br><span class="line">              &lt;/div&gt;</span><br><span class="line">          )</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 对于不同类型的表单，可以直接使用<code>e.target.type</code>来进行判断是哪一个表单发生了改变，从而进行获取<code>e.target.value/checked</code>,需要注意的是,<code>select</code>对应的<code>type</code>为<code>select-one</code>或者<code>select-multiple</code>，视是否为<code>multipie</code>而定</p>
</li>
<li><p>存在相同类型的表单，比如说存在2个<code>&lt;input type=&quot;text&quot;&gt;</code></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">export default class LearnReact extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            firstInput: &quot;&quot;,</span><br><span class="line">            lastInput: &quot;&quot;,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleChange = (e) =&gt; &#123;</span><br><span class="line">        console.log(e.target.name);</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            [e.target.name]: e.target.value</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;input type=&quot;text&quot; name=&quot;firstInput&quot; value=&#123;this.state.firstInput&#125; onChange=&#123;this.handleChange&#125;/&gt;</span><br><span class="line">                &lt;br/&gt;</span><br><span class="line">                &lt;input type=&quot;text&quot; name=&quot;lastInput&quot; value=&#123;this.state.lastInput&#125; onChange=&#123;this.handleChange&#125;/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 而对于有相同类型的表单的话，能做的只有给每个表单一个<code>name</code>然后根据<code>e.target.name</code>去进行判断是哪个表单触发了处理函数</p>
</li>
</ol>
<h2 id="非受控表单"><a href="#非受控表单" class="headerlink" title="非受控表单"></a>非受控表单</h2><p>官方是一直推荐使用受控表单的，因为每次值变化都能检测到，可以做很多的自定义操作。但是受控表单书写逻辑比较麻烦，一个受控表单就要对应一个<code>state</code>值和一个相应的处理方法。</p>
<p>如果你的表单足够简单的话，也可以使用非受控表单，通常非受控表单的处理方式为：</p>
<ol>
<li>给定目标表单一个<code>ref</code></li>
<li>在需要用值的时候通过<code>ref</code>去取到值，比如说进行提交的时候，而在这期间的对于内部值的变化是不感知的</li>
</ol>
<p>来看一个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">export default class LearnReact extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            inputVal: &quot;&quot;,</span><br><span class="line">        &#125;;</span><br><span class="line">        this.inputRef = React.createRef();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getValFromInput = () =&gt; &#123;</span><br><span class="line">        console.log(this.inputRef.current.value);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;input type=&quot;text&quot; ref=&#123;this.inputRef&#125;/&gt;</span><br><span class="line">                &lt;br/&gt;</span><br><span class="line">                &lt;button onClick=&#123;this.getValFromInput&#125;&gt;click to get InputVal&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例展示了非受控表单的基本使用，跟受控表单不同的是，取值的函数只有在想要获得值的时候才调用，而受控表单则是表单每次输入时就自动调用一次。</p>
<p>另外，因为没有传入<code>value</code>作为<code>prop</code>， 非受控表单的默认值不能像受控表单那样简单的把<code>state</code>中对应的值置空即可，而是需要一个<code>defaultValue</code>属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">      defaultValue=&quot;Bob&quot;</span><br><span class="line">      type=&quot;text&quot;</span><br><span class="line">      ref=&#123;this.input&#125; /&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于<code>checkbox</code>和<code>radio</code>对应的属性为<code>defaultChecked</code></p>
</blockquote>
<h2 id="lt-input-type-quot-file-quot-gt-文件上传表单"><a href="#lt-input-type-quot-file-quot-gt-文件上传表单" class="headerlink" title="&lt;input type=&quot;file&quot;&gt;文件上传表单"></a><code>&lt;input type=&quot;file&quot;&gt;</code>文件上传表单</h2><p>由于其的<code>value</code>属性只读，所以<code>React</code>也没办法将其变为受控表单，所以<strong>所有的<code>&lt;input type=&quot;file&quot;&gt;</code>都为非受控表单</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">export default class LearnReact extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.fileInput = React.createRef();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    handleSubmit = (event) =&gt; &#123;</span><br><span class="line">        event.preventDefault();</span><br><span class="line">        console.log(this.fileInput.current.files[0]);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">                &lt;label&gt;</span><br><span class="line">                    Upload file:</span><br><span class="line">                    &lt;input type=&quot;file&quot; ref=&#123;this.fileInput&#125; /&gt;</span><br><span class="line">                &lt;/label&gt;</span><br><span class="line">                &lt;br /&gt;</span><br><span class="line">                &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;</span><br><span class="line">            &lt;/form&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="受控组件vs非受控组件"><a href="#受控组件vs非受控组件" class="headerlink" title="受控组件vs非受控组件"></a>受控组件vs非受控组件</h2><p>推荐阅读：<a href="https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/" target="_blank" rel="noopener">controlled-vs-uncontrolled-inputs-react</a></p>
<p>如果你使用的表单比较简单，也没有什么实时校验合法性的需求的话，就可以使用非受控表单，其他的，建议还是都使用受控表单</p>
<h1 id="React中的Ref"><a href="#React中的Ref" class="headerlink" title="React中的Ref"></a>React中的Ref</h1><p>不进行赘述<code>Ref</code>的概念，简单介绍一下<code>Ref</code>的使用.</p>
<h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><p>目前简单使用<code>Ref</code>的方式有2种:</p>
<ol>
<li>通过<code>React.createRef()</code>(<code>React16.3</code>及以上)</li>
<li>较早版本使用回调形式的<code>refs</code></li>
<li><code>String</code>类型的<code>Refs</code>(过时，不推荐使用，在此也不做介绍)</li>
</ol>
<h3 id="React-createRef"><a href="#React-createRef" class="headerlink" title="React.createRef()"></a><code>React.createRef()</code></h3><p>首先声明<strong>不能在函数式组件上使用<code>ref</code></strong>,因为其并没有组件实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export default class LearnReact extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.inputRef = React.createRef();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;input type=&quot;text&quot; ref=&#123;this.inputRef&#125;/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述就是一个通过<code>React.createRef()</code>创建<code>ref</code>的例子，创建好之后我们可以通过<code>this.inputRef.current</code>来获取元素：</p>
<ol>
<li>对于原生<code>HTML</code>元素，<code>current</code>为其底层 DOM 元素</li>
<li>对于<code>Class类的组件</code>, <code>current</code>为当前组件实例</li>
</ol>
<p>给原生<code>DOM</code>元素添加<code>Ref</code>的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">export default class LearnReact extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.inputRef = React.createRef();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clickBtn = () =&gt; &#123;</span><br><span class="line">        this.inputRef.current.focus(); // 原生的html元素  底层DOM为current</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;input type=&quot;text&quot; ref=&#123;this.inputRef&#125;/&gt;</span><br><span class="line">                &lt;br/&gt;</span><br><span class="line">                &lt;button onClick=&#123;this.clickBtn&#125;&gt;Click me !&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给<code>Class Component</code>添加<code>ref</code>的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">export default class LearnReact extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.subComponentRef = React.createRef();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clickBtn = () =&gt; &#123;</span><br><span class="line">        this.subComponentRef.current.ConsoleMsgFromSub(); // 输出: this is msg from subComponent</span><br><span class="line">        // ClassComponent current为组件实例</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;SubComponent ref=&#123;this.subComponentRef&#125; /&gt;</span><br><span class="line">                &lt;br/&gt;</span><br><span class="line">                &lt;button onClick=&#123;this.clickBtn&#125;&gt;Click me !&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SubComponent </span><br><span class="line">export default class SubComponent extends React.Component &#123;</span><br><span class="line">    ConsoleMsgFromSub() &#123;</span><br><span class="line">        console.log(&quot;this is msg from subComponent&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;subComponent&lt;/h1&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是对于函数式组件，并不能直接使用<code>ref</code>,但是可以在函数组件内部使用<code>ref</code>属性，只要它指向一个<code>DOM</code>元素或<code>class</code>组件</p>
<h3 id="回调Refs"><a href="#回调Refs" class="headerlink" title="回调Refs"></a>回调Refs</h3><p>如果当前版本不支持<code>React.createRef</code>的话，可以使用回调<code>Refs</code>的方式，来介绍下基本使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">export default class LearnReact extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.inputRef = null;</span><br><span class="line">        this.setInputRef = (element) =&gt; &#123; // 回调ref中，该属性会传递一个函数</span><br><span class="line">            // 该函数接受 React 组件实例或 HTML DOM 元素作为参数，以使它们能在其他地方被存储和访问</span><br><span class="line">            this.inputRef = element; // element即为 React 组件实例或 HTML DOM 元素 将其赋给想使用变量存储起来便于访问</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        this.inputRef.focus(); // 回调ref不需要current</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;/*在这里要传入目标回调*/&#125;</span><br><span class="line">                &lt;input type=&quot;text&quot; ref=&#123;this.setInputRef&#125;/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>React</code>将在组件挂载时，会调用<code>ref</code>回调函数并传入<code>DOM</code>元素，当<strong>卸载时调用它并传入<code>null</code></strong>。</p>
<blockquote>
<p>在<code>componentDidMount</code>或<code>componentDidUpdate</code>触发前，<code>React</code>会保证<code>refs</code><strong>一定是最新的</strong>。</p>
</blockquote>
<h2 id="Refs转发"><a href="#Refs转发" class="headerlink" title="Refs转发"></a>Refs转发</h2><p><code>Ref</code>转发指的是将<code>ref</code>自动地通过组件传递到其一子组件.</p>
<p>即在父组件中拿到子组件中的元素的<code>ref</code>,一般应用场景较少。</p>
<p>一般实现<code>Refs</code>转发的方式有：</p>
<ol>
<li>一般对于新版本(16.3及以上)，可以使用<code>React.forwardRef()</code></li>
<li>旧版本的话，一般使用将<code>ref</code>作为一个特殊的<code>prop</code>传入子组件，具体见: <a href="https://gist.github.com/gaearon/1a018a023347fe1c2476073330cc5509" target="_blank" rel="noopener">dom_ref_forwarding_alternatives_before_16.3</a></li>
</ol>
<p>使用<code>React.forwardRef()</code>定义一个函数式组件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">export default React.forwardRef((props, ref) =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button ref=&#123;ref&#125;&gt;forwardRef&apos;s Button&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在父组件中调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">export default class LearnReact extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.subRef = React.createRef();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        console.log(this.subRef.current); // 获取到的即为ForwardComponent中的那个button</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;ForwardComponent ref=&#123;this.subRef&#125; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只有在<code>React.forwardRef</code>定义的函数式组件中才存在第二个参数<code>ref</code>。常规函数和<code>class</code>组件不接收<code>ref</code>参数，且 <code>props</code>中也不存在<code>ref</code>。</p>
</blockquote>
<p>使用特殊<code>prop</code>转发<code>ref</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">export default class LearnReact extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.subRef = React.createRef();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        console.log(this.subRef);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;/*传入一个特殊的props*/&#125;</span><br><span class="line">                &lt;SubComponent specialPropToPassRef=&#123;this.subRef&#125; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SubComponent</span><br><span class="line">export default class SubComponent extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1 ref=&#123;this.props.specialPropToPassRef&#125;&gt;SubComponent&lt;/h1&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="React中的高阶组件HOC-High-Order-Component"><a href="#React中的高阶组件HOC-High-Order-Component" class="headerlink" title="React中的高阶组件HOC(High Order Component)"></a>React中的高阶组件HOC(High Order Component)</h1><p>高阶组件本质上其实就是一个函数，其<strong>参数为组件，返回值为新组件</strong>。</p>
<p>其应用场景一般都是对当前目标组件做一些修饰或者代替<code>mixin</code>进行组合亦或是提取相似重复逻辑。</p>
<p>首要原则是： <code>HOC</code><strong>不能修改传入的组件，也不会使用继承来复制其行为</strong>, 而是应该通过将组件包装在容器组件中来组成<strong>新组件</strong>。<code>HOC</code>是纯函数，没有副作用。</p>
<p>来看一个简单的例子使用</p>
<p>现有如下目标子组件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export default class SubComponent extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    this.props.list.map((e, i) =&gt; &#123;</span><br><span class="line">                        return &lt;div key=&#123;i&#125;&gt;line &#123;e&#125;&lt;/div&gt;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在给这个子组件设计一个修饰其的<code>HOC</code>: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const TestHocFunc = (targetComponent, componentData) =&gt; &#123;</span><br><span class="line">    class SubComponentWithDescription extends React.Component &#123;</span><br><span class="line">        constructor(props) &#123;</span><br><span class="line">            super(props);</span><br><span class="line">            this.state = &#123;</span><br><span class="line">                data: componentData</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;h1&gt;SubComponentWithDescription&lt;/h1&gt;</span><br><span class="line">                    &#123;/*这里将props全部透传给目标子组件*/&#125;</span><br><span class="line">                    &lt;SubComponent list=&#123;this.state.data&#125; &#123;...this.props&#125; /&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return SubComponentWithDescription;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述<code>HOC</code>添加了一下额外的<code>DOM</code>结构，也将其不需要的<code>props</code>都透传给了<code>SubComponent</code>，同时另外传入了目标<code>props</code>，且没有涉及到修改<code>SubComponent</code>的内部结构。<br>然后就可以在父组件中进行使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">export default class LearnReact extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            renderList: [1,2,3]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        const SubComponentWithDescription = TestHocFunc(SubComponent, this.state.renderList); // 参数为组件，返回值为新组件</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;SubComponentWithDescription /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即可看到修饰后的<code>SubComponent</code></p>
<p>上述是一个<code>HOC</code>的简单使用。</p>
<p>在使用<code>HOC</code>的时候，还有一些注意点:</p>
<ul>
<li><p>对于本身用不到的<code>props</code>,应该将其悉数透传给目标子组件:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  // 过滤掉非此 HOC 额外的 props，且不要进行透传</span><br><span class="line">  const &#123; extraProp, ...passThroughProps &#125; = this.props;</span><br><span class="line"></span><br><span class="line">  // 将 props 注入到被包装的组件中。</span><br><span class="line">  // 通常为 state 的值或者实例方法。</span><br><span class="line">  const injectedProp = someStateOrInstanceMethod;</span><br><span class="line"></span><br><span class="line">  // 将 props 传递给被包装组件</span><br><span class="line">  return (</span><br><span class="line">    &lt;WrappedComponent</span><br><span class="line">      injectedProp=&#123;injectedProp&#125;</span><br><span class="line">      &#123;...passThroughProps&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>给定包装函数的<code>displayName</code>以便使用<code>React Developer Tools</code>进行调试：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function TestHocFunc(targetComponent, componentData) &#123;</span><br><span class="line">    TestHocFunc.displayName = &quot;DeeJay&apos;s Test Hoc Function&quot;;</span><br><span class="line">    return class extends React.Component &#123;</span><br><span class="line">        // balabala</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要在<code>render</code>方法中使用<code>HOC</code>:</p>
<p>  由于<code>render()</code>会通过判断当前返回的组件和上一个渲染的组件是不是相同（通过<code>===</code>判断）来进行更新现有子组件还是将其丢弃并挂载新子组件，所以在<code>render</code>方法中使用<code>HOC</code>会造成一个后果就是，<code>render()</code>判断的结果总是<code>false</code>即总是会重新渲染（即卸载当前再重新加载）整个组件，这不仅仅是<strong>性能问题</strong> 且重新挂载组件会导致<strong>该组件及其所有子组件的状态丢失</strong>。</p>
</li>
<li><p>使用<code>HOC</code>时，对目标子组件上的<strong>静态方法</strong>要做拷贝</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class SubComponent extends React.Component &#123;</span><br><span class="line">    static staticMethod() &#123; /* doSth */ &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">// 静态方法也可以写为</span><br><span class="line">// SubComponent.staticMethod = function () &#123;/* doSth */&#125;</span><br><span class="line"></span><br><span class="line">const SubComponentWithDesc = HOCFunc(SubComponent);</span><br><span class="line"></span><br><span class="line">console.log(SubComponentWithDesc.staticMethod === undefined); // true</span><br></pre></td></tr></table></figure>

<p>  对于上例来说，加过修饰的组件<code>SubComponentWithDesc</code>中并不存在原本组件的静态方法。对于这种情况，必须要做拷贝：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const SubComponentWithDesc = HOCFunc(SubComponent);</span><br><span class="line">SubComponentWithDesc.staticMethod = SubComponent.staticMethod; // 手动进行拷贝</span><br></pre></td></tr></table></figure>

<p>  这种情况适用于知道哪些方法需要拷贝，如果不知道的话可以使用<a href="https://github.com/mridgway/hoist-non-react-statics" target="_blank" rel="noopener">hoist-non-react-statics</a>这个库：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import hoistNonReactStatic from &apos;hoist-non-react-statics&apos;;</span><br><span class="line">const SubComponentWithDesc = HOCFunc(SubComponent);</span><br><span class="line">hoistNonReactStatic(SubComponentWithDesc, SubComponent);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>值得一提的是，<code>Refs</code>不会被传递,因为其跟<code>props</code>原理不同，<code>React</code>会去专门处理<code>refs</code>， 如果将<code>ref</code>添加到<code>HOC</code>的返回组件中，则<code>ref</code>引用指向容器组件，而不是被包装组件。如果想要使其指向原始被包装组件，可以参考<code>refs 转发</code></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">DeeJay</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://deejay0921.github.io/2019/11/26/React的基本使用/">https://deejay0921.github.io/2019/11/26/React的基本使用/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://deejay0921.github.io">DeeJay's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/前端/">前端    </a><a class="post-meta__tags" href="/tags/React/">React    </a></div><div class="post_share"><div class="social-share" data-image="https://blog.dashlane.com/wp-content/uploads/2016/02/react-logo-2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/12/09/React Hooks的基本介绍/"><img class="prev_cover lazyload" data-src="https://showmethecode.com.br/images/posts/react-hooks/banner.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>React Hooks的基本介绍</span></div></a></div><div class="next-post pull_right"><a href="/2019/11/19/Vue后端渲染之Nuxt.js/"><img class="next_cover lazyload" data-src="https://moriohcdn.b-cdn.net/521f533697.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Vue后端渲染之Nuxt.js</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/12/09/React Hooks的基本介绍/" title="React Hooks的基本介绍"><img class="relatedPosts_cover lazyload" data-src="https://showmethecode.com.br/images/posts/react-hooks/banner.png"><div class="relatedPosts_title">React Hooks的基本介绍</div></a></div><div class="relatedPosts_item"><a href="/2019/11/07/TypeScript中的声明文件/" title="TypeScript中的声明文件"><img class="relatedPosts_cover lazyload" data-src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2018/08/typescriptfeature.png"><div class="relatedPosts_title">TypeScript中的声明文件</div></a></div><div class="relatedPosts_item"><a href="/2017/08/06/CSS-垂直居中的几种实现思路方法/" title="CSS-垂直居中的几种实现思路方法"><img class="relatedPosts_cover lazyload" data-src="https://content.linkedin.com/content/dam/me/learning/blog/2016/september/CSS.jpg"><div class="relatedPosts_title">CSS-垂直居中的几种实现思路方法</div></a></div><div class="relatedPosts_item"><a href="/2017/08/04/CSS-3-Flex布局/" title="CSS-3-Flex布局"><img class="relatedPosts_cover lazyload" data-src="https://blog.paradisetechsoft.com/content/images/size/w2000/2019/08/CSS-FLEX-BLOG-BANNER-IMAGE.png"><div class="relatedPosts_title">CSS-3-Flex布局</div></a></div><div class="relatedPosts_item"><a href="/2017/08/01/CSS居中/" title="CSS居中"><img class="relatedPosts_cover lazyload" data-src="https://content.linkedin.com/content/dam/me/learning/blog/2016/september/CSS.jpg"><div class="relatedPosts_title">CSS居中</div></a></div><div class="relatedPosts_item"><a href="/2017/07/30/CSS基础/" title="CSS基础"><img class="relatedPosts_cover lazyload" data-src="https://content.linkedin.com/content/dam/me/learning/blog/2016/september/CSS.jpg"><div class="relatedPosts_title">CSS基础</div></a></div></div><div class="clear_both"></div></div></div></div><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2019 By DeeJay</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script></body></html>