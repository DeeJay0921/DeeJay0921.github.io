<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>React的基本使用 | DeeJay's Blog</title><meta name="description" content="React的基本使用"><meta name="keywords" content="前端,React"><meta name="author" content="DeeJay"><meta name="copyright" content="DeeJay"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="React的基本使用"><meta name="twitter:description" content="React的基本使用"><meta name="twitter:image" content="https://blog.dashlane.com/wp-content/uploads/2016/02/react-logo-2.png"><meta property="og:type" content="article"><meta property="og:title" content="React的基本使用"><meta property="og:url" content="https://deejay0921.github.io/2019/11/26/React的基本使用/"><meta property="og:site_name" content="DeeJay's Blog"><meta property="og:description" content="React的基本使用"><meta property="og:image" content="https://blog.dashlane.com/wp-content/uploads/2016/02/react-logo-2.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://deejay0921.github.io/2019/11/26/React的基本使用/"><link rel="next" title="Vue后端渲染之Nuxt.js" href="https://deejay0921.github.io/2019/11/19/Vue后端渲染之Nuxt.js/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'false',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'false',
  Snackbar: undefined
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">DeeJay's Blog</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="https://avatars1.githubusercontent.com/u/20784273?s=400&amp;u=ba38b4835b7e3c4960763bc6dce9abb320c43f05&amp;v=4" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">152</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">99</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">7</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#JSX"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">JSX</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#元素渲染"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">元素渲染</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#组件"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">组件</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#state"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">state</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#setState-updater-callback"><span class="toc_mobile_items-number">3.1.1.</span> <span class="toc_mobile_items-text">setState(updater[, callback])</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#组件生命周期"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">组件生命周期</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#render"><span class="toc_mobile_items-number">3.2.1.</span> <span class="toc_mobile_items-text">render()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#constructor-NaN"><span class="toc_mobile_items-number">3.2.2.</span> <span class="toc_mobile_items-text">constructor()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#componentDidMount"><span class="toc_mobile_items-number">3.2.3.</span> <span class="toc_mobile_items-text">componentDidMount()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#componentDidUpdate-prevProps-prevState-snapshot"><span class="toc_mobile_items-number">3.2.4.</span> <span class="toc_mobile_items-text">componentDidUpdate(prevProps, prevState, snapshot)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#componentWillUnmount"><span class="toc_mobile_items-number">3.2.5.</span> <span class="toc_mobile_items-text">componentWillUnmount()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#shouldComponentUpdate-nextProps-nextState"><span class="toc_mobile_items-number">3.2.6.</span> <span class="toc_mobile_items-text">shouldComponentUpdate(nextProps, nextState)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#static-getDerivedStateFromProps-props-state"><span class="toc_mobile_items-number">3.2.7.</span> <span class="toc_mobile_items-text">static getDerivedStateFromProps(props, state)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#getSnapshotBeforeUpdate-prevProps-prevState"><span class="toc_mobile_items-number">3.2.8.</span> <span class="toc_mobile_items-text">getSnapshotBeforeUpdate(prevProps, prevState)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#定义错误边界组件"><span class="toc_mobile_items-number">3.2.9.</span> <span class="toc_mobile_items-text">定义错误边界组件</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#static-getDerivedStateFromError-error"><span class="toc_mobile_items-number">3.2.10.</span> <span class="toc_mobile_items-text">static getDerivedStateFromError(error)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#componentDidCatch-error-info"><span class="toc_mobile_items-number">3.2.11.</span> <span class="toc_mobile_items-text">componentDidCatch(error, info)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#废弃的一些钩子"><span class="toc_mobile_items-number">3.2.12.</span> <span class="toc_mobile_items-text">废弃的一些钩子</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#component-forceUpdate-callback"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">component.forceUpdate(callback)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#props"><span class="toc_mobile_items-number">3.4.</span> <span class="toc_mobile_items-text">props</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#props-children"><span class="toc_mobile_items-number">3.4.1.</span> <span class="toc_mobile_items-text">props.children</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Render-Props"><span class="toc_mobile_items-number">3.4.2.</span> <span class="toc_mobile_items-text">Render Props</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#props添加默认值defaultProps"><span class="toc_mobile_items-number">3.4.3.</span> <span class="toc_mobile_items-text">props添加默认值defaultProps</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#使用propTypes进行类型检查"><span class="toc_mobile_items-number">3.4.4.</span> <span class="toc_mobile_items-text">使用propTypes进行类型检查</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#事件处理"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">事件处理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#React事件处理函数中的this"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">React事件处理函数中的this</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#事件处理函数的参数"><span class="toc_mobile_items-number">4.1.1.</span> <span class="toc_mobile_items-text">事件处理函数的参数</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#React中的条件渲染"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">React中的条件渲染</span></a></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JSX"><span class="toc-number">1.</span> <span class="toc-text">JSX</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#元素渲染"><span class="toc-number">2.</span> <span class="toc-text">元素渲染</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#组件"><span class="toc-number">3.</span> <span class="toc-text">组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#state"><span class="toc-number">3.1.</span> <span class="toc-text">state</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#setState-updater-callback"><span class="toc-number">3.1.1.</span> <span class="toc-text">setState(updater[, callback])</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组件生命周期"><span class="toc-number">3.2.</span> <span class="toc-text">组件生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#render"><span class="toc-number">3.2.1.</span> <span class="toc-text">render()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constructor-NaN"><span class="toc-number">3.2.2.</span> <span class="toc-text">constructor()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#componentDidMount"><span class="toc-number">3.2.3.</span> <span class="toc-text">componentDidMount()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#componentDidUpdate-prevProps-prevState-snapshot"><span class="toc-number">3.2.4.</span> <span class="toc-text">componentDidUpdate(prevProps, prevState, snapshot)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#componentWillUnmount"><span class="toc-number">3.2.5.</span> <span class="toc-text">componentWillUnmount()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shouldComponentUpdate-nextProps-nextState"><span class="toc-number">3.2.6.</span> <span class="toc-text">shouldComponentUpdate(nextProps, nextState)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static-getDerivedStateFromProps-props-state"><span class="toc-number">3.2.7.</span> <span class="toc-text">static getDerivedStateFromProps(props, state)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getSnapshotBeforeUpdate-prevProps-prevState"><span class="toc-number">3.2.8.</span> <span class="toc-text">getSnapshotBeforeUpdate(prevProps, prevState)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定义错误边界组件"><span class="toc-number">3.2.9.</span> <span class="toc-text">定义错误边界组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static-getDerivedStateFromError-error"><span class="toc-number">3.2.10.</span> <span class="toc-text">static getDerivedStateFromError(error)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#componentDidCatch-error-info"><span class="toc-number">3.2.11.</span> <span class="toc-text">componentDidCatch(error, info)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#废弃的一些钩子"><span class="toc-number">3.2.12.</span> <span class="toc-text">废弃的一些钩子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#component-forceUpdate-callback"><span class="toc-number">3.3.</span> <span class="toc-text">component.forceUpdate(callback)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#props"><span class="toc-number">3.4.</span> <span class="toc-text">props</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#props-children"><span class="toc-number">3.4.1.</span> <span class="toc-text">props.children</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Render-Props"><span class="toc-number">3.4.2.</span> <span class="toc-text">Render Props</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#props添加默认值defaultProps"><span class="toc-number">3.4.3.</span> <span class="toc-text">props添加默认值defaultProps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用propTypes进行类型检查"><span class="toc-number">3.4.4.</span> <span class="toc-text">使用propTypes进行类型检查</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#事件处理"><span class="toc-number">4.</span> <span class="toc-text">事件处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#React事件处理函数中的this"><span class="toc-number">4.1.</span> <span class="toc-text">React事件处理函数中的this</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#事件处理函数的参数"><span class="toc-number">4.1.1.</span> <span class="toc-text">事件处理函数的参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React中的条件渲染"><span class="toc-number">5.</span> <span class="toc-text">React中的条件渲染</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://blog.dashlane.com/wp-content/uploads/2016/02/react-logo-2.png)"><div id="post-info"><div id="post-title"><div class="posttitle">React的基本使用</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-11-26<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-11-30</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/前端/">前端</a></span><div class="post-meta-wordcount"><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>最近准备好好从头开始系统的复习和学习一波React相关技术，本文作为第一篇，先来回顾一波React的基本使用</p>
<a id="more"></a>

<h1 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h1><p>可以将JSX作为看做一个普通的表达式，其内部可以进行标签属性的绑定，事件的监听等操作。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;img src=&#123;user.avatarUrl&#125;&gt;&lt;/img&gt;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为 <code>JSX</code> 语法上更接近<code>JavaScript</code> 而不是<code>HTML</code>，所以<code>React DOM</code>使用 <code>camelCase</code>（小驼峰命名）来定义属性的名称，而不使用<code>HTML</code> 属性名称的命名约定。<br>例如，<code>JSX</code> 里的 <code>class</code> 变成了 <code>className</code>，而<code>tabindex</code>则变为<code>tabIndex</code>。</p>
</blockquote>
<p>另外值得一提的是，<code>React DOM</code>在渲染所有输入内容之前，默认会进行转义,可以有效的防止XSS注入。</p>
<p><code>JSX</code>的写法在编译时其实会被转换为<code>React.createElement()</code>创建的对象,比如代码里面写成:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const element = (</span><br><span class="line">  &lt;h1 className=&quot;greeting&quot;&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">  &lt;/h1&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>就完全等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const element = React.createElement(</span><br><span class="line">  &apos;h1&apos;,</span><br><span class="line">  &#123;className: &apos;greeting&apos;&#125;,</span><br><span class="line">  &apos;Hello, world!&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这个函数创建了一个包含标签类型属性等信息的一个对象。</p>
<h1 id="元素渲染"><a href="#元素渲染" class="headerlink" title="元素渲染"></a>元素渲染</h1><p><code>React</code>是通过<code>ReactDOM.render</code>方法将其目标<code>React</code>元素挂载到<code>DOM</code>节点上的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;</span><br><span class="line">ReactDOM.render(element, document.getElementById(&apos;root&apos;));</span><br></pre></td></tr></table></figure>

<p>对于这种元素，如果想更新的话，可以再次调用<code>ReactDOM.render</code>去进行渲染。不过对于组件内部的<code>state</code>和<code>props</code>变化，<code>React</code>会自动更新。</p>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p><code>React</code>中的组件分为<code>Function Component</code>和<code>Class Component</code>,其中<code>Class Component</code>有一些额外的特性，之后的例子基本都采用这种写法</p>
<h2 id="state"><a href="#state" class="headerlink" title="state"></a><code>state</code></h2><p>组件内部有一些自己维护的数据状态，就可以使用<code>state</code>。<code>state</code>的初始化操作一般放到<code>class</code>的<code>constructor</code>中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;&#125;; // 初始化操作放在这里</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="setState-updater-callback"><a href="#setState-updater-callback" class="headerlink" title="setState(updater[, callback])"></a><code>setState(updater[, callback])</code></h3><p>对于修改<code>state</code>的操作，<code>React</code>提供了<code>setState()</code>方法，这个方法是合并修改的，即<code>state</code>有多个属性如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.state = &#123;</span><br><span class="line">    name: &quot;yang&quot;,</span><br><span class="line">    age: 23</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们调用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;</span><br><span class="line">    name: &quot;zhang&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>之后，其<code>name</code>属性的改动会更新到<code>state</code>上，但是不会对<code>state</code>的<code>age</code>属性去做修改.<br>但是<code>setState</code>对于<code>state</code>的修改是一个异步的操作，其内部会对多个相同的<code>state</code>操作进行合并操作，所以调用<code>setState</code>之后如果马上去使用<code>state</code>的话，其内部的值是没更新的，见下例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">        name: &quot;Yang&quot;,</span><br><span class="line">        age: 23,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">clickBtn = () =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">        name: &quot;zhang&quot;,</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(this.state); // &#123;name: &quot;Yang&quot;, age: 23&#125; 在这state并没有同步更新</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这种情况，<code>setState</code>方法可以传入第二个参数作为<code>callback</code>，其回调函数内部可以获得同步修改之后的值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">clickBtn = (e) =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">        name: &quot;Zhang&quot;</span><br><span class="line">    &#125;, () =&gt; &#123;</span><br><span class="line">        console.log(this.state);// &#123;name: &quot;Zhang&quot;, age: 23&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>另外如果<code>setState()</code>了之后想获得更新后的<code>state</code>的话，也可以在<code>componentDidUpdate(prevState, prevProps, snapShot)</code>中获取到</p>
</blockquote>
<p>除此之外还会有一种情况，比方说我频繁的去调用<code>setState</code>，且每次的<code>state</code>的值的改动会依赖上一次的<code>state</code>的值，这种情况下，普通的调用<code>setState</code>并不会像同步的那样去更新<code>state</code>的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">        counter: 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clickBtn = () =&gt; &#123;</span><br><span class="line">    for (let i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            counter: this.state.counter + 1</span><br><span class="line">        &#125;, () =&gt; &#123;</span><br><span class="line">            console.log(this.state); // console 5次 &#123;counter: 1&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上例所示，这样调用<code>setState</code>的话，<code>state</code>上一次的改动是异步操作，所以几次循环的<code>counter</code>值都为0，最后得到的<code>counter</code>为1。</p>
<p>为了针对上述这种情况，<code>setState</code>方法的第一个参数也可以传入一个函数，其函数的参数为<code>(state, props)</code>，即用上一个 <code>state</code>作为第一个参数，将此次更新被应用时的<code>props</code>做为第二个参数</p>
<p>那么我们做如下改动:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">clickBtn = () =&gt; &#123;</span><br><span class="line">    for (let i = 0; i &lt; 5; i ++) &#123;</span><br><span class="line">        this.setState((state, props) =&gt; &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                counter: state.counter + 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, () =&gt; &#123;</span><br><span class="line">            console.log(this.state);  // console 5次 &#123;counter: 5&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即可达到效果，此时<code>counter</code>即为5了</p>
<details>
    <summary>setState扩展阅读：StackOverflow: Dan谈论setState()的更新队列原则</summary>

<pre><code>[原文链接在这](https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973)
总结一下的他的发言：
1. 只要是在事件处理函数中调用的setState，不管有几个组件调用了无论多少次，最后都只会合成一次更新去调用一次render
2. 在事件处理函数中，这种队列的合并总是会按照调用的顺序来进行合并的，即对于同一属性的更新，最后一次的更新永远会覆盖前面的
3. 到React16及之前的版本，都只有事件处理函数式按照上述原则来的，在其他场景比如Ajax请求回调中，这种维持队列更新的原则就不成立
4. React准备在未来的React17中将这种维持队列更新的原则应用到所有地方，
但是在这之前如果想在事件处理函数之外的地方应用，请使用ReactDOM.unstable_batchedUpdates( () =&gt; {doSth;})</code></pre></details>


<p>另外还可以看这个<a href="https://github.com/facebook/react/issues/11527" target="_blank" rel="noopener">Github Issue: gaearon解释为什么state设计成异步更新</a></p>
<h2 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h2><p><a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener">官方图示</a></p>
<p>图示里面很清晰，当第一次挂载时，调用的钩子为：</p>
<ol>
<li><strong><code>constructor()</code></strong></li>
<li><code>static getDerivedStateFromProps()</code></li>
<li><strong><code>render()</code></strong></li>
<li><strong><code>componentDidMount()</code></strong></li>
</ol>
<blockquote>
<p><code>componentWillMount()</code>已被废弃，不建议再使用</p>
</blockquote>
<p>当组件的 props 或 state 发生变化时会触发更新, 调用的钩子为：</p>
<ol>
<li><code>static getDerivedStateFromProps()</code></li>
<li><strong><code>shouldComponentUpdate()</code></strong></li>
<li><strong><code>render()</code></strong></li>
<li><code>getSnapshotBeforeUpdate()</code></li>
<li><strong><code>componentDidUpdate()</code></strong></li>
</ol>
<blockquote>
<p><code>componentWillUpdate()</code> <code>componentWillReceiveProps()</code>已被废弃</p>
</blockquote>
<p>组件卸载时，调用的钩子为:</p>
<ul>
<li><code>componentWillUnmount()</code></li>
</ul>
<p>另外的，当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用：</p>
<ol>
<li><code>static getDerivedStateFromError()</code></li>
<li><strong><code>componentDidCatch()</code></strong></li>
</ol>
<p>接下来介绍一些常用的钩子函数：</p>
<h3 id="render"><a href="#render" class="headerlink" title="render()"></a><code>render()</code></h3><p><code>render()</code>方法是 class 组件中唯一必须实现的方法。</p>
<p><code>render()</code>函数应该为<strong>纯函数</strong>，这意味着在不修改组件 state 的情况下，每次调用时都返回相同的结果，并且它<strong>不会直接与浏览器交互。</strong></p>
<p>如需与浏览器进行交互，请在<code>componentDidMount()</code>或其他生命周期方法中执行你的操作。保持<code>render()</code> 为纯函数，可以使组件更容易思考。</p>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor()"></a><code>constructor()</code></h3><p>只有一个原则，在<code>constructor()</code>中只做3件事：</p>
<ol>
<li><code>super(props)</code>，否则，<code>this.props</code>在构造函数中可能会出现未定义的 bug。</li>
<li>通过给<code>this.state</code>赋值对象来初始化内部<code>state</code></li>
<li>为事件处理函数绑定实例,例如：<code>this.btnClick = this.btnClick.bind(this)</code></li>
</ol>
<p>在<code>constructor()</code>中没有任何必要调用<code>setState()</code>，如有需要直接给<code>this.state</code>赋值即可。</p>
<p>另外，给<code>state</code>赋值<code>props</code>的话，只会保存<code>props</code>的初始值，如果后续<code>props</code>发生变化，其<code>state</code>中的值是<strong>不会</strong>随之更新的，应当避免这种使用，直接使用<code>this.props.xxx</code>即可。</p>
<p>具体可以看这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//ParentComponent</span><br><span class="line">clickBtn = () =&gt; &#123;</span><br><span class="line">    this.setState((state) =&gt; (&#123;</span><br><span class="line">        counter: state.counter + 1</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;SubComponent counter=&#123;this.state.counter&#125; /&gt;</span><br><span class="line"></span><br><span class="line">            &lt;button onClick=&#123;this.clickBtn&#125;&gt;</span><br><span class="line">                click to add counter</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SubComponent</span><br><span class="line">constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">        counter: props.counter</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例中，父组件触发更新时，子组件中，<code>props</code>可以正常更新，但是<code>state.counter</code>并不会更新，仅仅还是第一次的<code>props.counter</code>的值</p>
<h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount()"></a><code>componentDidMount()</code></h3><p><code>componentDidMount()</code>会在组件挂载后（插入<code>DOM</code>树中）立即调用。依赖于<code>DOM</code> 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。</p>
<p>另外在<code>componentDidMount</code>中调用<code>setState()</code>的话，会再次触发<code>render()</code>,可能会有性能问题，所以尽量在<code>constructor()</code>中将<code>state</code>就初始化好。</p>
<h3 id="componentDidUpdate-prevProps-prevState-snapshot"><a href="#componentDidUpdate-prevProps-prevState-snapshot" class="headerlink" title="componentDidUpdate(prevProps, prevState, snapshot)"></a><code>componentDidUpdate(prevProps, prevState, snapshot)</code></h3><p><code>componentDidUpdate()</code>会在更新后会被立即调用。首次渲染<strong>不会执行此方法</strong>。</p>
<p>当组件更新后，可以在此处对<code>DOM</code>进行操作。如果你对更新前后<code>的 props</code>进行了比较，也可以选择在此处进行网络请求。（例如，当<code>props</code>未发生变化时，则不会执行网络请求）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">//    比如说可以这样使用</span><br><span class="line">    if (this.props.userID !== prevProps.userID) &#123;</span><br><span class="line">        this.getData(this.props.userID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外也可以在<code>componentDidUpdate()</code>中调用<code>setState()</code>，但是要预留好出口，即<strong>一定要有条件判断，否则就会陷入死循环</strong>。</p>
<p>其第三个参数<code>snapshot</code>是钩子<code>getSnapshotBeforeUpdate</code>的返回值(如果你定义了的话，没定义就是<code>undefined</code>)</p>
<h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount()"></a><code>componentWillUnmount()</code></h3><p><code>componentWillUnmount()</code> 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如清除 <code>timer</code>，取消网络请求或清除在<code>componentDidMount()</code>中创建的订阅等</p>
<p>另外，不该在<code>componentWillUnmount()</code> 调用<code>setState()</code></p>
<h3 id="shouldComponentUpdate-nextProps-nextState"><a href="#shouldComponentUpdate-nextProps-nextState" class="headerlink" title="shouldComponentUpdate(nextProps, nextState)"></a><code>shouldComponentUpdate(nextProps, nextState)</code></h3><p>当 <code>props/state</code>发生变化时，<code>shouldComponentUpdate()</code>会在渲染执行之前被调用。返回值默认为<code>true</code>。<strong>首次渲染或使用<code>forceUpdate()</code>时不会调用该方法</strong>。</p>
<p>一般是不需要定义该钩子去修改默认行为的，如需做一些性能优化的话，可以考虑<code>React.PureComponent</code>而不是去改其内部逻辑。</p>
<p>如果无论如何都要自己实现<code>shouldComponentUpdate()</code>,可以通过<code>this.props</code>与<code>nextProps</code> 以及<code>this.state</code>与<code>nextState</code> 进行比较，并返回<code>false</code> 以告知<code>React</code>可以跳过更新。</p>
<p>请注意，返回<code>false</code><strong>并不会阻止子组件在<code>state</code>更改时重新渲染</strong>。</p>
<blockquote>
<p><code>shouldComponentUpdate()</code>返回<code>false</code>之后，不会去调用<code>render()</code>和<code>componentWillUpdate(已废弃)</code>以及<code>componentDidUpdate()</code></p>
</blockquote>
<p>另外官方提到说，后续版本可能就算返回了<code>false</code>,也有可能导致组件重新渲染</p>
<details>
    <summary>扩展了解: React.PureComponent</summary>

<pre><code>React.PureComponent和常规的React.Component的区别在于:

React.PureComponent中以浅层对比prop和state的方式来实现了shouldComponentUpdate()。

其内部只对对象做了浅层比较，所以涉及到state/props嵌套较深的情况的时候，尽量不要用React.PureComponent,考虑其他办法，比如forceUpdate()等

总的来说，对于结构简单的state/props，使用React.PureComponent可提高性能</code></pre></details>

<h3 id="static-getDerivedStateFromProps-props-state"><a href="#static-getDerivedStateFromProps-props-state" class="headerlink" title="static getDerivedStateFromProps(props, state)"></a><code>static getDerivedStateFromProps(props, state)</code></h3><p><code>getDerivedStateFromProps</code>会在<strong>调用<code>render</code>方法之前</strong>调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来<strong>更新<code>state</code></strong>，如果返回<code>null</code>则不更新任何内容。</p>
<p>本钩子访问不到组件实例，且用处真的不多，不做过多了解，只需要了解到每次渲染前都会触发<code>static getDerivedStateFromProps()</code>即可。</p>
<blockquote>
<p>一般不需要使用本钩子，常用的场景都有简单的解决方案, 见: <a href="https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html" target="_blank" rel="noopener">you-probably-dont-need-derived-state</a></p>
</blockquote>
<h3 id="getSnapshotBeforeUpdate-prevProps-prevState"><a href="#getSnapshotBeforeUpdate-prevProps-prevState" class="headerlink" title="getSnapshotBeforeUpdate(prevProps, prevState)"></a><code>getSnapshotBeforeUpdate(prevProps, prevState)</code></h3><p>本钩子也<strong>不常用</strong>。</p>
<p><code>getSnapshotBeforeUpdate()</code>在最近一次渲染输出（提交到<code>DOM</code>节点）之前调用。</p>
<p>它使得组件能在发生更改之前从<code>DOM</code>中捕获一些信息（例如，滚动位置）。</p>
<p>此生命周期的任何返回值将作为参数传递给<code>componentDidUpdate()</code>(第三个参数)。</p>
<p>来看具体用法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class SubComponent extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.spanRef = React.createRef();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">        // 定义了getSnapshotBeforeUpdate之后就要定义componentDidUpdate 否则会报warning</span><br><span class="line">        // 因为getSnapshotBeforeUpdate()的返回值只有在componentDidUpdate中使用</span><br><span class="line">        const spanNode = this.spanRef.current;</span><br><span class="line">        return spanNode.innerText; // 无需返回值时返回null即可</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidUpdate(prevProps, prevState, snapShot) &#123;</span><br><span class="line">        // 在这可以获得getSnapshotBeforeUpdate返回的快照 </span><br><span class="line">        // 比如更新后的props.counter为5 会console snapShot props.counter: 4</span><br><span class="line">        console.log(&quot;snapShot&quot;, snapShot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;SubComponent&lt;/h2&gt;</span><br><span class="line">                &lt;span ref=&#123;this.spanRef&#125;&gt;</span><br><span class="line">                    props.counter: &#123;this.props.counter&#125;</span><br><span class="line">                &lt;/span&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义错误边界组件"><a href="#定义错误边界组件" class="headerlink" title="定义错误边界组件"></a>定义错误边界组件</h3><p><strong>任意的</strong><code>React</code>组件，只要定义了<code>static getDerivedStateFromError(error)</code>或者<code>componentDidCatch(error, info)</code>之后，就会成为一个错误边界，其子组件如果出错的话，错误会在这个错误边界组件中被上述2个方法捕获到，所以可以做一些错误处理，比如说更换为出错提示的UI等。</p>
<p>在这看一个错误边界组件的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// ErrorBoundary.js</span><br><span class="line">export default class ErrorBoundary extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            isError: false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static getDerivedStateFromError(error) &#123;</span><br><span class="line">        //    getDerivedStateFromError将抛出的错误作为参数，并返回一个值以更新 state</span><br><span class="line">        console.log(&quot;getDerivedStateFromError: &quot;,error);</span><br><span class="line">        return &#123;</span><br><span class="line">            isError: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        if(this.state.isError) &#123;</span><br><span class="line">            return &lt;h1&gt;出错啦~&lt;/h1&gt;</span><br><span class="line">        &#125;</span><br><span class="line">        return this.props.children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了上述的错误处理组件之后，我们可以将之前的组件作为该错误处理组件的子组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ErrorBoundary&gt;</span><br><span class="line">    &lt;SubComponent counter=&#123;this.state.counter&#125;/&gt;</span><br><span class="line">&lt;/ErrorBoundary&gt;</span><br></pre></td></tr></table></figure>

<h3 id="static-getDerivedStateFromError-error"><a href="#static-getDerivedStateFromError-error" class="headerlink" title="static getDerivedStateFromError(error)"></a><code>static getDerivedStateFromError(error)</code></h3><p> <code>getDerivedStateFromError</code>将抛出的错误作为参数，并返回一个值以更新<code>state</code>,比如上文声明的错误边界组件中的：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> static getDerivedStateFromError(error) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        isError: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p><code>getDerivedStateFromError()</code> 会在<strong>渲染阶段</strong>调用，因此不允许出现副作用。 如遇此类情况，请改用<code>componentDidCatch()</code>。</p>
</blockquote>
<h3 id="componentDidCatch-error-info"><a href="#componentDidCatch-error-info" class="headerlink" title="componentDidCatch(error, info)"></a><code>componentDidCatch(error, info)</code></h3><p> <code>componentDidCatch</code>的第二个参数是一个带错误栈信息的错误信息对象</p>
<p> <code>componentDidCatch()</code>会在<strong>commit阶段</strong>被调用(commit阶段见<a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener">图示</a>)，因此允许执行副作用。 它应该用于记录错误之类的情况</p>
<h3 id="废弃的一些钩子"><a href="#废弃的一些钩子" class="headerlink" title="废弃的一些钩子"></a>废弃的一些钩子</h3><ul>
<li><code>componentWillMount()</code></li>
<li><code>componentWillReceiveProps(nextProps)</code></li>
<li><code>componentWillUpdate(nextProps, nextState)</code></li>
</ul>
<p>上述钩子已经被官方废弃，虽然仍然可以使用，但是并不推荐，官方同时也给出了<a href="https://zh-hans.reactjs.org/blog/2018/03/27/update-on-async-rendering.html" target="_blank" rel="noopener">替代方案</a></p>
<h2 id="component-forceUpdate-callback"><a href="#component-forceUpdate-callback" class="headerlink" title="component.forceUpdate(callback)"></a><code>component.forceUpdate(callback)</code></h2><p>默认情况下，<strong>当组件的<code>state</code>或<code>props</code>发生变化时，组件将重新渲染</strong>。如果<code>render()</code>方法依赖于其他数据，则可以调用 <code>forceUpdate()</code> 强制让组件重新渲染。</p>
<p>调用<code>forceUpdate()</code>将致使组件调用<code>render()</code>方法，此操作会跳过该组件的 <code>shouldComponentUpdate()</code>。</p>
<p>但其子组件会触发正常的生命周期方法，包括<code>shouldComponentUpdate()</code> 方法。<strong>这意味着如果子组件的<code>shouldComponentUpdate</code>返回false的话，子组件不会被重新渲染</strong>。</p>
<p>如果标记发生变化，<code>React</code>仍将只更新<code>DOM</code>。</p>
<blockquote>
<p>通常你应该避免使用<code>forceUpdate()</code>，尽量<code>在 render()</code>中使用<code>this.props</code>和<code>this.state</code></p>
</blockquote>
<h2 id="props"><a href="#props" class="headerlink" title="props"></a><code>props</code></h2><p>对于<code>FunctionComponent</code>来讲，<code>props</code>就是函数的参数，对于<code>ClassComponent</code>，<code>props</code>会被挂到当前组件实例上，通过<code>this.props</code>可以进行访问。</p>
<blockquote>
<p>一样的，<code>props</code>不允许子组件对其进行修改</p>
</blockquote>
<h3 id="props-children"><a href="#props-children" class="headerlink" title="props.children"></a><code>props.children</code></h3><p>每个组件都可以获取到<code>props.children</code>。它包含组件的开始标签和结束标签之间的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Welcome&gt;Hello world!&lt;/Welcome&gt;</span><br></pre></td></tr></table></figure>

<p>在<code>Welcome</code>组件中获取<code>props.children</code>，就可以得到字符串<code>Hello world!</code></p>
<p>对于<code>class</code>组件，请使用<code>this.props.children</code>来获取</p>
<p><code>props.children</code>是一个特殊的<code>prop</code>，通常由<code>JSX</code>表达式中的子组件组成，而非组件本身定义</p>
<h3 id="Render-Props"><a href="#Render-Props" class="headerlink" title="Render Props"></a><code>Render Props</code></h3><p> <code>render prop</code>是指一种在<code>React</code>组件之间使用一个值为函数的<code>prop</code>共享代码的简单技术,即传入一个函数作为<code>props</code>给其他组件：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &lt;DataProvider render=&#123;data =&gt; (</span><br><span class="line">  &lt;h1&gt;Hello &#123;data.target&#125;&lt;/h1&gt;</span><br><span class="line">)&#125;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="props添加默认值defaultProps"><a href="#props添加默认值defaultProps" class="headerlink" title="props添加默认值defaultProps"></a><code>props</code>添加默认值<code>defaultProps</code></h3><p><code>defaultProps</code>可以为<code>Class</code>组件添加默认<code>props</code>。这一般用于<code>props</code>未赋值，但又不能为<code>null</code>的情况:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SubComponent.defaultProps = &#123;</span><br><span class="line">    counter: 0</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>未指定<code>props.counter</code>的时候，会按照当前给定的默认值来取值</p>
<p>如果你正在使用像<code>transform-class-properties</code>的<code>Babel</code>转换工具，你也可以在<code>React</code>组件类中声明<code>defaultProps</code>作为<code>static</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">export default class SubComponent extends React.Component &#123;</span><br><span class="line">    static defaultProps = &#123;</span><br><span class="line">        counter: 0</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;SubComponent&lt;/h2&gt;</span><br><span class="line">                &lt;span&gt;</span><br><span class="line">                    props.counter: &#123;this.props.counter&#125;</span><br><span class="line">                &lt;/span&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用propTypes进行类型检查"><a href="#使用propTypes进行类型检查" class="headerlink" title="使用propTypes进行类型检查"></a>使用<code>propTypes</code>进行类型检查</h3><blockquote>
<p>自<code>React v15.5</code>起，<code>React.PropTypes</code>已移入另一个包中。请使用<code>prop-types</code>库 代替。详情请见<a href="https://zh-hans.reactjs.org/blog/2017/04/07/react-v15.5.0.html#migrating-from-reactproptypes" target="_blank" rel="noopener">博客</a></p>
</blockquote>
<p>详细的用法可以见<a href="https://www.npmjs.com/package/prop-types" target="_blank" rel="noopener">npm usage</a></p>
<details>
    <summary>或者点击查看: prop-types使用举例</summary>

<pre><code>import PropTypes from &apos;prop-types&apos;;
MyComponent.propTypes = {
  // 你可以将属性声明为 JS 原生类型，默认情况下
  // 这些属性都是可选的。
  optionalArray: PropTypes.array,
  optionalBool: PropTypes.bool,
  optionalFunc: PropTypes.func,
  optionalNumber: PropTypes.number,
  optionalObject: PropTypes.object,
  optionalString: PropTypes.string,
  optionalSymbol: PropTypes.symbol,

  // 任何可被渲染的元素（包括数字、字符串、元素或数组）
  // (或 Fragment) 也包含这些类型。
  optionalNode: PropTypes.node,

  // 一个 React 元素。
  optionalElement: PropTypes.element,

  // 一个 React 元素类型（即，MyComponent）。
  optionalElementType: PropTypes.elementType,

  // 你也可以声明 prop 为类的实例，这里使用
  // JS 的 instanceof 操作符。
  optionalMessage: PropTypes.instanceOf(Message),

  // 你可以让你的 prop 只能是特定的值，指定它为
  // 枚举类型。
  optionalEnum: PropTypes.oneOf([&apos;News&apos;, &apos;Photos&apos;]),

  // 一个对象可以是几种类型中的任意一个类型
  optionalUnion: PropTypes.oneOfType([
    PropTypes.string,
    PropTypes.number,
    PropTypes.instanceOf(Message)
  ]),

  // 可以指定一个数组由某一类型的元素组成
  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),

  // 可以指定一个对象由某一类型的值组成
  optionalObjectOf: PropTypes.objectOf(PropTypes.number),

  // 可以指定一个对象由特定的类型值组成
  optionalObjectWithShape: PropTypes.shape({
    color: PropTypes.string,
    fontSize: PropTypes.number
  }),

  // An object with warnings on extra properties
  optionalObjectWithStrictShape: PropTypes.exact({
    name: PropTypes.string,
    quantity: PropTypes.number
  }),   

  // 你可以在任何 PropTypes 属性后面加上 `isRequired` ，确保
  // 这个 prop 没有被提供时，会打印警告信息。
  requiredFunc: PropTypes.func.isRequired,

  // 任意类型的数据
  requiredAny: PropTypes.any.isRequired,

  // 你可以指定一个自定义验证器。它在验证失败时应返回一个 Error 对象。
  // 请不要使用 `console.warn` 或抛出异常，因为这在 `onOfType` 中不会起作用。
  customProp: function(props, propName, componentName) {
    if (!/matchme/.test(props[propName])) {
      return new Error(
        &apos;Invalid prop `&apos; + propName + &apos;` supplied to&apos; +
        &apos; `&apos; + componentName + &apos;`. Validation failed.&apos;
      );
    }
  },

  // 你也可以提供一个自定义的 `arrayOf` 或 `objectOf` 验证器。
  // 它应该在验证失败时返回一个 Error 对象。
  // 验证器将验证数组或对象中的每个值。验证器的前两个参数
  // 第一个是数组或对象本身
  // 第二个是他们当前的键。
  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) {
    if (!/matchme/.test(propValue[key])) {
      return new Error(
        &apos;Invalid prop `&apos; + propFullName + &apos;` supplied to&apos; +
        &apos; `&apos; + componentName + &apos;`. Validation failed.&apos;
      );
    }
  })
};</code></pre></details>

<p>另外可以通过对<code>props.children</code>做类型限制来限制能在本组件中只接收一个元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import Props_Types from &quot;prop-types&quot;;</span><br><span class="line"></span><br><span class="line">export default class SubComponent extends React.Component &#123;</span><br><span class="line">    // static defaultProps = &#123;</span><br><span class="line">    //     counter: 0</span><br><span class="line">    // &#125;;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;SubComponent&lt;/h2&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &#123;this.props.children&#125;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SubComponent.propTypes = &#123;</span><br><span class="line">    children: Props_Types.element.isRequired // </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>将<code>children</code>的类型设为<code>Props_Types.element</code>即可，我们设置了上述的检查后，如果这么使用的话:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;SubComponent&gt;</span><br><span class="line">    &lt;h2&gt;children1&lt;/h2&gt;</span><br><span class="line">    &lt;h3&gt;children2&lt;/h3&gt;</span><br><span class="line">&lt;/SubComponent&gt;</span><br></pre></td></tr></table></figure>

<p>就会看到报错： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed prop type: Invalid prop `children` of type `array` supplied to `SubComponent`, expected a single ReactElement.</span><br></pre></td></tr></table></figure>

<p>此时如果想要允许多个元素传入，可以将类型检查改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SubComponent.propTypes = &#123;</span><br><span class="line">    children: Props_Types.arrayOf(Props_Types.element)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><p>看完了组件的相关概念，来关心一下<code>React</code>中的事件处理</p>
<p><code>React</code>中的事件处理都是驼峰写法: <code>&lt;button onClick={this.clickBtn}&gt;&lt;/button&gt;</code></p>
<p>另外由于没有类似<code>Vue</code>的修饰符，所以对于组织默认行为或者阻止冒泡等需求，需要手动去调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">clickBtn = (e) =&gt; &#123;</span><br><span class="line">    e.preventDefault(); // 在这里手动调用</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">    this.setState((state) =&gt; (&#123;</span><br><span class="line">        counter: state.counter + 1</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick=&#123;this.clickBtn&#125;&gt;</span><br><span class="line">                click to add counter</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>事件处理函数中的<code>e</code>是一个<code>React</code>自己合成的事件对象，具体文档见 <a href="https://zh-hans.reactjs.org/docs/events.html" target="_blank" rel="noopener">SyntheticEvent</a></p>
</blockquote>
<h2 id="React事件处理函数中的this"><a href="#React事件处理函数中的this" class="headerlink" title="React事件处理函数中的this"></a>React事件处理函数中的<code>this</code></h2><p>需要注意的是，<code>JSX</code>回调函数中的<code>this</code>, 如果你忘记绑定<code>this.handleClick</code>并把它传入了 <code>onClick</code>，当你调用这个函数的时候<code>this</code>的值为<code>undefined</code>而非当前组件实例。</p>
<p>分析一下原因，为什么调用的事件处理函数中的<code>this</code>是<code>undefined</code>?</p>
<p>先来看一个<code>JS</code>的小例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class TestThis &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.attr = &quot;aaa&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    consoleAttr() &#123;</span><br><span class="line">        console.log(this.attr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const test = new TestThis();</span><br><span class="line">test.consoleAttr();// aaa</span><br><span class="line">let tempMethod = test.consoleAttr;</span><br><span class="line">tempMethod.bind(test)(); // aaa 硬性绑定到当前实例即可获得this</span><br><span class="line">tempMethod(); // Cannot read property &apos;attr&apos; of undefined 即 this 为undefined</span><br></pre></td></tr></table></figure>

<p>上述例子中将内部的方法重新赋值再次调用之后<code>this</code>指向就改变了。</p>
<p>明白上面例子后，再来了解一下<code>JSX</code>中传递的是什么东西: </p>
<blockquote>
<p>With JSX you pass a function as the event handler, rather than a string.</p>
</blockquote>
<p>官方文档说的很清楚，传递的是一个<code>function</code>，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick=&#123;this.clickBtn&#125;&gt;</span><br><span class="line">                click to add counter</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">// 在这里的&lt;button onClick=&#123;this.clickBtn&#125;&gt;其实就等价于:</span><br><span class="line">render() &#123;</span><br><span class="line">    const tempClickBtn = this.clickBtn;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick=&#123;tempClickBtn&#125;&gt;</span><br><span class="line">                click to add counter</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以造成了这种你在事件处理函数中得到的<code>this</code>其实是<code>undefined</code>的情况</p>
<p>那么为了避免这种情况，一般采用三种方法:</p>
<ol>
<li><p>在<code>constructor</code>中将每一个事件处理函数手动绑定到当前实例(真的不推荐，太麻烦)</p>
</li>
<li><p>使用<code>public class fields</code>语法直接声明事件处理函数即可:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clickBtn = (e) =&gt; &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在回调中使用箭头函数:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">clickBtn(e) &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick=&#123;(e) =&gt; this.clickBtn(e)&#125;&gt;</span><br><span class="line">                click to add counter</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="事件处理函数的参数"><a href="#事件处理函数的参数" class="headerlink" title="事件处理函数的参数"></a>事件处理函数的参数</h3><p>如果要想给事件处理方法传递更多参数时，只能通过：</p>
<ol>
<li><p>回调函数的写法:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">clickBtn(info, e) &#123;</span><br><span class="line">    console.log(info);</span><br><span class="line">    console.log(e);</span><br><span class="line">&#125;;</span><br><span class="line">&lt;!--回调函数的 e 必须显式的传递给事件处理方法 --&gt;</span><br><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick=&#123;(e) =&gt; this.clickBtn(&quot;123&quot;, e)&#125;&gt;</span><br><span class="line">                click to add counter</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>bind的写法:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">clickBtn(info, e) &#123;</span><br><span class="line">    console.log(info);</span><br><span class="line">    console.log(e);</span><br><span class="line">&#125;;</span><br><span class="line">// bind的写法不需要显式的传递 e</span><br><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick=&#123;this.clickBtn.bind(this, &quot;123&quot;)&#125;&gt;</span><br><span class="line">                click to add counter</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="React中的条件渲染"><a href="#React中的条件渲染" class="headerlink" title="React中的条件渲染"></a>React中的条件渲染</h1></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">DeeJay</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://deejay0921.github.io/2019/11/26/React的基本使用/">https://deejay0921.github.io/2019/11/26/React的基本使用/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://deejay0921.github.io">DeeJay's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/前端/">前端    </a><a class="post-meta__tags" href="/tags/React/">React    </a></div><div class="post_share"><div class="social-share" data-image="https://blog.dashlane.com/wp-content/uploads/2016/02/react-logo-2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2019/11/19/Vue后端渲染之Nuxt.js/"><img class="next_cover lazyload" data-src="https://moriohcdn.b-cdn.net/521f533697.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Vue后端渲染之Nuxt.js</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/10/30/TypeScript中的映射类型/" title="TypeScript中的映射类型及常见工具映射类型"><img class="relatedPosts_cover lazyload" data-src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2018/08/typescriptfeature.png"><div class="relatedPosts_title">TypeScript中的映射类型及常见工具映射类型</div></a></div><div class="relatedPosts_item"><a href="/2017/08/20/BOM/" title="BOM"><img class="relatedPosts_cover lazyload" data-src="https://image.slidesharecdn.com/dombomajaxevent-110401021116-phpapp01/95/browser-object-model-27-728.jpg?cb=1301623910"><div class="relatedPosts_title">BOM</div></a></div><div class="relatedPosts_item"><a href="/2017/08/06/CSS-垂直居中的几种实现思路方法/" title="CSS-垂直居中的几种实现思路方法"><img class="relatedPosts_cover lazyload" data-src="https://content.linkedin.com/content/dam/me/learning/blog/2016/september/CSS.jpg"><div class="relatedPosts_title">CSS-垂直居中的几种实现思路方法</div></a></div><div class="relatedPosts_item"><a href="/2017/09/02/AMD_-CMD/" title="AMD_-CMD"><img class="relatedPosts_cover lazyload" data-src="https://puppet.com/sites/default/files/2018-04/D2549-Modules-1200x626%20%281%29.png"><div class="relatedPosts_title">AMD_-CMD</div></a></div><div class="relatedPosts_item"><a href="/2017/08/01/CSS居中/" title="CSS居中"><img class="relatedPosts_cover lazyload" data-src="https://content.linkedin.com/content/dam/me/learning/blog/2016/september/CSS.jpg"><div class="relatedPosts_title">CSS居中</div></a></div><div class="relatedPosts_item"><a href="/2017/07/30/CSS基础/" title="CSS基础"><img class="relatedPosts_cover lazyload" data-src="https://content.linkedin.com/content/dam/me/learning/blog/2016/september/CSS.jpg"><div class="relatedPosts_title">CSS基础</div></a></div></div><div class="clear_both"></div></div></div></div><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2019 By DeeJay</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script></body></html>