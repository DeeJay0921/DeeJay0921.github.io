<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>React Hooks的基本介绍 | DeeJay's Blog</title><meta name="description" content="React Hooks的基本介绍"><meta name="keywords" content="前端,React"><meta name="author" content="DeeJay"><meta name="copyright" content="DeeJay"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="React Hooks的基本介绍"><meta name="twitter:description" content="React Hooks的基本介绍"><meta name="twitter:image" content="https://showmethecode.com.br/images/posts/react-hooks/banner.png"><meta property="og:type" content="article"><meta property="og:title" content="React Hooks的基本介绍"><meta property="og:url" content="https://deejay0921.github.io/2019/12/09/React Hooks的基本介绍/"><meta property="og:site_name" content="DeeJay's Blog"><meta property="og:description" content="React Hooks的基本介绍"><meta property="og:image" content="https://showmethecode.com.br/images/posts/react-hooks/banner.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://deejay0921.github.io/2019/12/09/React Hooks的基本介绍/"><link rel="next" title="React的基本使用" href="https://deejay0921.github.io/2019/11/26/React的基本使用/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'false',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'false',
  Snackbar: undefined
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">DeeJay's Blog</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="https://avatars1.githubusercontent.com/u/20784273?s=400&amp;u=ba38b4835b7e3c4960763bc6dce9abb320c43f05&amp;v=4" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">153</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">99</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">7</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Hooks简介"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Hooks简介</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Hooks的使用原则"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">Hooks的使用原则</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#State-Hook"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">State Hook</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#State-Hook的简单使用"><span class="toc_mobile_items-number">1.2.1.</span> <span class="toc_mobile_items-text">State Hook的简单使用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#state-Hook中的事件处理函数"><span class="toc_mobile_items-number">1.2.2.</span> <span class="toc_mobile_items-text">state Hook中的事件处理函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#定义多个state"><span class="toc_mobile_items-number">1.2.3.</span> <span class="toc_mobile_items-text">定义多个state</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#state-hook的更新"><span class="toc_mobile_items-number">1.2.4.</span> <span class="toc_mobile_items-text">state hook的更新</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Effect-Hook"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">Effect Hook</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#无需清除的effect的简单使用"><span class="toc_mobile_items-number">1.3.1.</span> <span class="toc_mobile_items-text">无需清除的effect的简单使用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#需要清除的effect"><span class="toc_mobile_items-number">1.3.2.</span> <span class="toc_mobile_items-text">需要清除的effect</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#使用多个Effect将不相关的逻辑分离开"><span class="toc_mobile_items-number">1.3.3.</span> <span class="toc_mobile_items-text">使用多个Effect将不相关的逻辑分离开</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#由于effect在每次重渲染时都会执行导致的性能问题及解决方案"><span class="toc_mobile_items-number">1.3.4.</span> <span class="toc_mobile_items-text">由于effect在每次重渲染时都会执行导致的性能问题及解决方案</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#自定义Hook"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">自定义Hook</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#useContext"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">useContext</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#useReducer"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">useReducer</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#useCallback-和-useMemo"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">useCallback 和 useMemo</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#使用useCallback和useMemo的场景举例"><span class="toc_mobile_items-number">1.7.1.</span> <span class="toc_mobile_items-text">使用useCallback和useMemo的场景举例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#使用useCallback举例"><span class="toc_mobile_items-number">1.7.2.</span> <span class="toc_mobile_items-text">使用useCallback举例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#使用useMemo举例"><span class="toc_mobile_items-number">1.7.3.</span> <span class="toc_mobile_items-text">使用useMemo举例</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#useRef"><span class="toc_mobile_items-number">1.8.</span> <span class="toc_mobile_items-text">useRef</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#useImperativeHandle"><span class="toc_mobile_items-number">1.9.</span> <span class="toc_mobile_items-text">useImperativeHandle</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#useLayoutEffect"><span class="toc_mobile_items-number">1.10.</span> <span class="toc_mobile_items-text">useLayoutEffect</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#一些补充"><span class="toc_mobile_items-number">1.11.</span> <span class="toc_mobile_items-text">一些补充</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#react-hooks-异步获取数据"><span class="toc_mobile_items-number">1.11.1.</span> <span class="toc_mobile_items-text">react hooks 异步获取数据</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#useRef的额外用法"><span class="toc_mobile_items-number">1.11.2.</span> <span class="toc_mobile_items-text">useRef的额外用法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#使用useRef让effect只在组件更新时执行"><span class="toc_mobile_items-number">1.11.2.1.</span> <span class="toc_mobile_items-text">使用useRef让effect只在组件更新时执行</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#通过useRef获取上一轮的props或者state"><span class="toc_mobile_items-number">1.11.2.2.</span> <span class="toc_mobile_items-text">通过useRef获取上一轮的props或者state</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#组件中的函数读取state和prop出现不及时更新的情况"><span class="toc_mobile_items-number">1.11.2.3.</span> <span class="toc_mobile_items-text">组件中的函数读取state和prop出现不及时更新的情况</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#在函数组件中使用hook达到static-getDerivedStateFromProps的效果"><span class="toc_mobile_items-number">1.11.2.4.</span> <span class="toc_mobile_items-text">在函数组件中使用hook达到static getDerivedStateFromProps的效果</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#实现类似于React-PureComponent的效果"><span class="toc_mobile_items-number">1.11.2.5.</span> <span class="toc_mobile_items-text">实现类似于React.PureComponent的效果</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Hooks简介"><span class="toc-number">1.</span> <span class="toc-text">Hooks简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Hooks的使用原则"><span class="toc-number">1.1.</span> <span class="toc-text">Hooks的使用原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#State-Hook"><span class="toc-number">1.2.</span> <span class="toc-text">State Hook</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#State-Hook的简单使用"><span class="toc-number">1.2.1.</span> <span class="toc-text">State Hook的简单使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#state-Hook中的事件处理函数"><span class="toc-number">1.2.2.</span> <span class="toc-text">state Hook中的事件处理函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定义多个state"><span class="toc-number">1.2.3.</span> <span class="toc-text">定义多个state</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#state-hook的更新"><span class="toc-number">1.2.4.</span> <span class="toc-text">state hook的更新</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Effect-Hook"><span class="toc-number">1.3.</span> <span class="toc-text">Effect Hook</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#无需清除的effect的简单使用"><span class="toc-number">1.3.1.</span> <span class="toc-text">无需清除的effect的简单使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#需要清除的effect"><span class="toc-number">1.3.2.</span> <span class="toc-text">需要清除的effect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用多个Effect将不相关的逻辑分离开"><span class="toc-number">1.3.3.</span> <span class="toc-text">使用多个Effect将不相关的逻辑分离开</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#由于effect在每次重渲染时都会执行导致的性能问题及解决方案"><span class="toc-number">1.3.4.</span> <span class="toc-text">由于effect在每次重渲染时都会执行导致的性能问题及解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义Hook"><span class="toc-number">1.4.</span> <span class="toc-text">自定义Hook</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useContext"><span class="toc-number">1.5.</span> <span class="toc-text">useContext</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useReducer"><span class="toc-number">1.6.</span> <span class="toc-text">useReducer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useCallback-和-useMemo"><span class="toc-number">1.7.</span> <span class="toc-text">useCallback 和 useMemo</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用useCallback和useMemo的场景举例"><span class="toc-number">1.7.1.</span> <span class="toc-text">使用useCallback和useMemo的场景举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用useCallback举例"><span class="toc-number">1.7.2.</span> <span class="toc-text">使用useCallback举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用useMemo举例"><span class="toc-number">1.7.3.</span> <span class="toc-text">使用useMemo举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useRef"><span class="toc-number">1.8.</span> <span class="toc-text">useRef</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useImperativeHandle"><span class="toc-number">1.9.</span> <span class="toc-text">useImperativeHandle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useLayoutEffect"><span class="toc-number">1.10.</span> <span class="toc-text">useLayoutEffect</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一些补充"><span class="toc-number">1.11.</span> <span class="toc-text">一些补充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#react-hooks-异步获取数据"><span class="toc-number">1.11.1.</span> <span class="toc-text">react hooks 异步获取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useRef的额外用法"><span class="toc-number">1.11.2.</span> <span class="toc-text">useRef的额外用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用useRef让effect只在组件更新时执行"><span class="toc-number">1.11.2.1.</span> <span class="toc-text">使用useRef让effect只在组件更新时执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#通过useRef获取上一轮的props或者state"><span class="toc-number">1.11.2.2.</span> <span class="toc-text">通过useRef获取上一轮的props或者state</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#组件中的函数读取state和prop出现不及时更新的情况"><span class="toc-number">1.11.2.3.</span> <span class="toc-text">组件中的函数读取state和prop出现不及时更新的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在函数组件中使用hook达到static-getDerivedStateFromProps的效果"><span class="toc-number">1.11.2.4.</span> <span class="toc-text">在函数组件中使用hook达到static getDerivedStateFromProps的效果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现类似于React-PureComponent的效果"><span class="toc-number">1.11.2.5.</span> <span class="toc-text">实现类似于React.PureComponent的效果</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://showmethecode.com.br/images/posts/react-hooks/banner.png)"><div id="post-info"><div id="post-title"><div class="posttitle">React Hooks的基本介绍</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-12-09<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-12-29</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/前端/">前端</a></span><div class="post-meta-wordcount"><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>上篇介绍了React的基本使用，这篇博客介绍一下著名的React Hooks</p>
<a id="more"></a>

<h1 id="Hooks简介"><a href="#Hooks简介" class="headerlink" title="Hooks简介"></a>Hooks简介</h1><blockquote>
<p>注意：React 16.8.0 是第一个支持 Hook 的版本</p>
</blockquote>
<p><code>Hooks</code>是<strong>一些可以让你在函数组件里“钩入”<code>React state</code>及生命周期等特性的函数</strong>。其提供了使函数式组件可以使用和<code>Class</code>组件一样的特性的方法，例如<code>useState</code>可以让函数式组件也拥有<code>state</code>等。</p>
<p><code>Hooks</code>带来的好处有：</p>
<ul>
<li>可以使用<code>Hook</code>从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用。<code>Hook</code> 使你<strong>在无需修改组件结构的情况下复用状态逻辑</strong></li>
<li><code>Hook</code>将<strong>组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分</strong>。</li>
<li><code>Hook</code>使你<strong>在非<code>class</code>的情况下可以使用更多的<code>React</code>特性</strong></li>
</ul>
<h2 id="Hooks的使用原则"><a href="#Hooks的使用原则" class="headerlink" title="Hooks的使用原则"></a>Hooks的使用原则</h2><p><code>Hook</code>就是<code>JavaScript</code>函数，但是使用它们会有两个额外的规则：</p>
<ol>
<li>只能在<strong>函数最外层</strong>调用<code>Hook</code>。不要在循环、条件判断或者子函数中调用。</li>
<li>只能在<code>React</code>的<strong>函数组件中</strong>调用<code>Hook</code>。不要在其他<code>JavaScript</code>函数中调用。(当然自定义的<code>Hook</code>中也可以调用)</li>
</ol>
<h2 id="State-Hook"><a href="#State-Hook" class="headerlink" title="State Hook"></a>State Hook</h2><h3 id="State-Hook的简单使用"><a href="#State-Hook的简单使用" class="headerlink" title="State Hook的简单使用"></a>State Hook的简单使用</h3><p>先来看一个最简单的使用<code>useState()</code>的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;useState&#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">export default () =&gt; &#123;</span><br><span class="line">    const [counter,  setCounter] = useState(0); // 0代表给counter的初始值为0</span><br><span class="line"></span><br><span class="line">    let btnClick = () =&gt; (</span><br><span class="line">        setCounter(counter + 1)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;LearnHooks&lt;/h1&gt;</span><br><span class="line">            &lt;div&gt;current Counter: &#123;counter&#125;&lt;/div&gt;</span><br><span class="line">            &lt;button onClick=&#123;btnClick&#125;&gt;click to plus counter&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述组件如果使用<code>Class</code>组件的写法，等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">export default class LearnReact extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            counter: 0,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    btnClick = () =&gt; &#123;</span><br><span class="line">        this.setState((prevState) =&gt; &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                counter: prevState.counter + 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;LearnHooks&lt;/h1&gt;</span><br><span class="line">                &lt;div&gt;current Counter: &#123;this.state.counter&#125;&lt;/div&gt;</span><br><span class="line">                &lt;button onClick=&#123;this.btnClick&#125;&gt;click to plus counter&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细体会一下两种写法的差异和优劣性，下面来仔细分析一下<code>state hook</code>的使用:</p>
<ol>
<li><p><code>const [counter,  setCounter] = useState(0)</code></p>
<p> 这句话定义了一个<code>counter</code>变量和一个用来修改定义的<code>counter</code>变量的方法<code>setCounter()</code>，定义的这个变量它与 <code>class</code>组件里面的<code>this.state</code>提供的功能完全相同。一般来说，在函数退出后变量就就会”消失”，<strong>而<code>state</code>中的变量会被<code>React</code>保留</strong>。</p>
</li>
<li><p><code>useState(0)</code></p>
<p> <code>useState()</code>只接收一个参数即定义的<code>state</code>变量的初始值，可以是对象也可以是其他原始类型等等。而<code>Class</code>组件的初始值则一定是在<code>this.state</code>中的这个对象里的属性，这是一个区别点。</p>
</li>
<li><p><code>useState()</code>的返回值</p>
<p> 经过上面的例子，我们已经可以得出，<code>useState</code>的返回值是<strong>一个数组</strong>，其内部元素依次为<strong>当前<code>state</code>以及更新<code>state</code>的函数</strong>, 每定义一个<code>state</code>都需要去成对的获取一下修改相应的<code>state</code>的方法。</p>
</li>
</ol>
<blockquote>
<p><code>useState(initialValue)</code>其<strong>是一个惰性的初始值，一旦初始化之后，后续<code>initialValue</code>就算有更新也会被忽略</strong></p>
</blockquote>
<h3 id="state-Hook中的事件处理函数"><a href="#state-Hook中的事件处理函数" class="headerlink" title="state Hook中的事件处理函数"></a>state Hook中的事件处理函数</h3><p>对于上述例子，更新<code>state</code>时传入的事件处理函数，注意不能直接写成:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;setCounter(counter + 1)&#125;&gt;click to plus counter&lt;/button&gt; // error!</span><br></pre></td></tr></table></figure>

<p>而是得写成回调形式，否则会直接执行一次<code>setCounter(counter + 1)</code>造成无限循环<code>render</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;() =&gt; setCounter(counter + 1)&#125;&gt;click to plus counter&lt;/button&gt; // correct!</span><br></pre></td></tr></table></figure>

<h3 id="定义多个state"><a href="#定义多个state" class="headerlink" title="定义多个state"></a>定义多个state</h3><p>当想要定义多个<code>state</code>时，重复调用多次<code>useState</code>就行了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const [age, setAge] = useState(42);</span><br><span class="line">const [fruit, setFruit] = useState(&apos;banana&apos;);</span><br><span class="line">const [todos, setTodos] = useState([&#123; text: &apos;学习 Hook&apos; &#125;]);</span><br></pre></td></tr></table></figure>

<p>但是在开发时要注意<code>state</code>的分离颗粒度。</p>
<h3 id="state-hook的更新"><a href="#state-hook的更新" class="headerlink" title="state hook的更新"></a>state hook的更新</h3><blockquote>
<p>值得注意的是, <code>useState</code>返回的修改<code>state</code>的方法对于<code>state</code>的修改，是<strong>单纯的替换而不是合并</strong></p>
</blockquote>
<p><code>useState</code>返回的修改<code>state</code>的方法对于<code>state</code>的修改，是<strong>单纯的替换而不是合并</strong>，来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;useState&#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">export default () =&gt; &#123;</span><br><span class="line">    const [obj, setObj] = useState(&#123;</span><br><span class="line">        name: &quot;Yang&quot;,</span><br><span class="line">        age: 23,</span><br><span class="line">        gender: &quot;male&quot;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    let changeObj = () =&gt; (</span><br><span class="line">        setObj(&#123;</span><br><span class="line">            name: &quot;Zhang&quot;</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;LearnHooks&lt;/h1&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Object.keys(obj).map(key =&gt; &#123;</span><br><span class="line">                    return (</span><br><span class="line">                        &lt;div key=&#123;key&#125;&gt;key: &#123;obj[key]&#125;&lt;/div&gt;</span><br><span class="line">                    )</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            &lt;button onClick=&#123;changeObj&#125;&gt;click to changeObj&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述例子中，调用<code>setObj({name: &quot;Zhang&quot;})</code>之后，</p>
<p><code>obj</code>的值由<code>{name: &quot;Yang&quot;, age: 23, gender: &quot;male&quot;}</code>直接变为了<code>{name: &quot;Zhang&quot;}</code>，</p>
<p>并没有像传统的<code>class</code>组件中调用<code>setState</code>那样对值进行合并，这一点要特别注意。</p>
<p><strong>且<code>State Hook</code>对于<code>state</code>的更新方法，也像<code>class</code>那样可以传入一个函数进行函数式更新</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setCounter((prevCounter) =&gt; &#123;</span><br><span class="line">    return prevCounter + 1;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Effect-Hook"><a href="#Effect-Hook" class="headerlink" title="Effect Hook"></a>Effect Hook</h2><p><code>Effect Hook</code>是针对于那些副作用操作（比如：<strong>数据获取</strong>，<strong>设置订阅</strong>以及手动<strong>更改<code>React</code>组件中的<code>DOM</code></strong>等）而使用的。</p>
<p>和<code>class</code>组件做比较的话，<code>Effect Hook</code>可以视为<code>componentDidMount</code>，<code>componentDidUpdate</code>和<code>componentWillUnmount</code>这三个钩子的组合。</p>
<h3 id="无需清除的effect的简单使用"><a href="#无需清除的effect的简单使用" class="headerlink" title="无需清除的effect的简单使用"></a>无需清除的effect的简单使用</h3><p>来看一个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;useState, useEffect&#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">export default () =&gt; &#123;</span><br><span class="line">    const [counter, setCounter] = useState(0);</span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">        //    第一次渲染之后和每次更新之后都会执行</span><br><span class="line">        document.title = `current Counter: $&#123;counter&#125;`</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;LearnHooks&lt;/h1&gt;</span><br><span class="line">            &lt;div&gt;current Counter: &#123;counter&#125;&lt;/div&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; setCounter(counter + 1)&#125;&gt;click to plus counter&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细的来分析一下这个最简单的例子：</p>
<p>首先我们定义了一个无需清除的<code>useEffect</code>,其内部接收一个函数作为参数，其内部的逻辑<strong>在默认情况下，在组件第一次渲染之后和每次更新之后都会执行</strong>。</p>
<p>然后由于其定义在函数内部，所以当前函数组件的<code>state</code>和<code>props</code>我们都可以在<code>useEffect</code>内部访问到</p>
<p><code>useEffect</code>传递的函数作为参数，会被称为<code>effect</code>被<code>React</code>保存起来，在这个函数内部，可以执行任意的副作用操作，<strong>且<code>React</code>保证了每次运行<code>effect</code>的同时，<code>DOM</code>都已经更新完毕</strong>。</p>
<blockquote>
<p>注意：由于<code>useEffect</code>其是异步的，所以不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快，但是如果需要<code>effect</code>同步执行，请使用<code>useLayoutEffect</code></p>
</blockquote>
<p>上面这样使用<code>useEffect</code>有一个潜在的好处是，开发者没必要去关心当前这个组件到底是第一次渲染还是处于更新状态</p>
<p>使用<code>Class</code>组件时经常会有<code>componentDidMount</code>和<code>componentDidUpdate</code>中存在相同逻辑的地方，<code>useEffect</code>使得这部分逻辑获得了简化</p>
<h3 id="需要清除的effect"><a href="#需要清除的effect" class="headerlink" title="需要清除的effect"></a>需要清除的effect</h3><p>一般使用<code>Class</code>组件时，我们会在<code>componentDidMount</code>进行一些数据的订阅，在<code>componentWillUnmount</code>中取消这部分的订阅</p>
<p>对于这样的<code>effect</code>，我们使用<code>useEffect</code>时就要有不一样的逻辑了</p>
<p>一般使用<code>Class</code>组件，我们需要将订阅和取消订阅操作放到2个不同的钩子函数中，但是使用<code>useEffect</code>时，这样的操作是放到一起的。</p>
<p><strong>只要在<code>useEffect</code>中<code>return</code>出一个函数后，返回的这个函数就会在执行清除操作时（<code>React</code>会在组件卸载的时候执行清除操作）调用它</strong>，这是<code>useEffect</code>的一个可选的清除机制</p>
<p>所以一般需要清除的<code>effect</code>的代码大概像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    //    第一次渲染之后和每次更新之后都会执行</span><br><span class="line">    Api.subscribeXXX(xxx);</span><br><span class="line"></span><br><span class="line">    return () =&gt; &#123; //  return的函数会在React执行清除操作时调用</span><br><span class="line">        Api.unsubscribeXXX(xxx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>接下来看一些<code>effect</code>常见的进阶用法</p>
<h3 id="使用多个Effect将不相关的逻辑分离开"><a href="#使用多个Effect将不相关的逻辑分离开" class="headerlink" title="使用多个Effect将不相关的逻辑分离开"></a>使用多个<code>Effect</code>将不相关的逻辑分离开</h3><p>使用<code>Class</code>组件的一个不好的地方就是开发者会被迫将不相关的逻辑放到同一个钩子函数中，跟<code>Vue</code>的<code>options Api</code>以及<code>composition Api</code>是一个道理。</p>
<p>而<code>useEffect</code>也像<code>useState</code>一样允许开发者定义多个，可以在同一个<code>useEffect</code>中专注于同一逻辑。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">export default () =&gt; &#123;</span><br><span class="line">    const [counter, setCounter] = useState(0);</span><br><span class="line">    useEffect(() =&gt; &#123; // 这个effect 只处理counter相关逻辑</span><br><span class="line">        document.title = `current Counter: $&#123;counter&#125;`;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    useEffect(() =&gt; &#123; // 这个effect只处理订阅逻辑</span><br><span class="line">        Api.subscribeXXX(xxx);</span><br><span class="line"></span><br><span class="line">        return () =&gt; &#123; //  return的函数会在React执行清除操作时调用</span><br><span class="line">            Api.unsubscribeXXX(xxx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;LearnHooks&lt;/h1&gt;</span><br><span class="line">            &lt;div&gt;current Counter: &#123;counter&#125;&lt;/div&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; setCounter(counter + 1)&#125;&gt;click to plus counter&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上例所示，我们可以根据代码的用途去定义多个<code>effect</code></p>
<h3 id="由于effect在每次重渲染时都会执行导致的性能问题及解决方案"><a href="#由于effect在每次重渲染时都会执行导致的性能问题及解决方案" class="headerlink" title="由于effect在每次重渲染时都会执行导致的性能问题及解决方案"></a>由于effect在每次重渲染时都会执行导致的性能问题及解决方案</h3><p>我们一直在强调，<code>effect</code>在<strong>组件第一次渲染及之后每次更新都会执行</strong></p>
<p>这样做的好处是解决了<code>Class</code>组件中经常存在的忘记在<code>componentDidUpdate</code>钩子中添加组件更新后的逻辑的问题</p>
<p>但是这样每次渲染后都执行清理或者执行<code>effect</code>也带来了性能问题</p>
<p>传统的<code>Class</code>组件可以在<code>componentDidUpdate</code>中进行对比<code>prevProps</code>或<code>prevState</code>来进行跳过执行逻辑</p>
<p>相应的，使用<code>useEffect</code>也有对应的功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123; // 这个effect 只处理counter相关逻辑</span><br><span class="line">    document.title = `current Counter: $&#123;counter&#125;`;</span><br><span class="line">&#125;, [counter]); // 仅在 counter 更改时更新</span><br></pre></td></tr></table></figure>

<p>我们可以通过给<code>useEffect</code>传递<strong>一个数组</strong>作为其第二个参数来达到效果，<strong>如果某些特定值在两次重渲染之间没有发生变化，就可以跳过对<code>effect</code>的调用</strong></p>
<p>值得注意的是，如果数组中有多个元素，即使<strong>只有一个元素发生变化，<code>React</code>也会执行<code>effect</code></strong></p>
<p>如果想执行<strong>只运行一次的<code>effect</code>（仅在组件挂载和卸载时执行）</strong>，可以<strong>传递一个空数组（<code>[]</code>）作为第二个参数</strong>。这就告诉<code>React</code>你的<code>effect</code>不依赖于<code>props</code>或<code>state</code>中的任何值，所以它永远都不需要重复执行。</p>
<p>如果你传入了一个空数组（<code>[]</code>），<code>effect</code>内部的<code>props</code>和<code>state</code>就会一直会是其初始值。</p>
<blockquote>
<p>另外<code>React</code>会等待浏览器完成画面渲染之后才会延迟调用<code>useEffect</code>，因此会使得额外操作很方便。</p>
</blockquote>
<h2 id="自定义Hook"><a href="#自定义Hook" class="headerlink" title="自定义Hook"></a>自定义Hook</h2><p>自定义<code>Hook</code>是一个函数，其名称<strong>必须以<code>use</code>开头</strong>，函数内部可以调用其他的<code>Hook</code>。</p>
<p>每次使用自定义<code>Hook</code>时，<strong>其中的所有<code>state</code>和副作用都是完全隔离独立的</strong>。</p>
<p>来看一个使用自定义<code>Hook</code>的例子</p>
<p>假设现在有一个记录页面已经打开了多少秒的组件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">export default () =&gt; &#123;</span><br><span class="line">    const [seconds, setSeconds] = useState(0);</span><br><span class="line">    let timer;</span><br><span class="line"></span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">        timer = setInterval(() =&gt; &#123;</span><br><span class="line">            setSeconds(seconds + 1);</span><br><span class="line">        &#125;, 1000);</span><br><span class="line"></span><br><span class="line">        return () =&gt; &#123;</span><br><span class="line">            console.log(&quot;Total Seconds: &quot;, seconds);</span><br><span class="line">            clearInterval(timer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;span&gt;页面已经渲染了&#123;seconds&#125;秒&lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时别的组件刚好也需要这个计时功能，就可以将其内部计数的逻辑单独抽出来，定义为一个自定<code>Hook</code>,比如我们定义为<code>useSeconds</code>,内部逻辑为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// useSeconds.js</span><br><span class="line">import &#123;useState, useEffect&#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">export default function useSeconds() &#123;</span><br><span class="line">    const [seconds, setSeconds] = useState(0);</span><br><span class="line">    let timer;</span><br><span class="line"></span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">       timer = setInterval(() =&gt; &#123;</span><br><span class="line">           setSeconds(seconds + 1);</span><br><span class="line">       &#125;,1000);</span><br><span class="line">       return () =&gt; &#123;</span><br><span class="line">           console.log(&quot;Total Seconds: &quot;, seconds);</span><br><span class="line">           clearInterval(timer);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return seconds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时我们就可以进行使用这个自定义<code>Hook</code>了，在原来的组件里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import useSeconds from &quot;./useSeconds&quot;;</span><br><span class="line"></span><br><span class="line">export default () =&gt; &#123;</span><br><span class="line">    const seconds = useSeconds();</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;span&gt;页面已经渲染了&#123;seconds&#125;秒&lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在另外想复用的组件里也可以直接引入使用，且多个自定义<code>Hook</code>之间的<code>state</code>和<code>effect</code>是相互独立的。</p>
<p>当然由于自定义<code>Hook</code>就是一个函数，也可以通过调用使用传入参数传递信息。</p>
<p>从上例中我们可以看出：<strong>自定义<code>Hook</code>解决了以前在<code>React</code>组件中无法灵活共享逻辑的问题。</strong></p>
<h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><p>接收一个<code>context</code>对象（<code>React.createContext</code>的返回值）并返回该<code>context</code>的当前值。该<code>Hook</code>能够读取<code>context</code>的值以及订阅<code>context</code>的变化。</p>
<p>来看一个简单使用的例子, 假设有如下<code>Theme</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">const themes = &#123;</span><br><span class="line">    light: &#123;</span><br><span class="line">        foreground: &quot;#000000&quot;,</span><br><span class="line">        background: &quot;#eeeeee&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    dark: &#123;</span><br><span class="line">        foreground: &quot;#ffffff&quot;,</span><br><span class="line">        background: &quot;#222222&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const ThemeContext = React.createContext(themes.light);</span><br><span class="line">export  &#123;</span><br><span class="line">    themes,</span><br><span class="line">    ThemeContext,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时在<code>&lt;App /&gt;</code>中应用这个<code>Context</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;useState, useEffect&#125; from &apos;react&apos;;</span><br><span class="line">import LearnHooks from &quot;./components/LearnHooks&quot;;</span><br><span class="line">import &#123; themes, ThemeContext &#125; from &quot;./components/Theme&quot;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">    const [theme, setTheme] = useState(themes.dark);</span><br><span class="line">    </span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            setTheme(themes.light); // 3s后将主题改为白色</span><br><span class="line">        &#125;, 3000)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">            &lt;ThemeContext.Provider value=&#123;theme&#125;&gt;</span><br><span class="line">                &lt;LearnHooks/&gt;</span><br><span class="line">            &lt;/ThemeContext.Provider&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>

<p>此时在我们的目标组件中，就可以进行使用<code>useContext</code>来进行获取<code>Context</code>了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;useContext&#125; from &quot;react&quot;;</span><br><span class="line">import &#123; ThemeContext &#125; from &quot;./Theme&quot;;</span><br><span class="line"></span><br><span class="line">export default () =&gt; &#123;</span><br><span class="line">    const theme = useContext(ThemeContext); // 获取theme</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;p style=&#123;&#123; background: theme.background, color: theme.foreground &#125;&#125;&gt;</span><br><span class="line">            normal Text</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><p>用法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [state, dispatch] = useReducer(reducer, initialArg, init);</span><br></pre></td></tr></table></figure>

<p>在 <code>state</code>逻辑较复杂且包含多个子值，或者下一个<code>state</code>依赖于之前的<code>state</code>等场景下，可以用来代替<code>useState()</code>,同时<code>useReducer</code>的优势在于还会对深层次组件更新做优化。</p>
<p><code>useReducer</code>最多可以接收三个参数：</p>
<ul>
<li>第一个参数<code>reducer</code>是<code>(state, action) =&gt; newState</code>类型的函数</li>
<li>第二个参数如果在第三个参数未传的情况下，是直接作为<code>state</code>的初始值的，但是如果传入了第三个参数，那么初始值为<code>init(initialArg)</code></li>
<li>第三个参数是可选的一个函数，参数为<code>initialArg</code>, 返回<code>state</code>的初始值（传入<code>init</code>时为惰性的初始化<code>state</code>）。</li>
</ul>
<p>看一个基本使用的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;useReducer&#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">function reducer(state, action) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &apos;increment&apos;:</span><br><span class="line">            return &#123;count: state.count + 1&#125;;</span><br><span class="line">        case &apos;decrement&apos;:</span><br><span class="line">            return &#123;count: state.count - 1&#125;;</span><br><span class="line">        default:</span><br><span class="line">            throw new Error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function init(initialCount) &#123;</span><br><span class="line">    return &#123;count: initialCount&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default () =&gt; &#123;</span><br><span class="line">    const [state, dispatch] = useReducer(reducer, 0, init);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            Count: &#123;state.count&#125;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &apos;decrement&apos;&#125;)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &apos;increment&apos;&#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="useCallback-和-useMemo"><a href="#useCallback-和-useMemo" class="headerlink" title="useCallback 和 useMemo"></a><code>useCallback</code> 和 <code>useMemo</code></h2><p>这2个<code>hook</code>都是作为性能优化手段来使用的，也能使用其特性达成一些特殊用途。且<code>useMemo</code>可以实现<code>useCallback</code></p>
<p>相关用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// useCallback:</span><br><span class="line">const memoizedCallback = useCallback(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    doSomething(a, b);</span><br><span class="line">  &#125;,</span><br><span class="line">  [a, b],</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// useMemo:</span><br><span class="line">const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>useCallback(fn, deps)</code>相当于<code>useMemo(() =&gt; fn, deps)</code>。</p>
</blockquote>
<p>2者都是返回一个<code>memoized</code>过后的函数/值，第二个参数和<code>useEffect</code>类似为依赖项，如果依赖项有改变的话，<code>memoized</code>的值或者函数才会得到更新。</p>
<p>如果依赖传入一个<code>[]</code>或者依赖未发生改变的话，其<code>memoized</code>的函数或者值的引用地址是不会改变的（同一块内存区域），利用这一特性，可以配合类似于<code>shouldComponentUpdate</code>的机制来进行避免重复渲染。</p>
<h3 id="使用useCallback和useMemo的场景举例"><a href="#使用useCallback和useMemo的场景举例" class="headerlink" title="使用useCallback和useMemo的场景举例"></a>使用<code>useCallback</code>和<code>useMemo</code>的场景举例</h3><p>了解了基本概念之后，<a href="https://juejin.im/post/5db14bf2e51d452a161df297" target="_blank" rel="noopener">这篇文章</a>举了个例子展示了<code>useCallback</code>及<code>useMemo</code>的使用。</p>
<p>大概例子是有这么一个防抖函数，在鼠标滑动的时候去触发：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// generateDebounce.js</span><br><span class="line"></span><br><span class="line">function generateDebounce(func, delay=1000) &#123;</span><br><span class="line">    let timer;</span><br><span class="line">    function debounce(...args) &#123;</span><br><span class="line">        debounce.cancel();</span><br><span class="line">        timer = setTimeout(() =&gt; &#123;</span><br><span class="line">            console.count(&quot;func called&quot;);</span><br><span class="line">            func.apply(this, args);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    debounce.cancel = function () &#123;</span><br><span class="line">        if (timer !== undefined) &#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer = undefined;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return debounce;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数调用之后返回一个防抖函数<code>debounce</code>，然后在如下组件中进行防抖使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;useState&#125; from &quot;react&quot;;</span><br><span class="line">import generateDebounce from &quot;./generateDebounce&quot;;</span><br><span class="line"></span><br><span class="line">export default () =&gt; &#123;</span><br><span class="line">    const [count, setCount] = useState(0);</span><br><span class="line">    const [bounceCount, setBounceCount] = useState(0);</span><br><span class="line">    const debounceSetCount = generateDebounce(setBounceCount); // 每次更新渲染都会重新创建一个debounceSetCount</span><br><span class="line"></span><br><span class="line">    const handleMouseMove = () =&gt; &#123;</span><br><span class="line">        setCount(count + 1);</span><br><span class="line">        debounceSetCount(bounceCount + 1);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div onMouseMove=&#123;handleMouseMove&#125;&gt;</span><br><span class="line">            &lt;p&gt;普通移动次数: &#123;count&#125;&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;防抖处理后移动次数: &#123;bounceCount&#125;&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述例子中，我们可以看到，虽然<code>bounceCount</code>增加的不多，但是其实内部的<code>console.count(&quot;func called&quot;);</code>执行的次数和未做防抖的次数<code>count</code>是一样的</p>
<p>也就是说并没有达到防抖的效果，造成这个现象的原因是：</p>
<p>每次执行<code>onMouseMove</code>都会导致组件的重新渲染，整个函数组件将会被重新执行</p>
<p>即意味着<code>const debounceSetCount = generateDebounce(setBounceCount);</code>这句每次都会执行，会创建很多个新的<code>debounceSetCount</code>，所以其不同的<code>debounce</code>其实是使用很多个不同的<code>timer</code>,这就造成了我们看到的调用次数并没有减少的情况</p>
<p>但是<code>bounceCount</code>增加的并没有像<code>count</code>那么快的原因就是在执行<code>onMouseMove</code>时疯狂的传入了很多次一样的参数，而在异步函数中执行增加操作时，其实都是一个相同的值在加一，所以<code>bounceCount</code>没有增加到函数调用次数那么大，但是本质上，函数还是调用了很多次的。</p>
<h3 id="使用useCallback举例"><a href="#使用useCallback举例" class="headerlink" title="使用useCallback举例"></a>使用<code>useCallback</code>举例</h3><p>花了这么多篇幅讲通这个例子的原路，现在来看怎么修复，我们通过<code>useCallback</code>创建一个<code>memoized</code>函数，依赖为<code>[]</code>, 这样一来，我们创建的这个<code>debounceSetCount</code>函数的引用就一直是同一个地址，这样就组件每次更新时，由于依赖为<code>[]</code>，函数一直不会更新，永远为同一个函数，即可达到效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default () =&gt; &#123;</span><br><span class="line">    const [count, setCount] = useState(0);</span><br><span class="line">    const [bounceCount, setBounceCount] = useState(0);</span><br><span class="line">    // const debounceSetCount = generateDebounce(setBounceCount);</span><br><span class="line">    // 改用callback创建一个 memoized 函数，依赖为[]即永远保存同一块内存中的这个 debounceSetCount 函数</span><br><span class="line">    const debounceSetCount = useCallback(generateDebounce(setBounceCount), []);</span><br><span class="line">    </span><br><span class="line">    // 省略下面代码。。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用useMemo举例"><a href="#使用useMemo举例" class="headerlink" title="使用useMemo举例"></a>使用<code>useMemo</code>举例</h3><p>上面例子中，也可以直接使用<code>useMemo</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// const debounceSetCount = generateDebounce(setBounceCount);</span><br><span class="line">// const debounceSetCount = useCallback(generateDebounce(setBounceCount), []);</span><br><span class="line">const debounceSetCount = useMemo(() =&gt; generateDebounce(setBounceCount), []);</span><br></pre></td></tr></table></figure>

<p>达到的效果是一样的。也能创建一个唯一的<code>debounceSetCount</code>函数</p>
<p>关于<code>useMemo</code>,官方建议我们，<strong>先不要使用<code>useMemo</code>编写可用的代码，然后再引入<code>useMemo</code>仅仅作为性能优化的手段</strong>，因为官方说了<code>useMemo</code>不一定能作为一个保证来使用</p>
<blockquote>
<p>关于<code>useMemo</code>引自文档： <strong>You may rely on useMemo as a performance optimization, not as a semantic guarantee.</strong> In the future, React may choose to “forget” some previously memoized values and recalculate them on next render, e.g. to free memory for offscreen components. </p>
</blockquote>
<h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><p>用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const ref = useRef(initialValue);</span><br></pre></td></tr></table></figure>

<p>和<code>Class</code>组件一样，<code>useRef</code>提供了在函数组件中使用<code>ref</code>的方法，其参数<code>initialValue</code>为给<code>ref</code>设置的初始值，该值在<code>useEffect</code>之中就已经被重新赋值为目标<code>DOM</code></p>
<p>来看使用例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;useRef, useEffect&#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default () =&gt; &#123;</span><br><span class="line">    const testRef = useRef(null); // 给null作为初始值</span><br><span class="line">    console.log(testRef); // &#123;current: null&#125;</span><br><span class="line"></span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">        console.log(testRef); // 输出 &#123;current: div&#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div ref=&#123;testRef&#125;&gt;</span><br><span class="line">            normal Text</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当<code>ref</code>对象内容发生变化时，<code>useRef</code>并不会通知更新。且变更<code>.current</code>属性也不会引发组件重新渲染。</p>
</blockquote>
<p>如果想要在<code>React</code>绑定或解绑<code>DOM</code>节点的<code>ref</code> 时运行某些代码，则需要使用回调<code>ref</code>来实现。</p>
<p>来看一个不使用<code>useRef</code>而是使用回调<code>ref</code>的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">export default () =&gt; &#123;</span><br><span class="line">    const [isShow, setIsShow] = useState(true);</span><br><span class="line">    const callbackRef = useCallback((domNode) =&gt; &#123;</span><br><span class="line">        console.log(domNode); // 在ref附加到节点上时自动调用  在节点卸载时也会自动调用 输出null</span><br><span class="line">    &#125;, []);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;React.Fragment&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                isShow &amp;&amp;</span><br><span class="line">                &lt;h1 ref=&#123;callbackRef&#125;&gt;</span><br><span class="line">                    &lt;div&gt;Hello, ref&lt;/div&gt;</span><br><span class="line">                &lt;/h1&gt;</span><br><span class="line">            &#125;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; (setIsShow(false))&#125;&gt;click&lt;/button&gt;</span><br><span class="line">        &lt;/React.Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们分析下上述例子：使用<code>useCallback</code>声明一个<code>callbackRef</code>，传入的依赖为<code>[]</code>,所以其<code>ref</code>不会在组件重新渲染时改变。</p>
<p><strong>使用回调<code>ref</code>的优点是，节点发生变化的时候，会自动调用目标回调</strong>，而使用<code>useRef</code>时，节点对象发生变化时，<code>useRef</code>并不会通知你（当然可以手动写一个<code>useEffect</code>去主动获取<code>ref</code>对象，是可以拿到最新的对象的）</p>
<h2 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h2><p>用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useImperativeHandle(ref, createHandle, [deps])</span><br></pre></td></tr></table></figure>

<p><code>useImperativeHandle</code>是和<code>forwardRef</code>搭配使用实现<code>refs</code>转发的,来看使用例子，现有父组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export default () =&gt; &#123;</span><br><span class="line">    const supRef = useRef(null);</span><br><span class="line"></span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">        console.log(supRef);</span><br><span class="line">        supRef.current.focus();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;ImperativeHandle ref=&#123;supRef&#125; /&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而子组件里的逻辑为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// ImperativeHandle.js</span><br><span class="line">import React, &#123;useRef, useImperativeHandle&#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">export default React.forwardRef((props, ref) =&gt; &#123;</span><br><span class="line">    const subRef = useRef(null);</span><br><span class="line"></span><br><span class="line">    useImperativeHandle(ref, () =&gt; subRef.current);</span><br><span class="line"></span><br><span class="line">    return &lt;input ref=&#123;subRef&#125; /&gt;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>而<code>useImperativeHandle</code>的功能在于，<strong>在使用<code>ref</code>时自定义暴露给父组件的实例值</strong>,上述例子中我们通过使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useImperativeHandle(ref, () =&gt; subRef.current);</span><br></pre></td></tr></table></figure>

<p>直接暴露出了整个<code>subRef.current</code>，我们可以自定义决定暴露出什么，比如我们改为暴露一个<code>subFocus</code>方法而不是暴露整个<code>subRef</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// ImperativeHandle.js</span><br><span class="line">    &lt;!--省略其他代码--&gt;</span><br><span class="line">    useImperativeHandle(ref, () =&gt; &#123; // 可以自定义决定暴露什么内容给父组件</span><br><span class="line">        return &#123;</span><br><span class="line">            subFocus: () =&gt; &#123;</span><br><span class="line">                subRef.current.focus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>在父组件中获取到的<code>supRef.current</code>也发生了相应的改变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export default () =&gt; &#123;</span><br><span class="line">    const supRef = useRef(null);</span><br><span class="line"></span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">        // 在这获取到的supRef.current 就是子组件通过 useImperativeHandle 自定义暴露出的内容</span><br><span class="line">        supRef.current.subFocus(); // 调用暴露出的subFocus()</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;ImperativeHandle ref=&#123;supRef&#125; /&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h2><p><code>useLayoutEffect</code>和<code>useEffect</code>的区别在于:<code>useLayoutEffect</code>会在所有的<code>DOM</code>变更之后<strong>同步调用</strong><code>effect</code>。</p>
<p>可以使用它来读取<code>DOM</code>布局并同步触发重渲染。在浏览器执行绘制之前，<code>useLayoutEffect</code>内部的更新计划将被同步刷新。</p>
<p>其调用阶段和<code>componentDidMount</code>、<code>componentDidUpdate</code> 的调用阶段是一样的</p>
<p>但是一般只有特殊情况才会使用到，一般建议使用<code>useEffect</code>来避免阻塞加载从而提高用户体验</p>
<h2 id="一些补充"><a href="#一些补充" class="headerlink" title="一些补充"></a>一些补充</h2><h3 id="react-hooks-异步获取数据"><a href="#react-hooks-异步获取数据" class="headerlink" title="react hooks 异步获取数据"></a>react hooks 异步获取数据</h3><p><a href="https://www.robinwieruch.de/react-hooks-fetch-data" target="_blank" rel="noopener">扩展阅读：How to fetch data with React Hooks?</a></p>
<h3 id="useRef的额外用法"><a href="#useRef的额外用法" class="headerlink" title="useRef的额外用法"></a><code>useRef</code>的额外用法</h3><p> <code>useRef</code>不仅可以用于<code>DOM refs</code>。<strong><code>ref</code>对象还是一个<code>current</code>属性可变且可以容纳任意值的通用容器</strong>,可以作为当前组件中的全局变量进行使用。</p>
<p> 比如说：作为一个<code>timerID</code>,在卸载组件的时候进行消除</p>
<h4 id="使用useRef让effect只在组件更新时执行"><a href="#使用useRef让effect只在组件更新时执行" class="headerlink" title="使用useRef让effect只在组件更新时执行"></a>使用<code>useRef</code>让<code>effect</code>只在组件更新时执行</h4><p> 通过使用<code>useRef</code>，可以达到一个使<code>useEffect</code>只在组件更新时(类似于<code>componentDidUpdate</code>)进行执行<code>effect</code>而在组件第一次渲染时(类似于<code>componentDidMount</code>)不执行<code>effect</code>:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> export default () =&gt; &#123;</span><br><span class="line">    const [counter, setCounter] = useState(0);</span><br><span class="line">    const isFirstRender = useRef(true); // 设置默认 是否第一次渲染为true</span><br><span class="line"></span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">        if(!isFirstRender.current) &#123; // 已经不是第一次渲染 而是后续组件更新</span><br><span class="line">            console.log(&quot;componentDidUpdate&quot;);</span><br><span class="line">            //    目标 effect的逻辑可以在这执行</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            isFirstRender.current = false; // 第一次渲染之后将值置为false</span><br><span class="line">            console.log(&quot;componentDidMount&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;div&gt;counter: &#123;counter&#125;&lt;/div&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; setCounter(counter + 1)&#125;&gt;click to reRender component&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过useRef获取上一轮的props或者state"><a href="#通过useRef获取上一轮的props或者state" class="headerlink" title="通过useRef获取上一轮的props或者state"></a>通过<code>useRef</code>获取上一轮的<code>props</code>或者<code>state</code></h4><p>可以通过<code>useRef</code>和<code>useEffect</code>来进行记录存储上一次的<code>state</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">export default () =&gt; &#123;</span><br><span class="line">    const [counter, setCounter] = useState(0);</span><br><span class="line">    const prevCounter = useRef();</span><br><span class="line"></span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">        prevCounter.current = counter;</span><br><span class="line">        console.log(&quot;counter: &quot;, counter);</span><br><span class="line">        console.log(&quot;prevCounter: &quot;, prevCounter.current); // 这里获取的prevCounter和counter是一致的</span><br><span class="line">        //  这的逻辑是较晚异步执行的</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    console.log(prevCounter.current); // 在这里获取的prevCounter 为前一次的值</span><br><span class="line">    // useEffect是异步执行  所以在这的逻辑是较早执行的</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;div&gt;counter: &#123;counter&#125;&lt;/div&gt;</span><br><span class="line">            &lt;div&gt;prevCounter: &#123;prevCounter.current&#125;&lt;/div&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; setCounter(counter + 1)&#125;&gt;click to reRender component&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果该逻辑经常用到的话，可以考虑封装为一个自定义<code>hook</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function usePrevious(value) &#123;</span><br><span class="line">  const ref = useRef();</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    ref.current = value;</span><br><span class="line">  &#125;);</span><br><span class="line">  return ref.current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="组件中的函数读取state和prop出现不及时更新的情况"><a href="#组件中的函数读取state和prop出现不及时更新的情况" class="headerlink" title="组件中的函数读取state和prop出现不及时更新的情况"></a>组件中的函数读取<code>state</code>和<code>prop</code>出现不及时更新的情况</h4><p>造成在组件内函数中拿到的<code>state</code>和<code>prop</code>不是最新的原因有两个:</p>
<ol>
<li>如果是使用的<code>useEffect</code>，可能是依赖数组中提供了<code>[]</code>或者依赖项没有提供全.</li>
<li>组件内部的任何函数，包括事件处理函数和<code>effect</code>，其内部拿到的值都是其被声明的那一次渲染中获取的</li>
</ol>
<p>其中第1点可能很好理解，解决方案就是修正给<code>useEffect</code>提供的依赖数组即可</p>
<p>下面解释一下第2点：假设现有如下例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">export default () =&gt; &#123;</span><br><span class="line">    const [counter, setCounter] = useState(0);</span><br><span class="line"></span><br><span class="line">    function handleAlertClick() &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            alert(&apos;You clicked on: &apos; + counter);</span><br><span class="line">        &#125;, 3000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;counter&#125; times&lt;/p&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; setCounter(counter + 1)&#125;&gt;</span><br><span class="line">                Click me</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;handleAlertClick&#125;&gt;</span><br><span class="line">                Show alert</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述组件中，点击了<code>show alert</code>按钮之后，再点击数次<code>click me</code>按钮去增加<code>counter</code> 可以看到，3s后会输出当时3s前点击<code>show alert</code>时的<code>counter</code>,而不是目前页面显示的<code>counter</code></p>
<p>要理解这种情况发生的原因，需要理解2点：</p>
<ol>
<li><strong>每次点击<code>click me</code>去更新<code>state</code>的时候，整个函数组件的逻辑都会被重新执行，所以事件处理函数<code>handleAlertClick</code>每次都会被重复声明</strong></li>
<li>明确了第1点之后，那么<strong>每次重新声明的<code>handleAlertClick</code>内部都只能拿到当前这次渲染中的<code>state</code></strong></li>
</ol>
<p>我们在上例中，先点击一次<code>handleAlertClick</code>，其只能拿到当前这次渲染时的<code>counter</code>即<code>0</code>，然后我们点击数次<code>click me</code>并不会改变第一次声明的这个<code>handleAlertClick</code>中拿到的<code>counter</code>值，所以即会造成上述情况。</p>
<p>而这种情况，也是会造成在函数中拿到的值是陈旧的情况，针对这种情况，如果想要去获取到最新的<code>state</code>和<code>prop</code>的话，可以在值更新后的异步回调中去创建一个<code>ref</code>去存储其最新值。</p>
<p>使用<code>ref</code>存储的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">export default () =&gt; &#123;</span><br><span class="line">    const [counter, setCounter] = useState(0);</span><br><span class="line">    const latestVal = useRef(null);</span><br><span class="line"></span><br><span class="line">    function handleAlertClick() &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            alert(&apos;You clicked on: &apos; + counter);</span><br><span class="line">            alert(&apos;latest counter: &apos; + latestVal.current);</span><br><span class="line">        &#125;, 3000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">        latestVal.current = counter; // 在这使用ref存储最新的值</span><br><span class="line">    &#125;, [counter]);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;counter&#125; times&lt;/p&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; setCounter(counter + 1)&#125;&gt;</span><br><span class="line">                Click me</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;handleAlertClick&#125;&gt;</span><br><span class="line">                Show alert</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在函数组件中使用hook达到static-getDerivedStateFromProps的效果"><a href="#在函数组件中使用hook达到static-getDerivedStateFromProps的效果" class="headerlink" title="在函数组件中使用hook达到static getDerivedStateFromProps的效果"></a>在函数组件中使用<code>hook</code>达到<code>static getDerivedStateFromProps</code>的效果</h4><blockquote>
<p>如果你的<strong>组件中<code>state</code>的值在任何时候都取决于<code>props</code>的时候</strong>，这种情况才考虑使用<code>static getDerivedStateFromProps</code>, 用之前考虑一下，如果不是这种情况，那么<a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#when-to-use-derived-state" target="_blank" rel="noopener">you-probably-dont-need-derived-state</a></p>
</blockquote>
<p>针对这种情况，<code>React</code>有一个机制是：如果在渲染过程中更新<code>state</code>的话，那么<code>React</code>会<strong>立即退出上一次渲染</strong>并用更新后的 <code>state</code>重新运行组件以避免耗费太多性能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function ScrollView(&#123;row&#125;) &#123;</span><br><span class="line">    let [isScrollingDown, setIsScrollingDown] = useState(false);</span><br><span class="line">    let [prevRow, setPrevRow] = useState(null);</span><br><span class="line"></span><br><span class="line">    // 每次父组件props.row改变时，在这做拦截判断，如果没改变那么按逻辑return，</span><br><span class="line">    // 如果props.row改变了，那么直接在这setState更新，跳过当前这次渲染，直接使用新的state运行下次组件逻辑</span><br><span class="line">    if (row !== prevRow) &#123;</span><br><span class="line">        // Row 自上次渲染以来发生过改变。更新 isScrollingDown。</span><br><span class="line">        setIsScrollingDown(prevRow !== null &amp;&amp; row &gt; prevRow);</span><br><span class="line">        setPrevRow(row);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return `Scrolling down: $&#123;isScrollingDown&#125;`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述是官方举的一个例子，该组件接收一个<code>props</code>为<code>row</code>，目标组件中<code>state</code>依赖<code>props.row</code>进行更新，本组件中如果父组件滚动时，子组件的逻辑会判断<code>props.row</code>,如果确定向下滚动了，那么直接调用<code>setState</code>更新<code>state</code>，跳过当前这次渲染，直接使用新的<code>state</code>运行下次组件逻辑</p>
<h4 id="实现类似于React-PureComponent的效果"><a href="#实现类似于React-PureComponent的效果" class="headerlink" title="实现类似于React.PureComponent的效果"></a>实现类似于<code>React.PureComponent</code>的效果</h4><p>可以通过<code>React.memo</code>来达到效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const Button = React.memo((props) =&gt; &#123;</span><br><span class="line">  // 你的组件</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>React.memo</code>等效于<code>PureComponent</code>，但它<strong>只比较<code>props</code></strong>, 不比较<code>state</code>。</p>
<blockquote>
<p>也可以通过第二个参数指定一个自定义的比较函数来比较新旧 props。如果函数返回 true，就会跳过更新</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 第二个参数指定一个自定义的比较函数来比较新旧 props</span><br><span class="line">const compare = (prevProp, currentProp) =&gt; &#123;</span><br><span class="line">    return prevProp.children === currentProp.children; // return true 代表跳过更新</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default React.memo((props) =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;div&gt;hello world&lt;/div&gt;</span><br><span class="line">            &#123;props.children&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;, compare)</span><br></pre></td></tr></table></figure>

</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">DeeJay</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://deejay0921.github.io/2019/12/09/React Hooks的基本介绍/">https://deejay0921.github.io/2019/12/09/React Hooks的基本介绍/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://deejay0921.github.io">DeeJay's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/前端/">前端    </a><a class="post-meta__tags" href="/tags/React/">React    </a></div><div class="post_share"><div class="social-share" data-image="https://showmethecode.com.br/images/posts/react-hooks/banner.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2019/11/26/React的基本使用/"><img class="next_cover lazyload" data-src="https://blog.dashlane.com/wp-content/uploads/2016/02/react-logo-2.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>React的基本使用</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/11/26/React的基本使用/" title="React的基本使用"><img class="relatedPosts_cover lazyload" data-src="https://blog.dashlane.com/wp-content/uploads/2016/02/react-logo-2.png"><div class="relatedPosts_title">React的基本使用</div></a></div><div class="relatedPosts_item"><a href="/2019/11/07/TypeScript中的声明文件/" title="TypeScript中的声明文件"><img class="relatedPosts_cover lazyload" data-src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2018/08/typescriptfeature.png"><div class="relatedPosts_title">TypeScript中的声明文件</div></a></div><div class="relatedPosts_item"><a href="/2017/08/06/CSS-垂直居中的几种实现思路方法/" title="CSS-垂直居中的几种实现思路方法"><img class="relatedPosts_cover lazyload" data-src="https://content.linkedin.com/content/dam/me/learning/blog/2016/september/CSS.jpg"><div class="relatedPosts_title">CSS-垂直居中的几种实现思路方法</div></a></div><div class="relatedPosts_item"><a href="/2017/08/04/CSS-3-Flex布局/" title="CSS-3-Flex布局"><img class="relatedPosts_cover lazyload" data-src="https://blog.paradisetechsoft.com/content/images/size/w2000/2019/08/CSS-FLEX-BLOG-BANNER-IMAGE.png"><div class="relatedPosts_title">CSS-3-Flex布局</div></a></div><div class="relatedPosts_item"><a href="/2017/08/01/CSS居中/" title="CSS居中"><img class="relatedPosts_cover lazyload" data-src="https://content.linkedin.com/content/dam/me/learning/blog/2016/september/CSS.jpg"><div class="relatedPosts_title">CSS居中</div></a></div><div class="relatedPosts_item"><a href="/2017/07/30/CSS基础/" title="CSS基础"><img class="relatedPosts_cover lazyload" data-src="https://content.linkedin.com/content/dam/me/learning/blog/2016/september/CSS.jpg"><div class="relatedPosts_title">CSS基础</div></a></div></div><div class="clear_both"></div></div></div></div><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2019 By DeeJay</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script></body></html>